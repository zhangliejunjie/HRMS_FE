import {
  HTMLElementType,
  chainPropTypes,
  composeClasses,
  createChainedFunction,
  createPopper,
  createStyled,
  createTheme_default,
  darken,
  debounce,
  deepmerge,
  elementAcceptingRef_default,
  exactProp,
  generateUtilityClass,
  generateUtilityClasses,
  getContrastRatio,
  getScrollbarSize,
  init_esm,
  init_esm2,
  init_lib,
  integerPropType_default,
  lighten,
  ownerDocument,
  ownerWindow,
  refType_default,
  setRef,
  shouldForwardProp,
  useControlled,
  useEnhancedEffect_default,
  useEventCallback,
  useForkRef,
  useId,
  useIsFocusVisible,
  usePreviousProps_default,
  useThemeProps,
  visuallyHidden_default
} from "./chunk-53MQOFU6.js";
import {
  _objectWithoutPropertiesLoose,
  init_objectWithoutPropertiesLoose
} from "./chunk-EBW3JKEH.js";
import {
  _extends,
  init_extends
} from "./chunk-SUFR5NQW.js";
import {
  require_react_dom
} from "./chunk-AGYRAQNY.js";
import {
  clsx_m_default,
  init_clsx_m
} from "./chunk-4JNWWNIS.js";
import {
  require_prop_types
} from "./chunk-5BMR7XGB.js";
import {
  require_jsx_runtime
} from "./chunk-ULI4Y4G7.js";
import {
  require_react
} from "./chunk-KL6BCPSF.js";
import {
  __commonJS,
  __esm,
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/@mui/base/AutocompleteUnstyled/useAutocomplete.js
function stripDiacritics(string) {
  return typeof string.normalize !== "undefined" ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
}
function createFilterOptions(config = {}) {
  const {
    ignoreAccents = true,
    ignoreCase = true,
    limit,
    matchFrom = "any",
    stringify,
    trim = false
  } = config;
  return (options, {
    inputValue,
    getOptionLabel
  }) => {
    let input = trim ? inputValue.trim() : inputValue;
    if (ignoreCase) {
      input = input.toLowerCase();
    }
    if (ignoreAccents) {
      input = stripDiacritics(input);
    }
    const filteredOptions = options.filter((option) => {
      let candidate = (stringify || getOptionLabel)(option);
      if (ignoreCase) {
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
    });
    return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
  };
}
function findIndex(array, comp) {
  for (let i = 0; i < array.length; i += 1) {
    if (comp(array[i])) {
      return i;
    }
  }
  return -1;
}
function useAutocomplete(props) {
  const {
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    componentName = "useAutocomplete",
    defaultValue = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled: disabledProp,
    disabledItemsFocusable = false,
    disableListWrap = false,
    filterOptions = defaultFilterOptions,
    filterSelectedOptions = false,
    freeSolo = false,
    getOptionDisabled,
    getOptionLabel: getOptionLabelProp = (option) => {
      var _option$label;
      return (_option$label = option.label) != null ? _option$label : option;
    },
    groupBy,
    handleHomeEndKeys = !props.freeSolo,
    id: idProp,
    includeInputInList = false,
    inputValue: inputValueProp,
    isOptionEqualToValue = (option, value2) => option === value2,
    multiple = false,
    onChange,
    onClose,
    onHighlightChange,
    onInputChange,
    onOpen,
    open: openProp,
    openOnFocus = false,
    options,
    readOnly = false,
    selectOnFocus = !props.freeSolo,
    value: valueProp
  } = props;
  const id = useId(idProp);
  let getOptionLabel = getOptionLabelProp;
  getOptionLabel = (option) => {
    const optionLabel = getOptionLabelProp(option);
    if (typeof optionLabel !== "string") {
      if (true) {
        const erroneousReturn = optionLabel === void 0 ? "undefined" : `${typeof optionLabel} (${optionLabel})`;
        console.error(`MUI: The \`getOptionLabel\` method of ${componentName} returned ${erroneousReturn} instead of a string for ${JSON.stringify(option)}.`);
      }
      return String(optionLabel);
    }
    return optionLabel;
  };
  const ignoreFocus = React.useRef(false);
  const firstFocus = React.useRef(true);
  const inputRef = React.useRef(null);
  const listboxRef = React.useRef(null);
  const [anchorEl, setAnchorEl] = React.useState(null);
  const [focusedTag, setFocusedTag] = React.useState(-1);
  const defaultHighlighted = autoHighlight ? 0 : -1;
  const highlightedIndexRef = React.useRef(defaultHighlighted);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: componentName
  });
  const [inputValue, setInputValueState] = useControlled({
    controlled: inputValueProp,
    default: "",
    name: componentName,
    state: "inputValue"
  });
  const [focused, setFocused] = React.useState(false);
  const resetInputValue = React.useCallback((event, newValue) => {
    const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
    if (!isOptionSelected && !clearOnBlur) {
      return;
    }
    let newInputValue;
    if (multiple) {
      newInputValue = "";
    } else if (newValue == null) {
      newInputValue = "";
    } else {
      const optionLabel = getOptionLabel(newValue);
      newInputValue = typeof optionLabel === "string" ? optionLabel : "";
    }
    if (inputValue === newInputValue) {
      return;
    }
    setInputValueState(newInputValue);
    if (onInputChange) {
      onInputChange(event, newInputValue, "reset");
    }
  }, [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
  const prevValue = React.useRef();
  React.useEffect(() => {
    const valueChange = value !== prevValue.current;
    prevValue.current = value;
    if (focused && !valueChange) {
      return;
    }
    if (freeSolo && !valueChange) {
      return;
    }
    resetInputValue(null, value);
  }, [value, resetInputValue, focused, prevValue, freeSolo]);
  const [open, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: componentName,
    state: "open"
  });
  const [inputPristine, setInputPristine] = React.useState(true);
  const inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
  const popupOpen = open && !readOnly;
  const filteredOptions = popupOpen ? filterOptions(
    options.filter((option) => {
      if (filterSelectedOptions && (multiple ? value : [value]).some((value2) => value2 !== null && isOptionEqualToValue(option, value2))) {
        return false;
      }
      return true;
    }),
    {
      inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue,
      getOptionLabel
    }
  ) : [];
  const listboxAvailable = open && filteredOptions.length > 0 && !readOnly;
  if (true) {
    if (value !== null && !freeSolo && options.length > 0) {
      const missingValue = (multiple ? value : [value]).filter((value2) => !options.some((option) => isOptionEqualToValue(option, value2)));
      if (missingValue.length > 0) {
        console.warn([`MUI: The value provided to ${componentName} is invalid.`, `None of the options match with \`${missingValue.length > 1 ? JSON.stringify(missingValue) : JSON.stringify(missingValue[0])}\`.`, "You can use the `isOptionEqualToValue` prop to customize the equality test."].join("\n"));
      }
    }
  }
  const focusTag = useEventCallback((tagToFocus) => {
    if (tagToFocus === -1) {
      inputRef.current.focus();
    } else {
      anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
    }
  });
  React.useEffect(() => {
    if (multiple && focusedTag > value.length - 1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
  }, [value, multiple, focusedTag, focusTag]);
  function validOptionIndex(index, direction) {
    if (!listboxRef.current || index === -1) {
      return -1;
    }
    let nextFocus = index;
    while (true) {
      if (direction === "next" && nextFocus === filteredOptions.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);
      const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
      if (option && !option.hasAttribute("tabindex") || nextFocusDisabled) {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const setHighlightedIndex = useEventCallback(({
    event,
    index,
    reason = "auto"
  }) => {
    highlightedIndexRef.current = index;
    if (index === -1) {
      inputRef.current.removeAttribute("aria-activedescendant");
    } else {
      inputRef.current.setAttribute("aria-activedescendant", `${id}-option-${index}`);
    }
    if (onHighlightChange) {
      onHighlightChange(event, index === -1 ? null : filteredOptions[index], reason);
    }
    if (!listboxRef.current) {
      return;
    }
    const prev = listboxRef.current.querySelector('[role="option"].Mui-focused');
    if (prev) {
      prev.classList.remove("Mui-focused");
      prev.classList.remove("Mui-focusVisible");
    }
    const listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
    if (!listboxNode) {
      return;
    }
    if (index === -1) {
      listboxNode.scrollTop = 0;
      return;
    }
    const option = listboxRef.current.querySelector(`[data-option-index="${index}"]`);
    if (!option) {
      return;
    }
    option.classList.add("Mui-focused");
    if (reason === "keyboard") {
      option.classList.add("Mui-focusVisible");
    }
    if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse") {
      const element = option;
      const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
      const elementBottom = element.offsetTop + element.offsetHeight;
      if (elementBottom > scrollBottom) {
        listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
      } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
        listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
      }
    }
  });
  const changeHighlightedIndex = useEventCallback(({
    event,
    diff,
    direction = "next",
    reason = "auto"
  }) => {
    if (!popupOpen) {
      return;
    }
    const getNextIndex = () => {
      const maxIndex = filteredOptions.length - 1;
      if (diff === "reset") {
        return defaultHighlighted;
      }
      if (diff === "start") {
        return 0;
      }
      if (diff === "end") {
        return maxIndex;
      }
      const newIndex = highlightedIndexRef.current + diff;
      if (newIndex < 0) {
        if (newIndex === -1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
          return 0;
        }
        return maxIndex;
      }
      if (newIndex > maxIndex) {
        if (newIndex === maxIndex + 1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap || Math.abs(diff) > 1) {
          return maxIndex;
        }
        return 0;
      }
      return newIndex;
    };
    const nextIndex = validOptionIndex(getNextIndex(), direction);
    setHighlightedIndex({
      index: nextIndex,
      reason,
      event
    });
    if (autoComplete && diff !== "reset") {
      if (nextIndex === -1) {
        inputRef.current.value = inputValue;
      } else {
        const option = getOptionLabel(filteredOptions[nextIndex]);
        inputRef.current.value = option;
        const index = option.toLowerCase().indexOf(inputValue.toLowerCase());
        if (index === 0 && inputValue.length > 0) {
          inputRef.current.setSelectionRange(inputValue.length, option.length);
        }
      }
    }
  });
  const syncHighlightedIndex = React.useCallback(() => {
    if (!popupOpen) {
      return;
    }
    const valueItem = multiple ? value[0] : value;
    if (filteredOptions.length === 0 || valueItem == null) {
      changeHighlightedIndex({
        diff: "reset"
      });
      return;
    }
    if (!listboxRef.current) {
      return;
    }
    if (valueItem != null) {
      const currentOption = filteredOptions[highlightedIndexRef.current];
      if (multiple && currentOption && findIndex(value, (val) => isOptionEqualToValue(currentOption, val)) !== -1) {
        return;
      }
      const itemIndex = findIndex(filteredOptions, (optionItem) => isOptionEqualToValue(optionItem, valueItem));
      if (itemIndex === -1) {
        changeHighlightedIndex({
          diff: "reset"
        });
      } else {
        setHighlightedIndex({
          index: itemIndex
        });
      }
      return;
    }
    if (highlightedIndexRef.current >= filteredOptions.length - 1) {
      setHighlightedIndex({
        index: filteredOptions.length - 1
      });
      return;
    }
    setHighlightedIndex({
      index: highlightedIndexRef.current
    });
  }, [
    filteredOptions.length,
    multiple ? false : value,
    filterSelectedOptions,
    changeHighlightedIndex,
    setHighlightedIndex,
    popupOpen,
    inputValue,
    multiple
  ]);
  const handleListboxRef = useEventCallback((node) => {
    setRef(listboxRef, node);
    if (!node) {
      return;
    }
    syncHighlightedIndex();
  });
  if (true) {
    React.useEffect(() => {
      if (!inputRef.current || inputRef.current.nodeName !== "INPUT") {
        if (inputRef.current && inputRef.current.nodeName === "TEXTAREA") {
          console.warn([`A textarea element was provided to ${componentName} where input was expected.`, `This is not a supported scenario but it may work under certain conditions.`, `A textarea keyboard navigation may conflict with Autocomplete controls (e.g. enter and arrow keys).`, `Make sure to test keyboard navigation and add custom event handlers if necessary.`].join("\n"));
        } else {
          console.error([`MUI: Unable to find the input element. It was resolved to ${inputRef.current} while an HTMLInputElement was expected.`, `Instead, ${componentName} expects an input element.`, "", componentName === "useAutocomplete" ? "Make sure you have binded getInputProps correctly and that the normal ref/effect resolutions order is guaranteed." : "Make sure you have customized the input component correctly."].join("\n"));
        }
      }
    }, [componentName]);
  }
  React.useEffect(() => {
    syncHighlightedIndex();
  }, [syncHighlightedIndex]);
  const handleOpen = (event) => {
    if (open) {
      return;
    }
    setOpenState(true);
    setInputPristine(true);
    if (onOpen) {
      onOpen(event);
    }
  };
  const handleClose = (event, reason) => {
    if (!open) {
      return;
    }
    setOpenState(false);
    if (onClose) {
      onClose(event, reason);
    }
  };
  const handleValue = (event, newValue, reason, details) => {
    if (multiple) {
      if (value.length === newValue.length && value.every((val, i) => val === newValue[i])) {
        return;
      }
    } else if (value === newValue) {
      return;
    }
    if (onChange) {
      onChange(event, newValue, reason, details);
    }
    setValueState(newValue);
  };
  const isTouch = React.useRef(false);
  const selectNewValue = (event, option, reasonProp = "selectOption", origin = "options") => {
    let reason = reasonProp;
    let newValue = option;
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      if (true) {
        const matches = newValue.filter((val) => isOptionEqualToValue(option, val));
        if (matches.length > 1) {
          console.error([`MUI: The \`isOptionEqualToValue\` method of ${componentName} do not handle the arguments correctly.`, `The component expects a single value to match a given option but found ${matches.length} matches.`].join("\n"));
        }
      }
      const itemIndex = findIndex(newValue, (valueItem) => isOptionEqualToValue(option, valueItem));
      if (itemIndex === -1) {
        newValue.push(option);
      } else if (origin !== "freeSolo") {
        newValue.splice(itemIndex, 1);
        reason = "removeOption";
      }
    }
    resetInputValue(event, newValue);
    handleValue(event, newValue, reason, {
      option
    });
    if (!disableCloseOnSelect && (!event || !event.ctrlKey && !event.metaKey)) {
      handleClose(event, reason);
    }
    if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
      inputRef.current.blur();
    }
  };
  function validTagIndex(index, direction) {
    if (index === -1) {
      return -1;
    }
    let nextFocus = index;
    while (true) {
      if (direction === "next" && nextFocus === value.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);
      if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const handleFocusTag = (event, direction) => {
    if (!multiple) {
      return;
    }
    if (inputValue === "") {
      handleClose(event, "toggleInput");
    }
    let nextTag = focusedTag;
    if (focusedTag === -1) {
      if (inputValue === "" && direction === "previous") {
        nextTag = value.length - 1;
      }
    } else {
      nextTag += direction === "next" ? 1 : -1;
      if (nextTag < 0) {
        nextTag = 0;
      }
      if (nextTag === value.length) {
        nextTag = -1;
      }
    }
    nextTag = validTagIndex(nextTag, direction);
    setFocusedTag(nextTag);
    focusTag(nextTag);
  };
  const handleClear = (event) => {
    ignoreFocus.current = true;
    setInputValueState("");
    if (onInputChange) {
      onInputChange(event, "", "clear");
    }
    handleValue(event, multiple ? [] : null, "clear");
  };
  const handleKeyDown2 = (other) => (event) => {
    if (other.onKeyDown) {
      other.onKeyDown(event);
    }
    if (event.defaultMuiPrevented) {
      return;
    }
    if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
    if (event.which !== 229) {
      switch (event.key) {
        case "Home":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "start",
              direction: "next",
              reason: "keyboard",
              event
            });
          }
          break;
        case "End":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "end",
              direction: "previous",
              reason: "keyboard",
              event
            });
          }
          break;
        case "PageUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -pageSize,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "PageDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: pageSize,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: 1,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -1,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowLeft":
          handleFocusTag(event, "previous");
          break;
        case "ArrowRight":
          handleFocusTag(event, "next");
          break;
        case "Enter":
          if (highlightedIndexRef.current !== -1 && popupOpen) {
            const option = filteredOptions[highlightedIndexRef.current];
            const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
            event.preventDefault();
            if (disabled) {
              return;
            }
            selectNewValue(event, option, "selectOption");
            if (autoComplete) {
              inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
            }
          } else if (freeSolo && inputValue !== "" && inputValueIsSelectedValue === false) {
            if (multiple) {
              event.preventDefault();
            }
            selectNewValue(event, inputValue, "createOption", "freeSolo");
          }
          break;
        case "Escape":
          if (popupOpen) {
            event.preventDefault();
            event.stopPropagation();
            handleClose(event, "escape");
          } else if (clearOnEscape && (inputValue !== "" || multiple && value.length > 0)) {
            event.preventDefault();
            event.stopPropagation();
            handleClear(event);
          }
          break;
        case "Backspace":
          if (multiple && !readOnly && inputValue === "" && value.length > 0) {
            const index = focusedTag === -1 ? value.length - 1 : focusedTag;
            const newValue = value.slice();
            newValue.splice(index, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index]
            });
          }
          break;
        default:
      }
    }
  };
  const handleFocus = (event) => {
    setFocused(true);
    if (openOnFocus && !ignoreFocus.current) {
      handleOpen(event);
    }
  };
  const handleBlur2 = (event) => {
    if (listboxRef.current !== null && listboxRef.current.parentElement.contains(document.activeElement)) {
      inputRef.current.focus();
      return;
    }
    setFocused(false);
    firstFocus.current = true;
    ignoreFocus.current = false;
    if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
      selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
    } else if (autoSelect && freeSolo && inputValue !== "") {
      selectNewValue(event, inputValue, "blur", "freeSolo");
    } else if (clearOnBlur) {
      resetInputValue(event, value);
    }
    handleClose(event, "blur");
  };
  const handleInputChange = (event) => {
    const newValue = event.target.value;
    if (inputValue !== newValue) {
      setInputValueState(newValue);
      setInputPristine(false);
      if (onInputChange) {
        onInputChange(event, newValue, "input");
      }
    }
    if (newValue === "") {
      if (!disableClearable && !multiple) {
        handleValue(event, null, "clear");
      }
    } else {
      handleOpen(event);
    }
  };
  const handleOptionMouseOver = (event) => {
    setHighlightedIndex({
      event,
      index: Number(event.currentTarget.getAttribute("data-option-index")),
      reason: "mouse"
    });
  };
  const handleOptionTouchStart = () => {
    isTouch.current = true;
  };
  const handleOptionClick = (event) => {
    const index = Number(event.currentTarget.getAttribute("data-option-index"));
    selectNewValue(event, filteredOptions[index], "selectOption");
    isTouch.current = false;
  };
  const handleTagDelete = (index) => (event) => {
    const newValue = value.slice();
    newValue.splice(index, 1);
    handleValue(event, newValue, "removeOption", {
      option: value[index]
    });
  };
  const handlePopupIndicator = (event) => {
    if (open) {
      handleClose(event, "toggleInput");
    } else {
      handleOpen(event);
    }
  };
  const handleMouseDown = (event) => {
    if (event.target.getAttribute("id") !== id) {
      event.preventDefault();
    }
  };
  const handleClick = () => {
    inputRef.current.focus();
    if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
      inputRef.current.select();
    }
    firstFocus.current = false;
  };
  const handleInputMouseDown = (event) => {
    if (inputValue === "" || !open) {
      handlePopupIndicator(event);
    }
  };
  let dirty = freeSolo && inputValue.length > 0;
  dirty = dirty || (multiple ? value.length > 0 : value !== null);
  let groupedOptions = filteredOptions;
  if (groupBy) {
    const indexBy = /* @__PURE__ */ new Map();
    let warn = false;
    groupedOptions = filteredOptions.reduce((acc, option, index) => {
      const group = groupBy(option);
      if (acc.length > 0 && acc[acc.length - 1].group === group) {
        acc[acc.length - 1].options.push(option);
      } else {
        if (true) {
          if (indexBy.get(group) && !warn) {
            console.warn(`MUI: The options provided combined with the \`groupBy\` method of ${componentName} returns duplicated headers.`, "You can solve the issue by sorting the options with the output of `groupBy`.");
            warn = true;
          }
          indexBy.set(group, true);
        }
        acc.push({
          key: index,
          index,
          group,
          options: [option]
        });
      }
      return acc;
    }, []);
  }
  if (disabledProp && focused) {
    handleBlur2();
  }
  return {
    getRootProps: (other = {}) => _extends({
      "aria-owns": listboxAvailable ? `${id}-listbox` : null
    }, other, {
      onKeyDown: handleKeyDown2(other),
      onMouseDown: handleMouseDown,
      onClick: handleClick
    }),
    getInputLabelProps: () => ({
      id: `${id}-label`,
      htmlFor: id
    }),
    getInputProps: () => ({
      id,
      value: inputValue,
      onBlur: handleBlur2,
      onFocus: handleFocus,
      onChange: handleInputChange,
      onMouseDown: handleInputMouseDown,
      "aria-activedescendant": popupOpen ? "" : null,
      "aria-autocomplete": autoComplete ? "both" : "list",
      "aria-controls": listboxAvailable ? `${id}-listbox` : void 0,
      "aria-expanded": listboxAvailable,
      autoComplete: "off",
      ref: inputRef,
      autoCapitalize: "none",
      spellCheck: "false",
      role: "combobox"
    }),
    getClearProps: () => ({
      tabIndex: -1,
      onClick: handleClear
    }),
    getPopupIndicatorProps: () => ({
      tabIndex: -1,
      onClick: handlePopupIndicator
    }),
    getTagProps: ({
      index
    }) => _extends({
      key: index,
      "data-tag-index": index,
      tabIndex: -1
    }, !readOnly && {
      onDelete: handleTagDelete(index)
    }),
    getListboxProps: () => ({
      role: "listbox",
      id: `${id}-listbox`,
      "aria-labelledby": `${id}-label`,
      ref: handleListboxRef,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }),
    getOptionProps: ({
      index,
      option
    }) => {
      const selected = (multiple ? value : [value]).some((value2) => value2 != null && isOptionEqualToValue(option, value2));
      const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
      return {
        key: getOptionLabel(option),
        tabIndex: -1,
        role: "option",
        id: `${id}-option-${index}`,
        onMouseOver: handleOptionMouseOver,
        onClick: handleOptionClick,
        onTouchStart: handleOptionTouchStart,
        "data-option-index": index,
        "aria-disabled": disabled,
        "aria-selected": selected
      };
    },
    id,
    inputValue,
    value,
    dirty,
    popupOpen,
    focused: focused || focusedTag !== -1,
    anchorEl,
    setAnchorEl,
    focusedTag,
    groupedOptions
  };
}
var React, defaultFilterOptions, pageSize;
var init_useAutocomplete = __esm({
  "node_modules/@mui/base/AutocompleteUnstyled/useAutocomplete.js"() {
    init_extends();
    React = __toESM(require_react());
    init_esm();
    defaultFilterOptions = createFilterOptions();
    pageSize = 5;
  }
});

// node_modules/@mui/base/AutocompleteUnstyled/index.js
var init_AutocompleteUnstyled = __esm({
  "node_modules/@mui/base/AutocompleteUnstyled/index.js"() {
    init_useAutocomplete();
  }
});

// node_modules/@mui/base/composeClasses/index.js
var init_composeClasses = __esm({
  "node_modules/@mui/base/composeClasses/index.js"() {
    init_esm();
  }
});

// node_modules/@mui/base/generateUtilityClasses/index.js
var init_generateUtilityClasses = __esm({
  "node_modules/@mui/base/generateUtilityClasses/index.js"() {
    init_esm();
  }
});

// node_modules/@mui/base/generateUtilityClass/index.js
var init_generateUtilityClass = __esm({
  "node_modules/@mui/base/generateUtilityClass/index.js"() {
    init_esm();
  }
});

// node_modules/@mui/base/ClickAwayListener/ClickAwayListener.js
function mapEventPropToEvent(eventProp) {
  return eventProp.substring(2).toLowerCase();
}
function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
function ClickAwayListener(props) {
  const {
    children,
    disableReactTree = false,
    mouseEvent = "onClick",
    onClickAway,
    touchEvent = "onTouchEnd"
  } = props;
  const movedRef = React2.useRef(false);
  const nodeRef = React2.useRef(null);
  const activatedRef = React2.useRef(false);
  const syntheticEventRef = React2.useRef(false);
  React2.useEffect(() => {
    setTimeout(() => {
      activatedRef.current = true;
    }, 0);
    return () => {
      activatedRef.current = false;
    };
  }, []);
  const handleRef = useForkRef(
    children.ref,
    nodeRef
  );
  const handleClickAway = useEventCallback((event) => {
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);
    if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar(event, doc)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
    } else {
      insideDOM = !doc.documentElement.contains(
        event.target
      ) || nodeRef.current.contains(
        event.target
      );
    }
    if (!insideDOM && (disableReactTree || !insideReactTree)) {
      onClickAway(event);
    }
  });
  const createHandleSynthetic = (handlerName) => (event) => {
    syntheticEventRef.current = true;
    const childrenPropsHandler = children.props[handlerName];
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const childrenProps = {
    ref: handleRef
  };
  if (touchEvent !== false) {
    childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
  }
  React2.useEffect(() => {
    if (touchEvent !== false) {
      const mappedTouchEvent = mapEventPropToEvent(touchEvent);
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc.addEventListener(mappedTouchEvent, handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc.removeEventListener(mappedTouchEvent, handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [handleClickAway, touchEvent]);
  if (mouseEvent !== false) {
    childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
  }
  React2.useEffect(() => {
    if (mouseEvent !== false) {
      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener(mappedMouseEvent, handleClickAway);
      return () => {
        doc.removeEventListener(mappedMouseEvent, handleClickAway);
      };
    }
    return void 0;
  }, [handleClickAway, mouseEvent]);
  return (0, import_jsx_runtime.jsx)(React2.Fragment, {
    children: React2.cloneElement(children, childrenProps)
  });
}
var React2, import_prop_types, import_jsx_runtime, ClickAwayListener_default;
var init_ClickAwayListener = __esm({
  "node_modules/@mui/base/ClickAwayListener/ClickAwayListener.js"() {
    React2 = __toESM(require_react());
    import_prop_types = __toESM(require_prop_types());
    init_esm();
    import_jsx_runtime = __toESM(require_jsx_runtime());
    true ? ClickAwayListener.propTypes = {
      children: elementAcceptingRef_default.isRequired,
      disableReactTree: import_prop_types.default.bool,
      mouseEvent: import_prop_types.default.oneOf(["onClick", "onMouseDown", "onMouseUp", "onPointerDown", "onPointerUp", false]),
      onClickAway: import_prop_types.default.func.isRequired,
      touchEvent: import_prop_types.default.oneOf(["onTouchEnd", "onTouchStart", false])
    } : void 0;
    if (true) {
      ClickAwayListener["propTypes"] = exactProp(ClickAwayListener.propTypes);
    }
    ClickAwayListener_default = ClickAwayListener;
  }
});

// node_modules/@mui/base/ClickAwayListener/index.js
var init_ClickAwayListener2 = __esm({
  "node_modules/@mui/base/ClickAwayListener/index.js"() {
    init_ClickAwayListener();
    init_ClickAwayListener();
  }
});

// node_modules/@mui/base/Portal/Portal.js
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
var React3, ReactDOM, import_prop_types2, import_jsx_runtime2, Portal, Portal_default;
var init_Portal = __esm({
  "node_modules/@mui/base/Portal/Portal.js"() {
    React3 = __toESM(require_react());
    ReactDOM = __toESM(require_react_dom());
    import_prop_types2 = __toESM(require_prop_types());
    init_esm();
    import_jsx_runtime2 = __toESM(require_jsx_runtime());
    Portal = React3.forwardRef(function Portal2(props, ref) {
      const {
        children,
        container,
        disablePortal = false
      } = props;
      const [mountNode, setMountNode] = React3.useState(null);
      const handleRef = useForkRef(React3.isValidElement(children) ? children.ref : null, ref);
      useEnhancedEffect_default(() => {
        if (!disablePortal) {
          setMountNode(getContainer(container) || document.body);
        }
      }, [container, disablePortal]);
      useEnhancedEffect_default(() => {
        if (mountNode && !disablePortal) {
          setRef(ref, mountNode);
          return () => {
            setRef(ref, null);
          };
        }
        return void 0;
      }, [ref, mountNode, disablePortal]);
      if (disablePortal) {
        if (React3.isValidElement(children)) {
          return React3.cloneElement(children, {
            ref: handleRef
          });
        }
        return children;
      }
      return (0, import_jsx_runtime2.jsx)(React3.Fragment, {
        children: mountNode ? ReactDOM.createPortal(children, mountNode) : mountNode
      });
    });
    true ? Portal.propTypes = {
      children: import_prop_types2.default.node,
      container: import_prop_types2.default.oneOfType([HTMLElementType, import_prop_types2.default.func]),
      disablePortal: import_prop_types2.default.bool
    } : void 0;
    if (true) {
      Portal["propTypes"] = exactProp(Portal.propTypes);
    }
    Portal_default = Portal;
  }
});

// node_modules/@mui/base/Portal/index.js
var init_Portal2 = __esm({
  "node_modules/@mui/base/Portal/index.js"() {
    init_Portal();
  }
});

// node_modules/@mui/base/ModalUnstyled/ModalManager.js
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, show) {
  if (show) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude = [], show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = blacklist.indexOf(element) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, show);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index) => {
    if (callback(item)) {
      idx = index;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el,
      property
    }) => {
      if (value) {
        el.style.setProperty(property, value);
      } else {
        el.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
var ModalManager;
var init_ModalManager = __esm({
  "node_modules/@mui/base/ModalUnstyled/ModalManager.js"() {
    init_esm();
    ModalManager = class {
      constructor() {
        this.containers = void 0;
        this.modals = void 0;
        this.modals = [];
        this.containers = [];
      }
      add(modal, container) {
        let modalIndex = this.modals.indexOf(modal);
        if (modalIndex !== -1) {
          return modalIndex;
        }
        modalIndex = this.modals.length;
        this.modals.push(modal);
        if (modal.modalRef) {
          ariaHidden(modal.modalRef, false);
        }
        const hiddenSiblings = getHiddenSiblings(container);
        ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
        const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
        if (containerIndex !== -1) {
          this.containers[containerIndex].modals.push(modal);
          return modalIndex;
        }
        this.containers.push({
          modals: [modal],
          container,
          restore: null,
          hiddenSiblings
        });
        return modalIndex;
      }
      mount(modal, props) {
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        if (!containerInfo.restore) {
          containerInfo.restore = handleContainer(containerInfo, props);
        }
      }
      remove(modal, ariaHiddenState = true) {
        const modalIndex = this.modals.indexOf(modal);
        if (modalIndex === -1) {
          return modalIndex;
        }
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
        this.modals.splice(modalIndex, 1);
        if (containerInfo.modals.length === 0) {
          if (containerInfo.restore) {
            containerInfo.restore();
          }
          if (modal.modalRef) {
            ariaHidden(modal.modalRef, ariaHiddenState);
          }
          ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
          this.containers.splice(containerIndex, 1);
        } else {
          const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
          if (nextTop.modalRef) {
            ariaHidden(nextTop.modalRef, false);
          }
        }
        return modalIndex;
      }
      isTopModal(modal) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
      }
    };
  }
});

// node_modules/@mui/base/ModalUnstyled/modalUnstyledClasses.js
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
var modalUnstyledClasses, modalUnstyledClasses_default;
var init_modalUnstyledClasses = __esm({
  "node_modules/@mui/base/ModalUnstyled/modalUnstyledClasses.js"() {
    init_generateUtilityClasses();
    init_generateUtilityClass();
    modalUnstyledClasses = generateUtilityClasses("MuiModal", ["root", "hidden"]);
    modalUnstyledClasses_default = modalUnstyledClasses;
  }
});

// node_modules/@mui/base/TrapFocus/TrapFocus.js
function getTabIndex(node) {
  const tabindexAttr = parseInt(node.getAttribute("tabindex"), 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node.contentEditable === "true" || (node.nodeName === "AUDIO" || node.nodeName === "VIDEO" || node.nodeName === "DETAILS") && node.getAttribute("tabindex") === null) {
    return 0;
  }
  return node.tabIndex;
}
function isNonTabbableRadio(node) {
  if (node.tagName !== "INPUT" || node.type !== "radio") {
    return false;
  }
  if (!node.name) {
    return false;
  }
  const getRadio = (selector) => node.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node.name}"]`);
  }
  return roving !== node;
}
function isNodeMatchingSelectorFocusable(node) {
  if (node.disabled || node.tagName === "INPUT" && node.type === "hidden" || isNonTabbableRadio(node)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i) => {
    const nodeTabIndex = getTabIndex(node);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node
      });
    }
  });
  return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map((a) => a.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function TrapFocus(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = React4.useRef();
  const sentinelStart = React4.useRef(null);
  const sentinelEnd = React4.useRef(null);
  const nodeToRestore = React4.useRef(null);
  const reactFocusEventTarget = React4.useRef(null);
  const activated = React4.useRef(false);
  const rootRef = React4.useRef(null);
  const handleRef = useForkRef(children.ref, rootRef);
  const lastKeydown = React4.useRef(null);
  React4.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  React4.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        if (true) {
          console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join("\n"));
        }
        rootRef.current.setAttribute("tabIndex", -1);
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  React4.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const contain = (nativeEvent) => {
      const {
        current: rootElement
      } = rootRef;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (!rootElement.contains(doc.activeElement)) {
        if (nativeEvent && reactFocusEventTarget.current !== nativeEvent.target || doc.activeElement !== reactFocusEventTarget.current) {
          reactFocusEventTarget.current = null;
        } else if (reactFocusEventTarget.current !== null) {
          return;
        }
        if (!activated.current) {
          return;
        }
        let tabbable = [];
        if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
          tabbable = getTabbable(rootRef.current);
        }
        if (tabbable.length > 0) {
          var _lastKeydown$current, _lastKeydown$current2;
          const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
          const focusNext = tabbable[0];
          const focusPrevious = tabbable[tabbable.length - 1];
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        } else {
          rootElement.focus();
        }
      }
    };
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        sentinelEnd.current.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return (0, import_jsx_runtime4.jsxs)(React4.Fragment, {
    children: [(0, import_jsx_runtime3.jsx)("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), React4.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), (0, import_jsx_runtime3.jsx)("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
var React4, import_prop_types3, import_jsx_runtime3, import_jsx_runtime4, candidatesSelector, TrapFocus_default;
var init_TrapFocus = __esm({
  "node_modules/@mui/base/TrapFocus/TrapFocus.js"() {
    React4 = __toESM(require_react());
    import_prop_types3 = __toESM(require_prop_types());
    init_esm();
    import_jsx_runtime3 = __toESM(require_jsx_runtime());
    import_jsx_runtime4 = __toESM(require_jsx_runtime());
    candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
    true ? TrapFocus.propTypes = {
      children: elementAcceptingRef_default,
      disableAutoFocus: import_prop_types3.default.bool,
      disableEnforceFocus: import_prop_types3.default.bool,
      disableRestoreFocus: import_prop_types3.default.bool,
      getTabbable: import_prop_types3.default.func,
      isEnabled: import_prop_types3.default.func,
      open: import_prop_types3.default.bool.isRequired
    } : void 0;
    if (true) {
      TrapFocus["propTypes"] = exactProp(TrapFocus.propTypes);
    }
    TrapFocus_default = TrapFocus;
  }
});

// node_modules/@mui/base/TrapFocus/index.js
var init_TrapFocus2 = __esm({
  "node_modules/@mui/base/TrapFocus/index.js"() {
    init_TrapFocus();
  }
});

// node_modules/@mui/base/utils/isHostComponent.js
function isHostComponent(element) {
  return typeof element === "string";
}
var isHostComponent_default;
var init_isHostComponent = __esm({
  "node_modules/@mui/base/utils/isHostComponent.js"() {
    isHostComponent_default = isHostComponent;
  }
});

// node_modules/@mui/base/utils/appendOwnerState.js
function appendOwnerState(elementType, otherProps = {}, ownerState) {
  if (isHostComponent_default(elementType)) {
    return otherProps;
  }
  return _extends({}, otherProps, {
    ownerState: _extends({}, otherProps.ownerState, ownerState)
  });
}
var init_appendOwnerState = __esm({
  "node_modules/@mui/base/utils/appendOwnerState.js"() {
    init_extends();
    init_isHostComponent();
  }
});

// node_modules/@mui/base/utils/areArraysEqual.js
function areArraysEqual(array1, array2, itemComparer = (a, b) => a === b) {
  return array1.length === array2.length && array1.every((value, index) => itemComparer(value, array2[index]));
}
var init_areArraysEqual = __esm({
  "node_modules/@mui/base/utils/areArraysEqual.js"() {
  }
});

// node_modules/@mui/base/utils/extractEventHandlers.js
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
var init_extractEventHandlers = __esm({
  "node_modules/@mui/base/utils/extractEventHandlers.js"() {
  }
});

// node_modules/@mui/base/utils/resolveComponentProps.js
function resolveComponentProps(componentProps, ownerState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState);
  }
  return componentProps;
}
var init_resolveComponentProps = __esm({
  "node_modules/@mui/base/utils/resolveComponentProps.js"() {
  }
});

// node_modules/@mui/base/utils/omitEventHandlers.js
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
var init_omitEventHandlers = __esm({
  "node_modules/@mui/base/utils/omitEventHandlers.js"() {
  }
});

// node_modules/@mui/base/utils/mergeSlotProps.js
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx_m_default(externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className, className, additionalProps == null ? void 0 : additionalProps.className);
    const mergedStyle2 = _extends({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = _extends({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(_extends({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx_m_default(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
var init_mergeSlotProps = __esm({
  "node_modules/@mui/base/utils/mergeSlotProps.js"() {
    init_extends();
    init_clsx_m();
    init_extractEventHandlers();
    init_omitEventHandlers();
  }
});

// node_modules/@mui/base/utils/useSlotProps.js
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
    elementType,
    externalSlotProps,
    ownerState
  } = parameters, rest = _objectWithoutPropertiesLoose(parameters, _excluded);
  const resolvedComponentsProps = resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef(internalRef, useForkRef(resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref));
  const props = appendOwnerState(elementType, _extends({}, mergedProps, {
    ref
  }), ownerState);
  return props;
}
var _excluded;
var init_useSlotProps = __esm({
  "node_modules/@mui/base/utils/useSlotProps.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm();
    init_appendOwnerState();
    init_mergeSlotProps();
    init_resolveComponentProps();
    _excluded = ["elementType", "externalSlotProps", "ownerState"];
  }
});

// node_modules/@mui/base/utils/types.js
var init_types = __esm({
  "node_modules/@mui/base/utils/types.js"() {
  }
});

// node_modules/@mui/base/utils/index.js
var init_utils = __esm({
  "node_modules/@mui/base/utils/index.js"() {
    init_appendOwnerState();
    init_areArraysEqual();
    init_extractEventHandlers();
    init_isHostComponent();
    init_resolveComponentProps();
    init_useSlotProps();
    init_types();
  }
});

// node_modules/@mui/base/ModalUnstyled/ModalUnstyled.js
function getContainer2(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(props) {
  return props.children ? props.children.props.hasOwnProperty("in") : false;
}
var React5, import_prop_types4, import_jsx_runtime5, import_jsx_runtime6, _excluded2, useUtilityClasses, defaultManager, ModalUnstyled, ModalUnstyled_default;
var init_ModalUnstyled = __esm({
  "node_modules/@mui/base/ModalUnstyled/ModalUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React5 = __toESM(require_react());
    import_prop_types4 = __toESM(require_prop_types());
    init_esm();
    init_composeClasses();
    init_Portal2();
    init_ModalManager();
    init_TrapFocus2();
    init_modalUnstyledClasses();
    init_utils();
    import_jsx_runtime5 = __toESM(require_jsx_runtime());
    import_jsx_runtime6 = __toESM(require_jsx_runtime());
    _excluded2 = ["children", "classes", "closeAfterTransition", "component", "components", "componentsProps", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited"];
    useUtilityClasses = (ownerState) => {
      const {
        open,
        exited,
        classes
      } = ownerState;
      const slots = {
        root: ["root", !open && exited && "hidden"]
      };
      return composeClasses(slots, getModalUtilityClass, classes);
    };
    defaultManager = new ModalManager();
    ModalUnstyled = React5.forwardRef(function ModalUnstyled2(props, ref) {
      var _props$ariaHidden;
      const {
        children,
        classes: classesProp,
        closeAfterTransition = false,
        component = "div",
        components = {},
        componentsProps = {},
        container,
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableEscapeKeyDown = false,
        disablePortal = false,
        disableRestoreFocus = false,
        disableScrollLock = false,
        hideBackdrop = false,
        keepMounted = false,
        manager = defaultManager,
        onBackdropClick,
        onClose,
        onKeyDown,
        open,
        onTransitionEnter,
        onTransitionExited
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
      const [exited, setExited] = React5.useState(true);
      const modal = React5.useRef({});
      const mountNodeRef = React5.useRef(null);
      const modalRef = React5.useRef(null);
      const handleRef = useForkRef(modalRef, ref);
      const hasTransition = getHasTransition(props);
      const ariaHiddenProp = (_props$ariaHidden = props["aria-hidden"]) != null ? _props$ariaHidden : true;
      const getDoc = () => ownerDocument(mountNodeRef.current);
      const getModal = () => {
        modal.current.modalRef = modalRef.current;
        modal.current.mountNode = mountNodeRef.current;
        return modal.current;
      };
      const handleMounted = () => {
        manager.mount(getModal(), {
          disableScrollLock
        });
        modalRef.current.scrollTop = 0;
      };
      const handleOpen = useEventCallback(() => {
        const resolvedContainer = getContainer2(container) || getDoc().body;
        manager.add(getModal(), resolvedContainer);
        if (modalRef.current) {
          handleMounted();
        }
      });
      const isTopModal = React5.useCallback(() => manager.isTopModal(getModal()), [manager]);
      const handlePortalRef = useEventCallback((node) => {
        mountNodeRef.current = node;
        if (!node) {
          return;
        }
        if (open && isTopModal()) {
          handleMounted();
        } else {
          ariaHidden(modalRef.current, ariaHiddenProp);
        }
      });
      const handleClose = React5.useCallback(() => {
        manager.remove(getModal(), ariaHiddenProp);
      }, [manager, ariaHiddenProp]);
      React5.useEffect(() => {
        return () => {
          handleClose();
        };
      }, [handleClose]);
      React5.useEffect(() => {
        if (open) {
          handleOpen();
        } else if (!hasTransition || !closeAfterTransition) {
          handleClose();
        }
      }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
      const ownerState = _extends({}, props, {
        classes: classesProp,
        closeAfterTransition,
        disableAutoFocus,
        disableEnforceFocus,
        disableEscapeKeyDown,
        disablePortal,
        disableRestoreFocus,
        disableScrollLock,
        exited,
        hideBackdrop,
        keepMounted
      });
      const classes = useUtilityClasses(ownerState);
      const handleEnter = () => {
        setExited(false);
        if (onTransitionEnter) {
          onTransitionEnter();
        }
      };
      const handleExited = () => {
        setExited(true);
        if (onTransitionExited) {
          onTransitionExited();
        }
        if (closeAfterTransition) {
          handleClose();
        }
      };
      const handleBackdropClick = (event) => {
        if (event.target !== event.currentTarget) {
          return;
        }
        if (onBackdropClick) {
          onBackdropClick(event);
        }
        if (onClose) {
          onClose(event, "backdropClick");
        }
      };
      const handleKeyDown2 = (event) => {
        if (onKeyDown) {
          onKeyDown(event);
        }
        if (event.key !== "Escape" || !isTopModal()) {
          return;
        }
        if (!disableEscapeKeyDown) {
          event.stopPropagation();
          if (onClose) {
            onClose(event, "escapeKeyDown");
          }
        }
      };
      const childProps = {};
      if (children.props.tabIndex === void 0) {
        childProps.tabIndex = "-1";
      }
      if (hasTransition) {
        childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
        childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
      }
      const Root = components.Root || component;
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref: handleRef,
          role: "presentation",
          onKeyDown: handleKeyDown2
        },
        className: classes.root,
        ownerState
      });
      const BackdropComponent = components.Backdrop;
      const backdropProps = useSlotProps({
        elementType: BackdropComponent,
        externalSlotProps: componentsProps.backdrop,
        additionalProps: {
          "aria-hidden": true,
          onClick: handleBackdropClick,
          open
        },
        ownerState
      });
      if (!keepMounted && !open && (!hasTransition || exited)) {
        return null;
      }
      return (0, import_jsx_runtime5.jsx)(Portal_default, {
        ref: handlePortalRef,
        container,
        disablePortal,
        children: (0, import_jsx_runtime6.jsxs)(Root, _extends({}, rootProps, {
          children: [!hideBackdrop && BackdropComponent ? (0, import_jsx_runtime5.jsx)(BackdropComponent, _extends({}, backdropProps)) : null, (0, import_jsx_runtime5.jsx)(TrapFocus_default, {
            disableEnforceFocus,
            disableAutoFocus,
            disableRestoreFocus,
            isEnabled: isTopModal,
            open,
            children: React5.cloneElement(children, childProps)
          })]
        }))
      });
    });
    true ? ModalUnstyled.propTypes = {
      children: elementAcceptingRef_default.isRequired,
      classes: import_prop_types4.default.object,
      closeAfterTransition: import_prop_types4.default.bool,
      component: import_prop_types4.default.elementType,
      components: import_prop_types4.default.shape({
        Backdrop: import_prop_types4.default.elementType,
        Root: import_prop_types4.default.elementType
      }),
      componentsProps: import_prop_types4.default.shape({
        backdrop: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object]),
        root: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object])
      }),
      container: import_prop_types4.default.oneOfType([HTMLElementType, import_prop_types4.default.func]),
      disableAutoFocus: import_prop_types4.default.bool,
      disableEnforceFocus: import_prop_types4.default.bool,
      disableEscapeKeyDown: import_prop_types4.default.bool,
      disablePortal: import_prop_types4.default.bool,
      disableRestoreFocus: import_prop_types4.default.bool,
      disableScrollLock: import_prop_types4.default.bool,
      hideBackdrop: import_prop_types4.default.bool,
      keepMounted: import_prop_types4.default.bool,
      onBackdropClick: import_prop_types4.default.func,
      onClose: import_prop_types4.default.func,
      onKeyDown: import_prop_types4.default.func,
      open: import_prop_types4.default.bool.isRequired
    } : void 0;
    ModalUnstyled_default = ModalUnstyled;
  }
});

// node_modules/@mui/base/ModalUnstyled/index.js
var init_ModalUnstyled2 = __esm({
  "node_modules/@mui/base/ModalUnstyled/index.js"() {
    init_ModalUnstyled();
    init_ModalManager();
    init_modalUnstyledClasses();
  }
});

// node_modules/@mui/base/NoSsr/NoSsr.js
function NoSsr(props) {
  const {
    children,
    defer = false,
    fallback = null
  } = props;
  const [mountedState, setMountedState] = React6.useState(false);
  useEnhancedEffect_default(() => {
    if (!defer) {
      setMountedState(true);
    }
  }, [defer]);
  React6.useEffect(() => {
    if (defer) {
      setMountedState(true);
    }
  }, [defer]);
  return (0, import_jsx_runtime7.jsx)(React6.Fragment, {
    children: mountedState ? children : fallback
  });
}
var React6, import_prop_types5, import_jsx_runtime7, NoSsr_default;
var init_NoSsr = __esm({
  "node_modules/@mui/base/NoSsr/NoSsr.js"() {
    React6 = __toESM(require_react());
    import_prop_types5 = __toESM(require_prop_types());
    init_esm();
    import_jsx_runtime7 = __toESM(require_jsx_runtime());
    true ? NoSsr.propTypes = {
      children: import_prop_types5.default.node,
      defer: import_prop_types5.default.bool,
      fallback: import_prop_types5.default.node
    } : void 0;
    if (true) {
      NoSsr["propTypes"] = exactProp(NoSsr.propTypes);
    }
    NoSsr_default = NoSsr;
  }
});

// node_modules/@mui/base/NoSsr/index.js
var init_NoSsr2 = __esm({
  "node_modules/@mui/base/NoSsr/index.js"() {
    init_NoSsr();
  }
});

// node_modules/@mui/base/TextareaAutosize/TextareaAutosize.js
function getStyleValue(computedStyle, property) {
  return parseInt(computedStyle[property], 10) || 0;
}
function isEmpty(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
var React7, import_prop_types6, import_react_dom, import_jsx_runtime8, import_jsx_runtime9, _excluded3, styles, TextareaAutosize, TextareaAutosize_default;
var init_TextareaAutosize = __esm({
  "node_modules/@mui/base/TextareaAutosize/TextareaAutosize.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React7 = __toESM(require_react());
    import_prop_types6 = __toESM(require_prop_types());
    import_react_dom = __toESM(require_react_dom());
    init_esm();
    import_jsx_runtime8 = __toESM(require_jsx_runtime());
    import_jsx_runtime9 = __toESM(require_jsx_runtime());
    _excluded3 = ["onChange", "maxRows", "minRows", "style", "value"];
    styles = {
      shadow: {
        visibility: "hidden",
        position: "absolute",
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        transform: "translateZ(0)"
      }
    };
    TextareaAutosize = React7.forwardRef(function TextareaAutosize2(props, ref) {
      const {
        onChange,
        maxRows,
        minRows = 1,
        style,
        value
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded3);
      const {
        current: isControlled
      } = React7.useRef(value != null);
      const inputRef = React7.useRef(null);
      const handleRef = useForkRef(ref, inputRef);
      const shadowRef = React7.useRef(null);
      const renders = React7.useRef(0);
      const [state, setState] = React7.useState({});
      const getUpdatedState = React7.useCallback(() => {
        const input = inputRef.current;
        const containerWindow = ownerWindow(input);
        const computedStyle = containerWindow.getComputedStyle(input);
        if (computedStyle.width === "0px") {
          return {};
        }
        const inputShallow = shadowRef.current;
        inputShallow.style.width = computedStyle.width;
        inputShallow.value = input.value || props.placeholder || "x";
        if (inputShallow.value.slice(-1) === "\n") {
          inputShallow.value += " ";
        }
        const boxSizing = computedStyle["box-sizing"];
        const padding = getStyleValue(computedStyle, "padding-bottom") + getStyleValue(computedStyle, "padding-top");
        const border = getStyleValue(computedStyle, "border-bottom-width") + getStyleValue(computedStyle, "border-top-width");
        const innerHeight = inputShallow.scrollHeight;
        inputShallow.value = "x";
        const singleRowHeight = inputShallow.scrollHeight;
        let outerHeight = innerHeight;
        if (minRows) {
          outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
        }
        if (maxRows) {
          outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
        }
        outerHeight = Math.max(outerHeight, singleRowHeight);
        const outerHeightStyle = outerHeight + (boxSizing === "border-box" ? padding + border : 0);
        const overflow = Math.abs(outerHeight - innerHeight) <= 1;
        return {
          outerHeightStyle,
          overflow
        };
      }, [maxRows, minRows, props.placeholder]);
      const updateState = (prevState, newState) => {
        const {
          outerHeightStyle,
          overflow
        } = newState;
        if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
          renders.current += 1;
          return {
            overflow,
            outerHeightStyle
          };
        }
        if (true) {
          if (renders.current === 20) {
            console.error(["MUI: Too many re-renders. The layout is unstable.", "TextareaAutosize limits the number of renders to prevent an infinite loop."].join("\n"));
          }
        }
        return prevState;
      };
      const syncHeight = React7.useCallback(() => {
        const newState = getUpdatedState();
        if (isEmpty(newState)) {
          return;
        }
        setState((prevState) => {
          return updateState(prevState, newState);
        });
      }, [getUpdatedState]);
      const syncHeightWithFlushSycn = () => {
        const newState = getUpdatedState();
        if (isEmpty(newState)) {
          return;
        }
        (0, import_react_dom.flushSync)(() => {
          setState((prevState) => {
            return updateState(prevState, newState);
          });
        });
      };
      React7.useEffect(() => {
        const handleResize = debounce(() => {
          renders.current = 0;
          if (inputRef.current) {
            syncHeightWithFlushSycn();
          }
        });
        const containerWindow = ownerWindow(inputRef.current);
        containerWindow.addEventListener("resize", handleResize);
        let resizeObserver;
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver = new ResizeObserver(handleResize);
          resizeObserver.observe(inputRef.current);
        }
        return () => {
          handleResize.clear();
          containerWindow.removeEventListener("resize", handleResize);
          if (resizeObserver) {
            resizeObserver.disconnect();
          }
        };
      });
      useEnhancedEffect_default(() => {
        syncHeight();
      });
      React7.useEffect(() => {
        renders.current = 0;
      }, [value]);
      const handleChange = (event) => {
        renders.current = 0;
        if (!isControlled) {
          syncHeight();
        }
        if (onChange) {
          onChange(event);
        }
      };
      return (0, import_jsx_runtime9.jsxs)(React7.Fragment, {
        children: [(0, import_jsx_runtime8.jsx)("textarea", _extends({
          value,
          onChange: handleChange,
          ref: handleRef,
          rows: minRows,
          style: _extends({
            height: state.outerHeightStyle,
            overflow: state.overflow ? "hidden" : null
          }, style)
        }, other)), (0, import_jsx_runtime8.jsx)("textarea", {
          "aria-hidden": true,
          className: props.className,
          readOnly: true,
          ref: shadowRef,
          tabIndex: -1,
          style: _extends({}, styles.shadow, style, {
            padding: 0
          })
        })]
      });
    });
    true ? TextareaAutosize.propTypes = {
      className: import_prop_types6.default.string,
      maxRows: import_prop_types6.default.oneOfType([import_prop_types6.default.number, import_prop_types6.default.string]),
      minRows: import_prop_types6.default.oneOfType([import_prop_types6.default.number, import_prop_types6.default.string]),
      onChange: import_prop_types6.default.func,
      placeholder: import_prop_types6.default.string,
      style: import_prop_types6.default.object,
      value: import_prop_types6.default.oneOfType([import_prop_types6.default.arrayOf(import_prop_types6.default.string), import_prop_types6.default.number, import_prop_types6.default.string])
    } : void 0;
    TextareaAutosize_default = TextareaAutosize;
  }
});

// node_modules/@mui/base/TextareaAutosize/index.js
var init_TextareaAutosize2 = __esm({
  "node_modules/@mui/base/TextareaAutosize/index.js"() {
    init_TextareaAutosize();
  }
});

// node_modules/@mui/material/esm/styles/createTransitions.js
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height) {
  if (!height) {
    return 0;
  }
  const constant = height / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = _extends({}, easing, inputTransitions.easing);
  const mergedDuration = _extends({}, duration, inputTransitions.duration);
  const create = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = options, other = _objectWithoutPropertiesLoose(options, _excluded4);
    if (true) {
      const isString = (value) => typeof value === "string";
      const isNumber = (value) => !isNaN(parseFloat(value));
      if (!isString(props) && !Array.isArray(props)) {
        console.error('MUI: Argument "props" must be a string or Array.');
      }
      if (!isNumber(durationOption) && !isString(durationOption)) {
        console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
      }
      if (!isString(easingOption)) {
        console.error('MUI: Argument "easing" must be a string.');
      }
      if (!isNumber(delay) && !isString(delay)) {
        console.error('MUI: Argument "delay" must be a number or a string.');
      }
      if (Object.keys(other).length !== 0) {
        console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(",")}].`);
      }
    }
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return _extends({
    getAutoHeightDuration,
    create
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
var _excluded4, easing, duration;
var init_createTransitions = __esm({
  "node_modules/@mui/material/esm/styles/createTransitions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    _excluded4 = ["duration", "easing", "delay"];
    easing = {
      easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
      easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
      easeIn: "cubic-bezier(0.4, 0, 1, 1)",
      sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
    };
    duration = {
      shortest: 150,
      shorter: 200,
      short: 250,
      standard: 300,
      complex: 375,
      enteringScreen: 225,
      leavingScreen: 195
    };
  }
});

// node_modules/@mui/base/BadgeUnstyled/useBadge.js
function useBadge(parameters) {
  const {
    badgeContent: badgeContentProp,
    invisible: invisibleProp = false,
    max: maxProp = 99,
    showZero = false
  } = parameters;
  const prevProps = usePreviousProps_default({
    badgeContent: badgeContentProp,
    max: maxProp
  });
  let invisible = invisibleProp;
  if (invisibleProp === false && badgeContentProp === 0 && !showZero) {
    invisible = true;
  }
  const {
    badgeContent,
    max = maxProp
  } = invisible ? prevProps : parameters;
  const displayValue = badgeContent && Number(badgeContent) > max ? `${max}+` : badgeContent;
  return {
    badgeContent,
    invisible,
    max,
    displayValue
  };
}
var init_useBadge = __esm({
  "node_modules/@mui/base/BadgeUnstyled/useBadge.js"() {
    init_esm();
  }
});

// node_modules/@mui/base/BadgeUnstyled/badgeUnstyledClasses.js
function getBadgeUnstyledUtilityClass(slot) {
  return generateUtilityClass("BaseBadge", slot);
}
var badgeUnstyledClasses;
var init_badgeUnstyledClasses = __esm({
  "node_modules/@mui/base/BadgeUnstyled/badgeUnstyledClasses.js"() {
    init_generateUtilityClasses();
    init_generateUtilityClass();
    badgeUnstyledClasses = generateUtilityClasses("BaseBadge", ["root", "badge", "invisible"]);
  }
});

// node_modules/@mui/base/BadgeUnstyled/BadgeUnstyled.js
var React8, import_prop_types7, import_jsx_runtime10, import_jsx_runtime11, _excluded5, useUtilityClasses2, BadgeUnstyled, BadgeUnstyled_default;
var init_BadgeUnstyled = __esm({
  "node_modules/@mui/base/BadgeUnstyled/BadgeUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React8 = __toESM(require_react());
    import_prop_types7 = __toESM(require_prop_types());
    init_composeClasses();
    init_useBadge();
    init_badgeUnstyledClasses();
    init_utils();
    import_jsx_runtime10 = __toESM(require_jsx_runtime());
    import_jsx_runtime11 = __toESM(require_jsx_runtime());
    _excluded5 = ["badgeContent", "component", "children", "components", "componentsProps", "invisible", "max", "showZero"];
    useUtilityClasses2 = (ownerState) => {
      const {
        invisible
      } = ownerState;
      const slots = {
        root: ["root"],
        badge: ["badge", invisible && "invisible"]
      };
      return composeClasses(slots, getBadgeUnstyledUtilityClass, void 0);
    };
    BadgeUnstyled = React8.forwardRef(function BadgeUnstyled2(props, ref) {
      const {
        component,
        children,
        components = {},
        componentsProps = {},
        max: maxProp = 99,
        showZero = false
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
      const {
        badgeContent,
        max,
        displayValue,
        invisible
      } = useBadge(_extends({}, props, {
        max: maxProp
      }));
      const ownerState = _extends({}, props, {
        badgeContent,
        invisible,
        max,
        showZero
      });
      const classes = useUtilityClasses2(ownerState);
      const Root = component || components.Root || "span";
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref
        },
        ownerState,
        className: classes.root
      });
      const Badge = components.Badge || "span";
      const badgeProps = useSlotProps({
        elementType: Badge,
        externalSlotProps: componentsProps.badge,
        ownerState,
        className: classes.badge
      });
      return (0, import_jsx_runtime11.jsxs)(Root, _extends({}, rootProps, {
        children: [children, (0, import_jsx_runtime10.jsx)(Badge, _extends({}, badgeProps, {
          children: displayValue
        }))]
      }));
    });
    true ? BadgeUnstyled.propTypes = {
      badgeContent: import_prop_types7.default.node,
      children: import_prop_types7.default.node,
      component: import_prop_types7.default.elementType,
      components: import_prop_types7.default.shape({
        Badge: import_prop_types7.default.elementType,
        Root: import_prop_types7.default.elementType
      }),
      componentsProps: import_prop_types7.default.shape({
        badge: import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object]),
        root: import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object])
      }),
      invisible: import_prop_types7.default.bool,
      max: import_prop_types7.default.number,
      showZero: import_prop_types7.default.bool
    } : void 0;
    BadgeUnstyled_default = BadgeUnstyled;
  }
});

// node_modules/@mui/base/BadgeUnstyled/BadgeUnstyled.types.js
var init_BadgeUnstyled_types = __esm({
  "node_modules/@mui/base/BadgeUnstyled/BadgeUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/BadgeUnstyled/index.js
var init_BadgeUnstyled2 = __esm({
  "node_modules/@mui/base/BadgeUnstyled/index.js"() {
    init_BadgeUnstyled();
    init_useBadge();
    init_useBadge();
    init_BadgeUnstyled_types();
    init_badgeUnstyledClasses();
    init_badgeUnstyledClasses();
  }
});

// node_modules/@mui/base/ButtonUnstyled/buttonUnstyledClasses.js
function getButtonUnstyledUtilityClass(slot) {
  return generateUtilityClass("ButtonUnstyled", slot);
}
var buttonUnstyledClasses;
var init_buttonUnstyledClasses = __esm({
  "node_modules/@mui/base/ButtonUnstyled/buttonUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    buttonUnstyledClasses = generateUtilityClasses("ButtonUnstyled", ["root", "active", "disabled", "focusVisible"]);
  }
});

// node_modules/@mui/base/ButtonUnstyled/useButton.js
function useButton(parameters) {
  const {
    disabled = false,
    focusableWhenDisabled,
    href,
    ref: externalRef,
    tabIndex,
    to,
    type
  } = parameters;
  const buttonRef = React9.useRef();
  const [active, setActive] = React9.useState(false);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = React9.useState(false);
  if (disabled && !focusableWhenDisabled && focusVisible) {
    setFocusVisible(false);
  }
  React9.useEffect(() => {
    isFocusVisibleRef.current = focusVisible;
  }, [focusVisible, isFocusVisibleRef]);
  const [hostElementName, setHostElementName] = React9.useState("");
  const createHandleMouseLeave = (otherHandlers) => (event) => {
    var _otherHandlers$onMous;
    if (focusVisible) {
      event.preventDefault();
    }
    (_otherHandlers$onMous = otherHandlers.onMouseLeave) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);
  };
  const createHandleBlur = (otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
  };
  const createHandleFocus = (otherHandlers) => (event) => {
    var _otherHandlers$onFocu2;
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      var _otherHandlers$onFocu;
      setFocusVisible(true);
      (_otherHandlers$onFocu = otherHandlers.onFocusVisible) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
    }
    (_otherHandlers$onFocu2 = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu2.call(otherHandlers, event);
  };
  const isNativeButton = () => {
    const button = buttonRef.current;
    return hostElementName === "BUTTON" || hostElementName === "INPUT" && ["button", "submit", "reset"].includes(button == null ? void 0 : button.type) || hostElementName === "A" && (button == null ? void 0 : button.href);
  };
  const createHandleClick = (otherHandlers) => (event) => {
    if (!disabled) {
      var _otherHandlers$onClic;
      (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
    }
  };
  const createHandleMouseDown = (otherHandlers) => (event) => {
    var _otherHandlers$onMous2;
    if (event.target === event.currentTarget && !disabled) {
      setActive(true);
    }
    (_otherHandlers$onMous2 = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous2.call(otherHandlers, event);
  };
  const createHandleMouseUp = (otherHandlers) => (event) => {
    var _otherHandlers$onMous3;
    if (event.target === event.currentTarget) {
      setActive(false);
    }
    (_otherHandlers$onMous3 = otherHandlers.onMouseUp) == null ? void 0 : _otherHandlers$onMous3.call(otherHandlers, event);
  };
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    if (event.target === event.currentTarget && !isNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (event.target === event.currentTarget && event.key === " " && !disabled) {
      setActive(true);
    }
    if (event.target === event.currentTarget && !isNativeButton() && event.key === "Enter" && !disabled) {
      var _otherHandlers$onClic2;
      (_otherHandlers$onClic2 = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic2.call(otherHandlers, event);
      event.preventDefault();
    }
  };
  const createHandleKeyUp = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyU;
    if (event.target === event.currentTarget) {
      setActive(false);
    }
    (_otherHandlers$onKeyU = otherHandlers.onKeyUp) == null ? void 0 : _otherHandlers$onKeyU.call(otherHandlers, event);
    if (event.target === event.currentTarget && !isNativeButton() && !disabled && event.key === " " && !event.defaultPrevented) {
      var _otherHandlers$onClic3;
      (_otherHandlers$onClic3 = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic3.call(otherHandlers, event);
    }
  };
  const updateHostElementName = React9.useCallback((instance) => {
    var _instance$tagName;
    setHostElementName((_instance$tagName = instance == null ? void 0 : instance.tagName) != null ? _instance$tagName : "");
  }, []);
  const handleRef = useForkRef(updateHostElementName, useForkRef(externalRef, useForkRef(focusVisibleRef, buttonRef)));
  const buttonProps = {};
  if (hostElementName === "BUTTON") {
    buttonProps.type = type != null ? type : "button";
    if (focusableWhenDisabled) {
      buttonProps["aria-disabled"] = disabled;
    } else {
      buttonProps.disabled = disabled;
    }
  } else if (hostElementName !== "") {
    if (!href && !to) {
      buttonProps.role = "button";
      buttonProps.tabIndex = tabIndex != null ? tabIndex : 0;
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
      buttonProps.tabIndex = focusableWhenDisabled ? tabIndex != null ? tabIndex : 0 : -1;
    }
  }
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);
    delete externalEventHandlers.onFocusVisible;
    return _extends({
      type
    }, externalEventHandlers, buttonProps, {
      onBlur: createHandleBlur(externalEventHandlers),
      onClick: createHandleClick(externalEventHandlers),
      onFocus: createHandleFocus(externalEventHandlers),
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      onKeyUp: createHandleKeyUp(externalEventHandlers),
      onMouseDown: createHandleMouseDown(externalEventHandlers),
      onMouseLeave: createHandleMouseLeave(externalEventHandlers),
      onMouseUp: createHandleMouseUp(externalEventHandlers),
      ref: handleRef
    });
  };
  return {
    getRootProps,
    focusVisible,
    setFocusVisible,
    disabled,
    active
  };
}
var React9;
var init_useButton = __esm({
  "node_modules/@mui/base/ButtonUnstyled/useButton.js"() {
    init_extends();
    React9 = __toESM(require_react());
    init_esm();
    init_extractEventHandlers();
  }
});

// node_modules/@mui/base/ButtonUnstyled/ButtonUnstyled.js
var React10, import_prop_types8, import_jsx_runtime12, _excluded6, useUtilityClasses3, ButtonUnstyled;
var init_ButtonUnstyled = __esm({
  "node_modules/@mui/base/ButtonUnstyled/ButtonUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React10 = __toESM(require_react());
    import_prop_types8 = __toESM(require_prop_types());
    init_composeClasses();
    init_buttonUnstyledClasses();
    init_useButton();
    init_utils();
    import_jsx_runtime12 = __toESM(require_jsx_runtime());
    _excluded6 = ["action", "children", "component", "components", "componentsProps", "disabled", "focusableWhenDisabled", "onBlur", "onClick", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseLeave"];
    useUtilityClasses3 = (ownerState) => {
      const {
        active,
        disabled,
        focusVisible
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", focusVisible && "focusVisible", active && "active"]
      };
      return composeClasses(slots, getButtonUnstyledUtilityClass, {});
    };
    ButtonUnstyled = React10.forwardRef(function ButtonUnstyled2(props, forwardedRef) {
      var _ref;
      const {
        action,
        children,
        component,
        components = {},
        componentsProps = {},
        focusableWhenDisabled = false
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
      const buttonRef = React10.useRef();
      const {
        active,
        focusVisible,
        setFocusVisible,
        getRootProps
      } = useButton(_extends({}, props, {
        focusableWhenDisabled
      }));
      React10.useImperativeHandle(action, () => ({
        focusVisible: () => {
          setFocusVisible(true);
          buttonRef.current.focus();
        }
      }), [setFocusVisible]);
      const ownerState = _extends({}, props, {
        active,
        focusableWhenDisabled,
        focusVisible
      });
      const classes = useUtilityClasses3(ownerState);
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "button";
      const rootProps = useSlotProps({
        elementType: Root,
        getSlotProps: getRootProps,
        externalForwardedProps: other,
        externalSlotProps: componentsProps.root,
        additionalProps: {
          ref: forwardedRef
        },
        ownerState,
        className: classes.root
      });
      return (0, import_jsx_runtime12.jsx)(Root, _extends({}, rootProps, {
        children
      }));
    });
    true ? ButtonUnstyled.propTypes = {
      action: import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.shape({
        current: import_prop_types8.default.shape({
          focusVisible: import_prop_types8.default.func.isRequired
        })
      })]),
      children: import_prop_types8.default.node,
      component: import_prop_types8.default.elementType,
      components: import_prop_types8.default.shape({
        Root: import_prop_types8.default.elementType
      }),
      componentsProps: import_prop_types8.default.shape({
        root: import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.object])
      }),
      disabled: import_prop_types8.default.bool,
      focusableWhenDisabled: import_prop_types8.default.bool,
      onBlur: import_prop_types8.default.func,
      onClick: import_prop_types8.default.func,
      onFocus: import_prop_types8.default.func,
      onFocusVisible: import_prop_types8.default.func,
      onKeyDown: import_prop_types8.default.func,
      onKeyUp: import_prop_types8.default.func,
      onMouseLeave: import_prop_types8.default.func
    } : void 0;
  }
});

// node_modules/@mui/base/ButtonUnstyled/ButtonUnstyled.types.js
var init_ButtonUnstyled_types = __esm({
  "node_modules/@mui/base/ButtonUnstyled/ButtonUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/ButtonUnstyled/useButton.types.js
var init_useButton_types = __esm({
  "node_modules/@mui/base/ButtonUnstyled/useButton.types.js"() {
  }
});

// node_modules/@mui/base/ButtonUnstyled/index.js
var init_ButtonUnstyled2 = __esm({
  "node_modules/@mui/base/ButtonUnstyled/index.js"() {
    init_ButtonUnstyled();
    init_buttonUnstyledClasses();
    init_ButtonUnstyled_types();
    init_useButton();
    init_useButton_types();
  }
});

// node_modules/@mui/base/FormControlUnstyled/FormControlUnstyledContext.js
var React11, FormControlUnstyledContext, FormControlUnstyledContext_default;
var init_FormControlUnstyledContext = __esm({
  "node_modules/@mui/base/FormControlUnstyled/FormControlUnstyledContext.js"() {
    React11 = __toESM(require_react());
    FormControlUnstyledContext = React11.createContext(void 0);
    if (true) {
      FormControlUnstyledContext.displayName = "FormControlUnstyledContext";
    }
    FormControlUnstyledContext_default = FormControlUnstyledContext;
  }
});

// node_modules/@mui/base/FormControlUnstyled/formControlUnstyledClasses.js
function getFormControlUnstyledUtilityClass(slot) {
  return generateUtilityClass("BaseFormControl", slot);
}
var formControlUnstyledClasses;
var init_formControlUnstyledClasses = __esm({
  "node_modules/@mui/base/FormControlUnstyled/formControlUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    formControlUnstyledClasses = generateUtilityClasses("BaseFormControl", ["root", "disabled", "error", "filled", "focused", "required"]);
  }
});

// node_modules/@mui/base/FormControlUnstyled/FormControlUnstyled.js
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0) && value !== "";
}
function useUtilityClasses4(ownerState) {
  const {
    disabled,
    error,
    filled,
    focused,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focused && "focused", error && "error", filled && "filled", required && "required"]
  };
  return composeClasses(slots, getFormControlUnstyledUtilityClass, {});
}
var React12, import_prop_types9, import_jsx_runtime13, _excluded7, FormControlUnstyled;
var init_FormControlUnstyled = __esm({
  "node_modules/@mui/base/FormControlUnstyled/FormControlUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React12 = __toESM(require_react());
    import_prop_types9 = __toESM(require_prop_types());
    init_esm();
    init_FormControlUnstyledContext();
    init_formControlUnstyledClasses();
    init_utils();
    init_composeClasses();
    import_jsx_runtime13 = __toESM(require_jsx_runtime());
    _excluded7 = ["defaultValue", "children", "component", "components", "componentsProps", "disabled", "error", "onChange", "required", "value"];
    FormControlUnstyled = React12.forwardRef(function FormControlUnstyled2(props, ref) {
      var _ref;
      const {
        defaultValue,
        children,
        component,
        components = {},
        componentsProps = {},
        disabled = false,
        error = false,
        onChange,
        required = false,
        value: incomingValue
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded7);
      const [value, setValue] = useControlled({
        controlled: incomingValue,
        default: defaultValue,
        name: "FormControl",
        state: "value"
      });
      const filled = hasValue(value);
      const [focused, setFocused] = React12.useState(false);
      if (disabled && focused) {
        setFocused(false);
      }
      const ownerState = _extends({}, props, {
        disabled,
        error,
        filled,
        focused,
        required
      });
      const handleChange = (event) => {
        setValue(event.target.value);
        onChange == null ? void 0 : onChange(event);
      };
      const childContext = {
        disabled,
        error,
        filled,
        focused,
        onBlur: () => {
          setFocused(false);
        },
        onChange: handleChange,
        onFocus: () => {
          setFocused(true);
        },
        required,
        value: value != null ? value : ""
      };
      const classes = useUtilityClasses4(ownerState);
      const renderChildren = () => {
        if (typeof children === "function") {
          return children(childContext);
        }
        return children;
      };
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref,
          children: renderChildren()
        },
        ownerState,
        className: classes.root
      });
      return (0, import_jsx_runtime13.jsx)(FormControlUnstyledContext_default.Provider, {
        value: childContext,
        children: (0, import_jsx_runtime13.jsx)(Root, _extends({}, rootProps))
      });
    });
    true ? FormControlUnstyled.propTypes = {
      children: import_prop_types9.default.oneOfType([import_prop_types9.default.node, import_prop_types9.default.func]),
      component: import_prop_types9.default.elementType,
      components: import_prop_types9.default.shape({
        Root: import_prop_types9.default.elementType
      }),
      componentsProps: import_prop_types9.default.shape({
        root: import_prop_types9.default.oneOfType([import_prop_types9.default.func, import_prop_types9.default.object])
      }),
      defaultValue: import_prop_types9.default.any,
      disabled: import_prop_types9.default.bool,
      error: import_prop_types9.default.bool,
      onChange: import_prop_types9.default.func,
      required: import_prop_types9.default.bool,
      value: import_prop_types9.default.any
    } : void 0;
  }
});

// node_modules/@mui/base/FormControlUnstyled/useFormControlUnstyledContext.js
function useFormControlUnstyledContext() {
  return React13.useContext(FormControlUnstyledContext_default);
}
var React13;
var init_useFormControlUnstyledContext = __esm({
  "node_modules/@mui/base/FormControlUnstyled/useFormControlUnstyledContext.js"() {
    React13 = __toESM(require_react());
    init_FormControlUnstyledContext();
  }
});

// node_modules/@mui/base/FormControlUnstyled/index.js
var init_FormControlUnstyled2 = __esm({
  "node_modules/@mui/base/FormControlUnstyled/index.js"() {
    init_FormControlUnstyled();
    init_FormControlUnstyledContext();
    init_formControlUnstyledClasses();
    init_formControlUnstyledClasses();
    init_useFormControlUnstyledContext();
  }
});

// node_modules/@mui/base/InputUnstyled/inputUnstyledClasses.js
var inputBaseClasses, inputUnstyledClasses_default;
var init_inputUnstyledClasses = __esm({
  "node_modules/@mui/base/InputUnstyled/inputUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    inputBaseClasses = generateUtilityClasses("MuiInput", ["root", "formControl", "focused", "disabled", "error", "multiline", "input", "inputMultiline", "inputTypeSearch", "adornedStart", "adornedEnd"]);
    inputUnstyledClasses_default = inputBaseClasses;
  }
});

// node_modules/@mui/base/InputUnstyled/useInput.js
function useInput(parameters) {
  const {
    defaultValue: defaultValueProp,
    disabled: disabledProp = false,
    error: errorProp = false,
    onBlur,
    onChange,
    onFocus,
    required: requiredProp = false,
    value: valueProp
  } = parameters;
  const formControlContext = useFormControlUnstyledContext();
  let defaultValue;
  let disabled;
  let error;
  let required;
  let value;
  if (formControlContext) {
    var _formControlContext$d, _formControlContext$e, _formControlContext$r;
    defaultValue = void 0;
    disabled = (_formControlContext$d = formControlContext.disabled) != null ? _formControlContext$d : false;
    error = (_formControlContext$e = formControlContext.error) != null ? _formControlContext$e : false;
    required = (_formControlContext$r = formControlContext.required) != null ? _formControlContext$r : false;
    value = formControlContext.value;
    if (true) {
      const definedLocalProps = ["defaultValue", "disabled", "error", "required", "value"].filter((prop) => parameters[prop] !== void 0);
      if (definedLocalProps.length > 0) {
        console.warn(["MUI: You have set props on an input that is inside a FormControlUnstyled.", "Set these props on a FormControlUnstyled instead. Otherwise they will be ignored.", `Ignored props: ${definedLocalProps.join(", ")}`].join("\n"));
      }
    }
  } else {
    defaultValue = defaultValueProp;
    disabled = disabledProp;
    error = errorProp;
    required = requiredProp;
    value = valueProp;
  }
  const {
    current: isControlled
  } = React14.useRef(value != null);
  const handleInputRefWarning = React14.useCallback((instance) => {
    if (true) {
      if (instance && instance.nodeName !== "INPUT" && !instance.focus) {
        console.error(["MUI: You have provided a `components.Input` to the input component", "that does not correctly handle the `ref` prop.", "Make sure the `ref` prop is called with a HTMLInputElement."].join("\n"));
      }
    }
  }, []);
  const inputRef = React14.useRef(null);
  const handleInputRef = useForkRef(inputRef, handleInputRefWarning);
  const [focused, setFocused] = React14.useState(false);
  React14.useEffect(() => {
    if (!formControlContext && disabled && focused) {
      setFocused(false);
      onBlur == null ? void 0 : onBlur();
    }
  }, [formControlContext, disabled, focused, onBlur]);
  const handleFocus = (otherHandlers) => (event) => {
    var _otherHandlers$onFocu;
    if (formControlContext != null && formControlContext.disabled) {
      event.stopPropagation();
      return;
    }
    (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
    if (formControlContext && formControlContext.onFocus) {
      var _formControlContext$o;
      formControlContext == null ? void 0 : (_formControlContext$o = formControlContext.onFocus) == null ? void 0 : _formControlContext$o.call(formControlContext);
    } else {
      setFocused(true);
    }
  };
  const handleBlur2 = (otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
    if (formControlContext && formControlContext.onBlur) {
      formControlContext.onBlur();
    } else {
      setFocused(false);
    }
  };
  const handleChange = (otherHandlers) => (event, ...args) => {
    var _formControlContext$o2, _otherHandlers$onChan;
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(true ? `MUI: Expected valid input target. Did you use a custom \`components.Input\` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info.` : formatMuiErrorMessage(17));
      }
    }
    formControlContext == null ? void 0 : (_formControlContext$o2 = formControlContext.onChange) == null ? void 0 : _formControlContext$o2.call(formControlContext, event);
    (_otherHandlers$onChan = otherHandlers.onChange) == null ? void 0 : _otherHandlers$onChan.call(otherHandlers, event, ...args);
  };
  const handleClick = (otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
  };
  const getRootProps = (externalProps = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters, ["onBlur", "onChange", "onFocus"]);
    const externalEventHandlers = _extends({}, propsEventHandlers, extractEventHandlers(externalProps));
    return _extends({}, externalProps, externalEventHandlers, {
      onClick: handleClick(externalEventHandlers)
    });
  };
  const getInputProps = (externalProps = {}) => {
    const propsEventHandlers = {
      onBlur,
      onChange,
      onFocus
    };
    const externalEventHandlers = _extends({}, propsEventHandlers, extractEventHandlers(externalProps));
    const mergedEventHandlers = _extends({}, externalProps, externalEventHandlers, {
      onBlur: handleBlur2(externalEventHandlers),
      onChange: handleChange(externalEventHandlers),
      onFocus: handleFocus(externalEventHandlers)
    });
    return _extends({}, mergedEventHandlers, {
      "aria-invalid": error || void 0,
      defaultValue,
      ref: handleInputRef,
      value,
      required,
      disabled
    });
  };
  return {
    disabled,
    error,
    focused,
    formControlContext,
    getInputProps,
    getRootProps,
    required,
    value
  };
}
var React14;
var init_useInput = __esm({
  "node_modules/@mui/base/InputUnstyled/useInput.js"() {
    init_extends();
    init_esm();
    React14 = __toESM(require_react());
    init_esm();
    init_FormControlUnstyled2();
    init_extractEventHandlers();
  }
});

// node_modules/@mui/base/InputUnstyled/InputUnstyled.js
var React15, import_prop_types10, import_jsx_runtime14, import_jsx_runtime15, _excluded8, InputUnstyled;
var init_InputUnstyled = __esm({
  "node_modules/@mui/base/InputUnstyled/InputUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React15 = __toESM(require_react());
    import_prop_types10 = __toESM(require_prop_types());
    init_isHostComponent();
    init_inputUnstyledClasses();
    init_useInput();
    init_utils();
    import_jsx_runtime14 = __toESM(require_jsx_runtime());
    import_jsx_runtime15 = __toESM(require_jsx_runtime());
    _excluded8 = ["aria-describedby", "aria-label", "aria-labelledby", "autoComplete", "autoFocus", "className", "component", "components", "componentsProps", "defaultValue", "disabled", "endAdornment", "error", "id", "multiline", "name", "onClick", "onChange", "onKeyDown", "onKeyUp", "onFocus", "onBlur", "placeholder", "readOnly", "required", "startAdornment", "value", "type", "rows", "minRows", "maxRows"];
    InputUnstyled = React15.forwardRef(function InputUnstyled2(props, forwardedRef) {
      var _ref, _components$Textarea, _components$Input;
      const {
        "aria-describedby": ariaDescribedby,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledby,
        autoComplete,
        autoFocus,
        className,
        component,
        components = {},
        componentsProps = {},
        defaultValue,
        disabled,
        endAdornment,
        error,
        id,
        multiline = false,
        name,
        onClick,
        onChange,
        onKeyDown,
        onKeyUp,
        onFocus,
        onBlur,
        placeholder,
        readOnly,
        required,
        startAdornment,
        value,
        type: typeProp,
        rows,
        minRows,
        maxRows
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded8);
      const {
        getRootProps,
        getInputProps,
        focused,
        formControlContext,
        error: errorState,
        disabled: disabledState
      } = useInput({
        disabled,
        defaultValue,
        error,
        onBlur,
        onClick,
        onChange,
        onFocus,
        required,
        value
      });
      const type = !multiline ? typeProp != null ? typeProp : "text" : void 0;
      const ownerState = _extends({}, props, {
        disabled: disabledState,
        error: errorState,
        focused,
        formControlContext,
        multiline,
        type
      });
      const rootStateClasses = {
        [inputUnstyledClasses_default.disabled]: disabledState,
        [inputUnstyledClasses_default.error]: errorState,
        [inputUnstyledClasses_default.focused]: focused,
        [inputUnstyledClasses_default.formControl]: Boolean(formControlContext),
        [inputUnstyledClasses_default.multiline]: multiline,
        [inputUnstyledClasses_default.adornedStart]: Boolean(startAdornment),
        [inputUnstyledClasses_default.adornedEnd]: Boolean(endAdornment)
      };
      const inputStateClasses = {
        [inputUnstyledClasses_default.disabled]: disabledState,
        [inputUnstyledClasses_default.multiline]: multiline
      };
      const propsToForward = {
        "aria-describedby": ariaDescribedby,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledby,
        autoComplete,
        autoFocus,
        id,
        onKeyDown,
        onKeyUp,
        name,
        placeholder,
        readOnly,
        type
      };
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
      const rootProps = useSlotProps({
        elementType: Root,
        getSlotProps: getRootProps,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref: forwardedRef
        },
        ownerState,
        className: [inputUnstyledClasses_default.root, rootStateClasses, className]
      });
      const Input = multiline ? (_components$Textarea = components.Textarea) != null ? _components$Textarea : "textarea" : (_components$Input = components.Input) != null ? _components$Input : "input";
      const inputProps = useSlotProps({
        elementType: Input,
        getSlotProps: (otherHandlers) => getInputProps(_extends({}, otherHandlers, propsToForward)),
        externalSlotProps: componentsProps.input,
        additionalProps: _extends({
          rows: multiline ? rows : void 0
        }, multiline && !isHostComponent_default(Input) && {
          minRows: rows || minRows,
          maxRows: rows || maxRows
        }),
        ownerState,
        className: [inputUnstyledClasses_default.input, inputStateClasses]
      });
      if (true) {
        if (multiline) {
          if (rows) {
            if (minRows || maxRows) {
              console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set.");
            }
          }
        }
      }
      return (0, import_jsx_runtime15.jsxs)(Root, _extends({}, rootProps, {
        children: [startAdornment, (0, import_jsx_runtime14.jsx)(Input, _extends({}, inputProps)), endAdornment]
      }));
    });
    true ? InputUnstyled.propTypes = {
      "aria-describedby": import_prop_types10.default.string,
      "aria-label": import_prop_types10.default.string,
      "aria-labelledby": import_prop_types10.default.string,
      autoComplete: import_prop_types10.default.string,
      autoFocus: import_prop_types10.default.bool,
      children: import_prop_types10.default.node,
      className: import_prop_types10.default.string,
      component: import_prop_types10.default.elementType,
      components: import_prop_types10.default.shape({
        Input: import_prop_types10.default.elementType,
        Root: import_prop_types10.default.elementType,
        Textarea: import_prop_types10.default.elementType
      }),
      componentsProps: import_prop_types10.default.shape({
        input: import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object]),
        root: import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object])
      }),
      defaultValue: import_prop_types10.default.any,
      disabled: import_prop_types10.default.bool,
      endAdornment: import_prop_types10.default.node,
      error: import_prop_types10.default.bool,
      id: import_prop_types10.default.string,
      maxRows: import_prop_types10.default.number,
      minRows: import_prop_types10.default.number,
      multiline: import_prop_types10.default.bool,
      name: import_prop_types10.default.string,
      onBlur: import_prop_types10.default.func,
      onChange: import_prop_types10.default.func,
      onClick: import_prop_types10.default.func,
      onFocus: import_prop_types10.default.func,
      onKeyDown: import_prop_types10.default.func,
      onKeyUp: import_prop_types10.default.func,
      placeholder: import_prop_types10.default.string,
      readOnly: import_prop_types10.default.bool,
      required: import_prop_types10.default.bool,
      rows: import_prop_types10.default.number,
      startAdornment: import_prop_types10.default.node,
      type: import_prop_types10.default.oneOf(["button", "checkbox", "color", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]),
      value: import_prop_types10.default.any
    } : void 0;
  }
});

// node_modules/@mui/base/InputUnstyled/InputUnstyled.types.js
var init_InputUnstyled_types = __esm({
  "node_modules/@mui/base/InputUnstyled/InputUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/InputUnstyled/useInput.types.js
var init_useInput_types = __esm({
  "node_modules/@mui/base/InputUnstyled/useInput.types.js"() {
  }
});

// node_modules/@mui/base/InputUnstyled/index.js
var init_InputUnstyled2 = __esm({
  "node_modules/@mui/base/InputUnstyled/index.js"() {
    init_InputUnstyled();
    init_InputUnstyled_types();
    init_useInput();
    init_useInput_types();
    init_inputUnstyledClasses();
    init_inputUnstyledClasses();
  }
});

// node_modules/@mui/base/ListboxUnstyled/useListbox.types.js
var ActionTypes;
var init_useListbox_types = __esm({
  "node_modules/@mui/base/ListboxUnstyled/useListbox.types.js"() {
    (function(ActionTypes2) {
      ActionTypes2["blur"] = "blur";
      ActionTypes2["focus"] = "focus";
      ActionTypes2["keyDown"] = "keyDown";
      ActionTypes2["optionClick"] = "optionClick";
      ActionTypes2["optionHover"] = "optionHover";
      ActionTypes2["optionsChange"] = "optionsChange";
      ActionTypes2["setValue"] = "setValue";
      ActionTypes2["setHighlight"] = "setHighlight";
      ActionTypes2["textNavigation"] = "textNagivation";
    })(ActionTypes || (ActionTypes = {}));
  }
});

// node_modules/@mui/base/ListboxUnstyled/defaultListboxReducer.js
function findValidOptionToHighlight(index, lookupDirection, options, focusDisabled, isOptionDisabled, wrapAround) {
  if (options.length === 0 || options.every((o, i) => isOptionDisabled(o, i))) {
    return -1;
  }
  let nextFocus = index;
  for (; ; ) {
    if (!wrapAround && lookupDirection === "next" && nextFocus === options.length || !wrapAround && lookupDirection === "previous" && nextFocus === -1) {
      return -1;
    }
    const nextFocusDisabled = focusDisabled ? false : isOptionDisabled(options[nextFocus], nextFocus);
    if (nextFocusDisabled) {
      nextFocus += lookupDirection === "next" ? 1 : -1;
      if (wrapAround) {
        nextFocus = (nextFocus + options.length) % options.length;
      }
    } else {
      return nextFocus;
    }
  }
}
function getNewHighlightedOption(options, previouslyHighlightedOption, diff, lookupDirection, highlightDisabled, isOptionDisabled, wrapAround, optionComparer) {
  var _options$nextIndex;
  const maxIndex = options.length - 1;
  const defaultHighlightedIndex = -1;
  let nextIndexCandidate;
  const previouslyHighlightedIndex = previouslyHighlightedOption == null ? -1 : options.findIndex((option) => optionComparer(option, previouslyHighlightedOption));
  if (diff === "reset") {
    var _options$defaultHighl;
    return defaultHighlightedIndex === -1 ? null : (_options$defaultHighl = options[defaultHighlightedIndex]) != null ? _options$defaultHighl : null;
  }
  if (diff === "start") {
    nextIndexCandidate = 0;
  } else if (diff === "end") {
    nextIndexCandidate = maxIndex;
  } else {
    const newIndex = previouslyHighlightedIndex + diff;
    if (newIndex < 0) {
      if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(diff) > 1) {
        nextIndexCandidate = 0;
      } else {
        nextIndexCandidate = maxIndex;
      }
    } else if (newIndex > maxIndex) {
      if (!wrapAround || Math.abs(diff) > 1) {
        nextIndexCandidate = maxIndex;
      } else {
        nextIndexCandidate = 0;
      }
    } else {
      nextIndexCandidate = newIndex;
    }
  }
  const nextIndex = findValidOptionToHighlight(nextIndexCandidate, lookupDirection, options, highlightDisabled, isOptionDisabled, wrapAround);
  return (_options$nextIndex = options[nextIndex]) != null ? _options$nextIndex : null;
}
function handleOptionSelection(option, state, props) {
  const {
    multiple,
    optionComparer = (o, v) => o === v,
    isOptionDisabled = () => false
  } = props;
  const {
    selectedValue
  } = state;
  const optionIndex = props.options.findIndex((o) => props.optionComparer(option, o));
  if (isOptionDisabled(option, optionIndex)) {
    return state;
  }
  if (multiple) {
    var _ref, _ref2;
    const selectedValues = (_ref = selectedValue) != null ? _ref : [];
    const newSelectedValues = selectedValues.some((sv) => optionComparer(sv, option)) ? selectedValue.filter((v) => !optionComparer(v, option)) : [...(_ref2 = selectedValue) != null ? _ref2 : [], option];
    return {
      selectedValue: newSelectedValues,
      highlightedValue: option
    };
  }
  if (selectedValue != null && optionComparer(option, selectedValue)) {
    return state;
  }
  return {
    selectedValue: option,
    highlightedValue: option
  };
}
function handleKeyDown(event, state, props) {
  const {
    options,
    isOptionDisabled,
    disableListWrap,
    disabledItemsFocusable,
    optionComparer
  } = props;
  const moveHighlight = (diff, direction, wrapAround) => {
    return getNewHighlightedOption(options, state.highlightedValue, diff, direction, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, wrapAround, optionComparer);
  };
  switch (event.key) {
    case "Home":
      return _extends({}, state, {
        highlightedValue: moveHighlight("start", "next", false)
      });
    case "End":
      return _extends({}, state, {
        highlightedValue: moveHighlight("end", "previous", false)
      });
    case "PageUp":
      return _extends({}, state, {
        highlightedValue: moveHighlight(-pageSize2, "previous", false)
      });
    case "PageDown":
      return _extends({}, state, {
        highlightedValue: moveHighlight(pageSize2, "next", false)
      });
    case "ArrowUp":
      return _extends({}, state, {
        highlightedValue: moveHighlight(-1, "previous", !(disableListWrap != null ? disableListWrap : false))
      });
    case "ArrowDown":
      return _extends({}, state, {
        highlightedValue: moveHighlight(1, "next", !(disableListWrap != null ? disableListWrap : false))
      });
    case "Enter":
    case " ":
      if (state.highlightedValue === null) {
        return state;
      }
      return handleOptionSelection(state.highlightedValue, state, props);
    default:
      break;
  }
  return state;
}
function handleBlur(state) {
  return _extends({}, state, {
    highlightedValue: null
  });
}
function handleTextNavigation(state, searchString, props) {
  const {
    options,
    isOptionDisabled,
    disableListWrap,
    disabledItemsFocusable,
    optionComparer,
    optionStringifier
  } = props;
  const moveHighlight = (previouslyHighlightedOption) => {
    return getNewHighlightedOption(options, previouslyHighlightedOption, 1, "next", disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, !(disableListWrap != null ? disableListWrap : false), optionComparer);
  };
  const startWithCurrentOption = searchString.length > 1;
  let nextOption = startWithCurrentOption ? state.highlightedValue : moveHighlight(state.highlightedValue);
  for (let index = 0; index < options.length; index += 1) {
    if (!nextOption || !startWithCurrentOption && state.highlightedValue === nextOption) {
      return state;
    }
    if (textCriteriaMatches(nextOption, searchString, optionStringifier) && (!isOptionDisabled(nextOption, options.indexOf(nextOption)) || disabledItemsFocusable)) {
      return _extends({}, state, {
        highlightedValue: nextOption
      });
    }
    nextOption = moveHighlight(nextOption);
  }
  return state;
}
function handleOptionsChange(options, previousOptions, state, props) {
  var _options$find, _options$find2;
  const {
    multiple,
    optionComparer
  } = props;
  const newHighlightedOption = state.highlightedValue == null ? null : (_options$find = options.find((option) => optionComparer(option, state.highlightedValue))) != null ? _options$find : null;
  if (multiple) {
    var _ref3;
    const selectedValues = (_ref3 = state.selectedValue) != null ? _ref3 : [];
    const newSelectedValues = selectedValues.filter((selectedValue) => options.some((option) => optionComparer(option, selectedValue)));
    return {
      highlightedValue: newHighlightedOption,
      selectedValue: newSelectedValues
    };
  }
  const newSelectedValue = (_options$find2 = options.find((option) => optionComparer(option, state.selectedValue))) != null ? _options$find2 : null;
  return {
    highlightedValue: newHighlightedOption,
    selectedValue: newSelectedValue
  };
}
function defaultListboxReducer(state, action) {
  const {
    type
  } = action;
  switch (type) {
    case ActionTypes.keyDown:
      return handleKeyDown(action.event, state, action.props);
    case ActionTypes.optionClick:
      return handleOptionSelection(action.option, state, action.props);
    case ActionTypes.blur:
      return handleBlur(state);
    case ActionTypes.setValue:
      return _extends({}, state, {
        selectedValue: action.value
      });
    case ActionTypes.setHighlight:
      return _extends({}, state, {
        highlightedValue: action.highlight
      });
    case ActionTypes.textNavigation:
      return handleTextNavigation(state, action.searchString, action.props);
    case ActionTypes.optionsChange:
      return handleOptionsChange(action.options, action.previousOptions, state, action.props);
    default:
      return state;
  }
}
var pageSize2, textCriteriaMatches;
var init_defaultListboxReducer = __esm({
  "node_modules/@mui/base/ListboxUnstyled/defaultListboxReducer.js"() {
    init_extends();
    init_useListbox_types();
    pageSize2 = 5;
    textCriteriaMatches = (nextFocus, searchString, stringifyOption) => {
      var _stringifyOption;
      const text = (_stringifyOption = stringifyOption(nextFocus)) == null ? void 0 : _stringifyOption.trim().toLowerCase();
      if (!text || text.length === 0) {
        return false;
      }
      return text.indexOf(searchString) === 0;
    };
  }
});

// node_modules/@mui/base/ListboxUnstyled/useControllableReducer.js
function getControlledState(internalState, props) {
  if (props.value !== void 0) {
    return _extends({}, internalState, {
      selectedValue: props.value
    });
  }
  return internalState;
}
function areOptionsEqual(option1, option2, optionComparer) {
  if (option1 === option2) {
    return true;
  }
  if (option1 === null || option2 === null) {
    return false;
  }
  return optionComparer(option1, option2);
}
function useStateChangeDetection(nextState, internalPreviousState, propsRef, hasDispatchedActionRef) {
  React16.useEffect(() => {
    if (!propsRef.current || !hasDispatchedActionRef.current) {
      return;
    }
    hasDispatchedActionRef.current = false;
    const previousState = getControlledState(internalPreviousState, propsRef.current);
    const {
      multiple,
      optionComparer
    } = propsRef.current;
    if (multiple) {
      var _previousState$select;
      const previousSelectedValues = (_previousState$select = previousState == null ? void 0 : previousState.selectedValue) != null ? _previousState$select : [];
      const nextSelectedValues = nextState.selectedValue;
      const onChange = propsRef.current.onChange;
      if (!areArraysEqual(nextSelectedValues, previousSelectedValues, optionComparer)) {
        onChange == null ? void 0 : onChange(nextSelectedValues);
      }
    } else {
      const previousSelectedValue = previousState == null ? void 0 : previousState.selectedValue;
      const nextSelectedValue = nextState.selectedValue;
      const onChange = propsRef.current.onChange;
      if (!areOptionsEqual(nextSelectedValue, previousSelectedValue, optionComparer)) {
        onChange == null ? void 0 : onChange(nextSelectedValue);
      }
    }
  }, [nextState.selectedValue, internalPreviousState, propsRef, hasDispatchedActionRef]);
  React16.useEffect(() => {
    if (!propsRef.current) {
      return;
    }
    if (!areOptionsEqual(internalPreviousState.highlightedValue, nextState.highlightedValue, propsRef.current.optionComparer)) {
      var _propsRef$current, _propsRef$current$onH;
      (_propsRef$current = propsRef.current) == null ? void 0 : (_propsRef$current$onH = _propsRef$current.onHighlightChange) == null ? void 0 : _propsRef$current$onH.call(_propsRef$current, nextState.highlightedValue);
    }
  }, [nextState.highlightedValue, internalPreviousState.highlightedValue, propsRef]);
}
function useControllableReducer(internalReducer, externalReducer, props) {
  var _ref;
  const {
    value,
    defaultValue
  } = props;
  const propsRef = React16.useRef(props);
  propsRef.current = props;
  const hasDispatchedActionRef = React16.useRef(false);
  const initialSelectedValue = (_ref = value === void 0 ? defaultValue : value) != null ? _ref : props.multiple ? [] : null;
  const initalState = {
    highlightedValue: null,
    selectedValue: initialSelectedValue
  };
  const combinedReducer = React16.useCallback((state, action) => {
    hasDispatchedActionRef.current = true;
    if (externalReducer) {
      return externalReducer(getControlledState(state, propsRef.current), action);
    }
    return internalReducer(getControlledState(state, propsRef.current), action);
  }, [externalReducer, internalReducer, propsRef]);
  const [nextState, dispatch] = React16.useReducer(combinedReducer, initalState);
  const previousState = React16.useRef(initalState);
  React16.useEffect(() => {
    previousState.current = nextState;
  }, [previousState, nextState]);
  useStateChangeDetection(nextState, previousState.current, propsRef, hasDispatchedActionRef);
  return [getControlledState(nextState, propsRef.current), dispatch];
}
var React16;
var init_useControllableReducer = __esm({
  "node_modules/@mui/base/ListboxUnstyled/useControllableReducer.js"() {
    init_extends();
    React16 = __toESM(require_react());
    init_areArraysEqual();
  }
});

// node_modules/@mui/base/ListboxUnstyled/useListbox.js
function useListbox(props) {
  var _props$optionIdGenera, _options$highlightedI;
  const {
    disabledItemsFocusable = false,
    disableListWrap = false,
    focusManagement = "activeDescendant",
    id: idProp,
    isOptionDisabled = defaultIsOptionDisabled,
    listboxRef: externalListboxRef,
    multiple = false,
    optionComparer = defaultOptionComparer,
    optionStringifier = defaultOptionStringifier,
    options,
    stateReducer: externalReducer
  } = props;
  const id = useId(idProp);
  function defaultIdGenerator(_, index) {
    return `${id}-option-${index}`;
  }
  const optionIdGenerator = (_props$optionIdGenera = props.optionIdGenerator) != null ? _props$optionIdGenera : defaultIdGenerator;
  const propsWithDefaults = _extends({}, props, {
    disabledItemsFocusable,
    disableListWrap,
    focusManagement,
    isOptionDisabled,
    multiple,
    optionComparer,
    optionStringifier
  });
  const listboxRef = React17.useRef(null);
  const handleRef = useForkRef(externalListboxRef, listboxRef);
  const textCriteriaRef = React17.useRef({
    searchString: "",
    lastTime: null
  });
  const [{
    highlightedValue,
    selectedValue
  }, dispatch] = useControllableReducer(defaultListboxReducer, externalReducer, propsWithDefaults);
  const highlightedIndex = React17.useMemo(() => {
    return highlightedValue == null ? -1 : options.findIndex((option) => optionComparer(option, highlightedValue));
  }, [highlightedValue, options, optionComparer]);
  const previousOptions = React17.useRef([]);
  React17.useEffect(() => {
    if (areArraysEqual(previousOptions.current, options, optionComparer)) {
      return;
    }
    dispatch({
      type: ActionTypes.optionsChange,
      options,
      previousOptions: previousOptions.current,
      props: propsWithDefaults
    });
    previousOptions.current = options;
  }, [options, optionComparer, dispatch]);
  const setSelectedValue = React17.useCallback((option) => {
    dispatch({
      type: ActionTypes.setValue,
      value: option
    });
  }, [dispatch]);
  const setHighlightedValue = React17.useCallback((option) => {
    dispatch({
      type: ActionTypes.setHighlight,
      highlight: option
    });
  }, [dispatch]);
  const createHandleOptionClick = (option, other) => (event) => {
    var _other$onClick;
    (_other$onClick = other.onClick) == null ? void 0 : _other$onClick.call(other, event);
    if (event.defaultPrevented) {
      return;
    }
    event.preventDefault();
    dispatch({
      type: ActionTypes.optionClick,
      option,
      event,
      props: propsWithDefaults
    });
  };
  const createHandleOptionMouseOver = (option, other) => (event) => {
    var _other$onMouseOver;
    (_other$onMouseOver = other.onMouseOver) == null ? void 0 : _other$onMouseOver.call(other, event);
    if (event.defaultPrevented) {
      return;
    }
    dispatch({
      type: ActionTypes.optionHover,
      option,
      event,
      props: propsWithDefaults
    });
  };
  const createHandleKeyDown = (other) => (event) => {
    var _other$onKeyDown;
    (_other$onKeyDown = other.onKeyDown) == null ? void 0 : _other$onKeyDown.call(other, event);
    if (event.defaultPrevented) {
      return;
    }
    const keysToPreventDefault = ["ArrowUp", "ArrowDown", "Home", "End", "PageUp", "PageDown"];
    if (focusManagement === "activeDescendant") {
      keysToPreventDefault.push(" ", "Enter");
    }
    if (keysToPreventDefault.includes(event.key)) {
      event.preventDefault();
    }
    dispatch({
      type: ActionTypes.keyDown,
      event,
      props: propsWithDefaults
    });
    if (event.key.length === 1 && event.key !== " ") {
      const textCriteria = textCriteriaRef.current;
      const lowerKey = event.key.toLowerCase();
      const currentTime = performance.now();
      if (textCriteria.searchString.length > 0 && textCriteria.lastTime && currentTime - textCriteria.lastTime > TEXT_NAVIGATION_RESET_TIMEOUT) {
        textCriteria.searchString = lowerKey;
      } else if (textCriteria.searchString.length !== 1 || lowerKey !== textCriteria.searchString) {
        textCriteria.searchString += lowerKey;
      }
      textCriteria.lastTime = currentTime;
      dispatch({
        type: ActionTypes.textNavigation,
        searchString: textCriteria.searchString,
        props: propsWithDefaults
      });
    }
  };
  const createHandleBlur = (other) => (event) => {
    var _other$onBlur, _listboxRef$current;
    (_other$onBlur = other.onBlur) == null ? void 0 : _other$onBlur.call(other, event);
    if (event.defaultPrevented) {
      return;
    }
    if ((_listboxRef$current = listboxRef.current) != null && _listboxRef$current.contains(document.activeElement)) {
      return;
    }
    dispatch({
      type: ActionTypes.blur,
      event,
      props: propsWithDefaults
    });
  };
  const getRootProps = (otherHandlers = {}) => {
    return _extends({}, otherHandlers, {
      "aria-activedescendant": focusManagement === "activeDescendant" && highlightedValue != null ? optionIdGenerator(highlightedValue, highlightedIndex) : void 0,
      id,
      onBlur: createHandleBlur(otherHandlers),
      onKeyDown: createHandleKeyDown(otherHandlers),
      role: "listbox",
      tabIndex: focusManagement === "DOM" ? -1 : 0,
      ref: handleRef
    });
  };
  const getOptionState = (option) => {
    let selected;
    const index = options.findIndex((opt) => optionComparer(opt, option));
    if (multiple) {
      var _ref;
      selected = ((_ref = selectedValue) != null ? _ref : []).some((value) => value != null && optionComparer(option, value));
    } else {
      selected = optionComparer(option, selectedValue);
    }
    const disabled = isOptionDisabled(option, index);
    return {
      selected,
      disabled,
      highlighted: highlightedIndex === index
    };
  };
  const getOptionTabIndex = (optionState) => {
    if (focusManagement === "activeDescendant") {
      return void 0;
    }
    if (!optionState.highlighted) {
      return -1;
    }
    if (optionState.disabled && !disabledItemsFocusable) {
      return -1;
    }
    return 0;
  };
  const getOptionProps = (option, otherHandlers = {}) => {
    const optionState = getOptionState(option);
    const index = options.findIndex((opt) => optionComparer(opt, option));
    return _extends({}, otherHandlers, {
      "aria-disabled": optionState.disabled || void 0,
      "aria-selected": optionState.selected,
      tabIndex: getOptionTabIndex(optionState),
      id: optionIdGenerator(option, index),
      onClick: createHandleOptionClick(option, otherHandlers),
      onMouseOver: createHandleOptionMouseOver(option, otherHandlers),
      role: "option"
    });
  };
  React17.useDebugValue({
    highlightedOption: options[highlightedIndex],
    selectedOption: selectedValue
  });
  return {
    getRootProps,
    getOptionProps,
    getOptionState,
    highlightedOption: (_options$highlightedI = options[highlightedIndex]) != null ? _options$highlightedI : null,
    selectedOption: selectedValue,
    setSelectedValue,
    setHighlightedValue
  };
}
var React17, TEXT_NAVIGATION_RESET_TIMEOUT, defaultOptionComparer, defaultIsOptionDisabled, defaultOptionStringifier;
var init_useListbox = __esm({
  "node_modules/@mui/base/ListboxUnstyled/useListbox.js"() {
    init_extends();
    React17 = __toESM(require_react());
    init_esm();
    init_useListbox_types();
    init_defaultListboxReducer();
    init_useControllableReducer();
    init_areArraysEqual();
    TEXT_NAVIGATION_RESET_TIMEOUT = 500;
    defaultOptionComparer = (optionA, optionB) => optionA === optionB;
    defaultIsOptionDisabled = () => false;
    defaultOptionStringifier = (option) => typeof option === "string" ? option : String(option);
  }
});

// node_modules/@mui/base/ListboxUnstyled/index.js
var init_ListboxUnstyled = __esm({
  "node_modules/@mui/base/ListboxUnstyled/index.js"() {
    init_useListbox();
    init_defaultListboxReducer();
    init_useListbox_types();
  }
});

// node_modules/@mui/base/MenuUnstyled/MenuUnstyledContext.js
var React18, MenuUnstyledContext, MenuUnstyledContext_default;
var init_MenuUnstyledContext = __esm({
  "node_modules/@mui/base/MenuUnstyled/MenuUnstyledContext.js"() {
    React18 = __toESM(require_react());
    MenuUnstyledContext = React18.createContext(null);
    MenuUnstyledContext.displayName = "MenuUnstyledContext";
    MenuUnstyledContext_default = MenuUnstyledContext;
  }
});

// node_modules/@mui/base/MenuUnstyled/menuUnstyledClasses.js
function getMenuUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiMenuUnstyled", slot);
}
var menuUnstyledClasses;
var init_menuUnstyledClasses = __esm({
  "node_modules/@mui/base/MenuUnstyled/menuUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    menuUnstyledClasses = generateUtilityClasses("MuiMenuUnstyled", ["root", "listbox", "expanded"]);
  }
});

// node_modules/@mui/base/MenuUnstyled/useMenu.js
function stateReducer(state, action) {
  if (action.type === ActionTypes.blur || action.type === ActionTypes.optionHover || action.type === ActionTypes.setValue) {
    return state;
  }
  const newState = defaultListboxReducer(state, action);
  if (action.type !== ActionTypes.setHighlight && newState.highlightedValue === null && action.props.options.length > 0) {
    return _extends({}, newState, {
      highlightedValue: action.props.options[0]
    });
  }
  return newState;
}
function useMenu(parameters = {}) {
  const {
    listboxRef: listboxRefProp,
    open = false,
    onClose,
    listboxId
  } = parameters;
  const [menuItems, setMenuItems] = React19.useState({});
  const listboxRef = React19.useRef(null);
  const handleRef = useForkRef(listboxRef, listboxRefProp);
  const registerItem = React19.useCallback((id, metadata) => {
    setMenuItems((previousState) => {
      const newState = _extends({}, previousState);
      newState[id] = metadata;
      return newState;
    });
  }, []);
  const unregisterItem = React19.useCallback((id) => {
    setMenuItems((previousState) => {
      const newState = _extends({}, previousState);
      delete newState[id];
      return newState;
    });
  }, []);
  const {
    getOptionState,
    getOptionProps,
    getRootProps,
    highlightedOption,
    setHighlightedValue: setListboxHighlight
  } = useListbox({
    options: Object.keys(menuItems),
    optionStringifier: (id) => {
      var _menuItems$id$ref$cur;
      return menuItems[id].label || ((_menuItems$id$ref$cur = menuItems[id].ref.current) == null ? void 0 : _menuItems$id$ref$cur.innerText);
    },
    isOptionDisabled: (id) => {
      var _menuItems$id;
      return (menuItems == null ? void 0 : (_menuItems$id = menuItems[id]) == null ? void 0 : _menuItems$id.disabled) || false;
    },
    listboxRef: handleRef,
    focusManagement: "DOM",
    id: listboxId,
    stateReducer,
    disabledItemsFocusable: true
  });
  const highlightFirstItem = React19.useCallback(() => {
    if (Object.keys(menuItems).length > 0) {
      setListboxHighlight(menuItems[Object.keys(menuItems)[0]].id);
    }
  }, [menuItems, setListboxHighlight]);
  const highlightLastItem = React19.useCallback(() => {
    if (Object.keys(menuItems).length > 0) {
      setListboxHighlight(menuItems[Object.keys(menuItems)[Object.keys(menuItems).length - 1]].id);
    }
  }, [menuItems, setListboxHighlight]);
  React19.useEffect(() => {
    if (!open) {
      highlightFirstItem();
    }
  }, [open, highlightFirstItem]);
  const createHandleKeyDown = (otherHandlers) => (e) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, e);
    if (e.defaultPrevented) {
      return;
    }
    if (e.key === "Escape" && open) {
      onClose == null ? void 0 : onClose();
    }
  };
  const createHandleBlur = (otherHandlers) => (e) => {
    var _otherHandlers$onBlur, _listboxRef$current;
    (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, e);
    if (!((_listboxRef$current = listboxRef.current) != null && _listboxRef$current.contains(e.relatedTarget))) {
      onClose == null ? void 0 : onClose();
    }
  };
  React19.useEffect(() => {
    var _listboxRef$current2;
    if ((_listboxRef$current2 = listboxRef.current) != null && _listboxRef$current2.contains(document.activeElement) && highlightedOption !== null) {
      var _menuItems$highlighte, _menuItems$highlighte2;
      menuItems == null ? void 0 : (_menuItems$highlighte = menuItems[highlightedOption]) == null ? void 0 : (_menuItems$highlighte2 = _menuItems$highlighte.ref.current) == null ? void 0 : _menuItems$highlighte2.focus();
    }
  }, [highlightedOption, menuItems]);
  const getListboxProps = (otherHandlers = {}) => {
    const rootProps = getRootProps(_extends({}, otherHandlers, {
      onBlur: createHandleBlur(otherHandlers),
      onKeyDown: createHandleKeyDown(otherHandlers)
    }));
    return _extends({}, otherHandlers, rootProps, {
      role: "menu"
    });
  };
  const getItemState = (id) => {
    const {
      disabled,
      highlighted
    } = getOptionState(id);
    return {
      disabled,
      highlighted
    };
  };
  React19.useDebugValue({
    menuItems,
    highlightedOption
  });
  return {
    registerItem,
    unregisterItem,
    menuItems,
    getListboxProps,
    getItemState,
    getItemProps: getOptionProps,
    highlightedOption,
    highlightFirstItem,
    highlightLastItem
  };
}
var React19;
var init_useMenu = __esm({
  "node_modules/@mui/base/MenuUnstyled/useMenu.js"() {
    init_extends();
    React19 = __toESM(require_react());
    init_esm();
    init_ListboxUnstyled();
  }
});

// node_modules/@mui/base/PopperUnstyled/popperUnstyledClasses.js
function getPopperUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiPopperUnstyled", slot);
}
var popperUnstyledClasses;
var init_popperUnstyledClasses = __esm({
  "node_modules/@mui/base/PopperUnstyled/popperUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    popperUnstyledClasses = generateUtilityClasses("MuiPopperUnstyled", ["root"]);
  }
});

// node_modules/@mui/base/PopperUnstyled/PopperUnstyled.js
function flipPlacement(placement, direction) {
  if (direction === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
var React20, import_prop_types11, import_jsx_runtime16, _excluded9, _excluded22, useUtilityClasses5, defaultPopperOptions, PopperTooltip, PopperUnstyled, PopperUnstyled_default;
var init_PopperUnstyled = __esm({
  "node_modules/@mui/base/PopperUnstyled/PopperUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React20 = __toESM(require_react());
    init_esm();
    init_lib();
    import_prop_types11 = __toESM(require_prop_types());
    init_composeClasses();
    init_Portal2();
    init_popperUnstyledClasses();
    init_utils();
    import_jsx_runtime16 = __toESM(require_jsx_runtime());
    _excluded9 = ["anchorEl", "children", "component", "components", "componentsProps", "direction", "disablePortal", "modifiers", "open", "ownerState", "placement", "popperOptions", "popperRef", "TransitionProps"];
    _excluded22 = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition"];
    useUtilityClasses5 = () => {
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getPopperUnstyledUtilityClass, {});
    };
    defaultPopperOptions = {};
    PopperTooltip = React20.forwardRef(function PopperTooltip2(props, ref) {
      var _ref;
      const {
        anchorEl,
        children,
        component,
        components = {},
        componentsProps = {},
        direction,
        disablePortal,
        modifiers,
        open,
        ownerState,
        placement: initialPlacement,
        popperOptions,
        popperRef: popperRefProp,
        TransitionProps
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
      const tooltipRef = React20.useRef(null);
      const ownRef = useForkRef(tooltipRef, ref);
      const popperRef = React20.useRef(null);
      const handlePopperRef = useForkRef(popperRef, popperRefProp);
      const handlePopperRefRef = React20.useRef(handlePopperRef);
      useEnhancedEffect_default(() => {
        handlePopperRefRef.current = handlePopperRef;
      }, [handlePopperRef]);
      React20.useImperativeHandle(popperRefProp, () => popperRef.current, []);
      const rtlPlacement = flipPlacement(initialPlacement, direction);
      const [placement, setPlacement] = React20.useState(rtlPlacement);
      React20.useEffect(() => {
        if (popperRef.current) {
          popperRef.current.forceUpdate();
        }
      });
      useEnhancedEffect_default(() => {
        if (!anchorEl || !open) {
          return void 0;
        }
        const handlePopperUpdate = (data) => {
          setPlacement(data.placement);
        };
        const resolvedAnchorEl = resolveAnchorEl(anchorEl);
        if (true) {
          if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
            const box = resolvedAnchorEl.getBoundingClientRect();
            if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
              console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join("\n"));
            }
          }
        }
        let popperModifiers = [{
          name: "preventOverflow",
          options: {
            altBoundary: disablePortal
          }
        }, {
          name: "flip",
          options: {
            altBoundary: disablePortal
          }
        }, {
          name: "onUpdate",
          enabled: true,
          phase: "afterWrite",
          fn: ({
            state
          }) => {
            handlePopperUpdate(state);
          }
        }];
        if (modifiers != null) {
          popperModifiers = popperModifiers.concat(modifiers);
        }
        if (popperOptions && popperOptions.modifiers != null) {
          popperModifiers = popperModifiers.concat(popperOptions.modifiers);
        }
        const popper = createPopper(resolveAnchorEl(anchorEl), tooltipRef.current, _extends({
          placement: rtlPlacement
        }, popperOptions, {
          modifiers: popperModifiers
        }));
        handlePopperRefRef.current(popper);
        return () => {
          popper.destroy();
          handlePopperRefRef.current(null);
        };
      }, [anchorEl, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
      const childProps = {
        placement
      };
      if (TransitionProps !== null) {
        childProps.TransitionProps = TransitionProps;
      }
      const classes = useUtilityClasses5();
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          role: "tooltip",
          ref: ownRef
        },
        ownerState: _extends({}, props, ownerState),
        className: classes.root
      });
      return (0, import_jsx_runtime16.jsx)(Root, _extends({}, rootProps, {
        children: typeof children === "function" ? children(childProps) : children
      }));
    });
    PopperUnstyled = React20.forwardRef(function PopperUnstyled2(props, ref) {
      const {
        anchorEl,
        children,
        container: containerProp,
        direction = "ltr",
        disablePortal = false,
        keepMounted = false,
        modifiers,
        open,
        placement = "bottom",
        popperOptions = defaultPopperOptions,
        popperRef,
        style,
        transition = false
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded22);
      const [exited, setExited] = React20.useState(true);
      const handleEnter = () => {
        setExited(false);
      };
      const handleExited = () => {
        setExited(true);
      };
      if (!keepMounted && !open && (!transition || exited)) {
        return null;
      }
      const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
      return (0, import_jsx_runtime16.jsx)(Portal_default, {
        disablePortal,
        container,
        children: (0, import_jsx_runtime16.jsx)(PopperTooltip, _extends({
          anchorEl,
          direction,
          disablePortal,
          modifiers,
          ref,
          open: transition ? !exited : open,
          placement,
          popperOptions,
          popperRef
        }, other, {
          style: _extends({
            position: "fixed",
            top: 0,
            left: 0,
            display: !open && keepMounted && (!transition || exited) ? "none" : null
          }, style),
          TransitionProps: transition ? {
            in: open,
            onEnter: handleEnter,
            onExited: handleExited
          } : null,
          children
        }))
      });
    });
    true ? PopperUnstyled.propTypes = {
      anchorEl: chainPropTypes(import_prop_types11.default.oneOfType([HTMLElementType, import_prop_types11.default.object, import_prop_types11.default.func]), (props) => {
        if (props.open) {
          const resolvedAnchorEl = resolveAnchorEl(props.anchorEl);
          if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
            const box = resolvedAnchorEl.getBoundingClientRect();
            if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
              return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join("\n"));
            }
          } else if (!resolvedAnchorEl || typeof resolvedAnchorEl.getBoundingClientRect !== "function" || resolvedAnchorEl.contextElement != null && resolvedAnchorEl.contextElement.nodeType !== 1) {
            return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join("\n"));
          }
        }
        return null;
      }),
      children: import_prop_types11.default.oneOfType([import_prop_types11.default.node, import_prop_types11.default.func]),
      components: import_prop_types11.default.shape({
        Root: import_prop_types11.default.elementType
      }),
      componentsProps: import_prop_types11.default.shape({
        root: import_prop_types11.default.oneOfType([import_prop_types11.default.func, import_prop_types11.default.object])
      }),
      container: import_prop_types11.default.oneOfType([HTMLElementType, import_prop_types11.default.func]),
      direction: import_prop_types11.default.oneOf(["ltr", "rtl"]),
      disablePortal: import_prop_types11.default.bool,
      keepMounted: import_prop_types11.default.bool,
      modifiers: import_prop_types11.default.arrayOf(import_prop_types11.default.shape({
        data: import_prop_types11.default.object,
        effect: import_prop_types11.default.func,
        enabled: import_prop_types11.default.bool,
        fn: import_prop_types11.default.func,
        name: import_prop_types11.default.any,
        options: import_prop_types11.default.object,
        phase: import_prop_types11.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
        requires: import_prop_types11.default.arrayOf(import_prop_types11.default.string),
        requiresIfExists: import_prop_types11.default.arrayOf(import_prop_types11.default.string)
      })),
      open: import_prop_types11.default.bool.isRequired,
      placement: import_prop_types11.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
      popperOptions: import_prop_types11.default.shape({
        modifiers: import_prop_types11.default.array,
        onFirstUpdate: import_prop_types11.default.func,
        placement: import_prop_types11.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
        strategy: import_prop_types11.default.oneOf(["absolute", "fixed"])
      }),
      popperRef: refType_default,
      style: import_prop_types11.default.object,
      transition: import_prop_types11.default.bool
    } : void 0;
    PopperUnstyled_default = PopperUnstyled;
  }
});

// node_modules/@mui/base/PopperUnstyled/index.js
var init_PopperUnstyled2 = __esm({
  "node_modules/@mui/base/PopperUnstyled/index.js"() {
    init_PopperUnstyled();
  }
});

// node_modules/@mui/base/MenuUnstyled/MenuUnstyled.js
function getUtilityClasses(ownerState) {
  const {
    open
  } = ownerState;
  const slots = {
    root: ["root", open && "expanded"],
    listbox: ["listbox", open && "expanded"]
  };
  return composeClasses(slots, getMenuUnstyledUtilityClass, {});
}
var React21, import_prop_types12, import_jsx_runtime17, _excluded10, MenuUnstyled;
var init_MenuUnstyled = __esm({
  "node_modules/@mui/base/MenuUnstyled/MenuUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React21 = __toESM(require_react());
    import_prop_types12 = __toESM(require_prop_types());
    init_esm();
    init_MenuUnstyledContext();
    init_menuUnstyledClasses();
    init_useMenu();
    init_composeClasses();
    init_PopperUnstyled2();
    init_useSlotProps();
    import_jsx_runtime17 = __toESM(require_jsx_runtime());
    _excluded10 = ["actions", "anchorEl", "children", "component", "components", "componentsProps", "keepMounted", "listboxId", "onClose", "open"];
    MenuUnstyled = React21.forwardRef(function MenuUnstyled2(props, forwardedRef) {
      var _ref, _components$Listbox;
      const {
        actions,
        anchorEl,
        children,
        component,
        components = {},
        componentsProps = {},
        keepMounted = false,
        listboxId,
        onClose,
        open = false
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded10);
      const {
        registerItem,
        unregisterItem,
        getListboxProps,
        getItemProps,
        getItemState,
        highlightFirstItem,
        highlightLastItem
      } = useMenu({
        open,
        onClose,
        listboxId
      });
      React21.useImperativeHandle(actions, () => ({
        highlightFirstItem,
        highlightLastItem
      }), [highlightFirstItem, highlightLastItem]);
      const ownerState = _extends({}, props, {
        open
      });
      const classes = getUtilityClasses(ownerState);
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : PopperUnstyled_default;
      const rootProps = useSlotProps({
        elementType: Root,
        externalForwardedProps: other,
        externalSlotProps: componentsProps.root,
        additionalProps: {
          anchorEl,
          open,
          keepMounted,
          role: void 0,
          ref: forwardedRef
        },
        className: classes.root,
        ownerState
      });
      const Listbox = (_components$Listbox = components.Listbox) != null ? _components$Listbox : "ul";
      const listboxProps = useSlotProps({
        elementType: Listbox,
        getSlotProps: getListboxProps,
        externalSlotProps: componentsProps.listbox,
        ownerState,
        className: classes.listbox
      });
      const contextValue = {
        registerItem,
        unregisterItem,
        getItemState,
        getItemProps,
        open
      };
      return (0, import_jsx_runtime17.jsx)(Root, _extends({}, rootProps, {
        children: (0, import_jsx_runtime17.jsx)(Listbox, _extends({}, listboxProps, {
          children: (0, import_jsx_runtime17.jsx)(MenuUnstyledContext_default.Provider, {
            value: contextValue,
            children
          })
        }))
      }));
    });
    true ? MenuUnstyled.propTypes = {
      actions: refType_default,
      anchorEl: import_prop_types12.default.oneOfType([HTMLElementType, import_prop_types12.default.object, import_prop_types12.default.func]),
      children: import_prop_types12.default.node,
      component: import_prop_types12.default.elementType,
      components: import_prop_types12.default.shape({
        Listbox: import_prop_types12.default.elementType,
        Root: import_prop_types12.default.elementType
      }),
      componentsProps: import_prop_types12.default.shape({
        listbox: import_prop_types12.default.oneOfType([import_prop_types12.default.func, import_prop_types12.default.object]),
        root: import_prop_types12.default.oneOfType([import_prop_types12.default.func, import_prop_types12.default.object])
      }),
      keepMounted: import_prop_types12.default.bool,
      listboxId: import_prop_types12.default.string,
      onClose: import_prop_types12.default.func,
      open: import_prop_types12.default.bool
    } : void 0;
  }
});

// node_modules/@mui/base/MenuUnstyled/MenuUnstyled.types.js
var init_MenuUnstyled_types = __esm({
  "node_modules/@mui/base/MenuUnstyled/MenuUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/MenuUnstyled/useMenu.types.js
var init_useMenu_types = __esm({
  "node_modules/@mui/base/MenuUnstyled/useMenu.types.js"() {
  }
});

// node_modules/@mui/base/MenuUnstyled/index.js
var init_MenuUnstyled2 = __esm({
  "node_modules/@mui/base/MenuUnstyled/index.js"() {
    init_MenuUnstyled();
    init_MenuUnstyledContext();
    init_MenuUnstyledContext();
    init_menuUnstyledClasses();
    init_menuUnstyledClasses();
    init_MenuUnstyled_types();
    init_useMenu();
    init_useMenu_types();
  }
});

// node_modules/@mui/base/MenuItemUnstyled/menuItemUnstyledClasses.js
function getMenuItemUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiMenuItemUnstyled", slot);
}
var menuItemUnstyledClasses;
var init_menuItemUnstyledClasses = __esm({
  "node_modules/@mui/base/MenuItemUnstyled/menuItemUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    menuItemUnstyledClasses = generateUtilityClasses("MuiMenuItemUnstyled", ["root", "disabled", "focusVisible"]);
  }
});

// node_modules/@mui/base/MenuItemUnstyled/useMenuItem.js
function useMenuItem(props) {
  var _itemState$disabled;
  const {
    disabled = false,
    ref,
    label
  } = props;
  const id = useId();
  const menuContext = React22.useContext(MenuUnstyledContext_default);
  const itemRef = React22.useRef(null);
  const handleRef = useForkRef(itemRef, ref);
  if (menuContext === null) {
    throw new Error("MenuItemUnstyled must be used within a MenuUnstyled");
  }
  const {
    registerItem,
    unregisterItem,
    open
  } = menuContext;
  React22.useEffect(() => {
    if (id === void 0) {
      return void 0;
    }
    registerItem(id, {
      disabled,
      id,
      ref: itemRef,
      label
    });
    return () => unregisterItem(id);
  }, [id, registerItem, unregisterItem, disabled, ref, label]);
  const {
    getRootProps: getButtonProps,
    focusVisible
  } = useButton({
    disabled,
    focusableWhenDisabled: true,
    ref: handleRef
  });
  const [focusRequested, requestFocus] = React22.useState(false);
  const focusIfRequested = React22.useCallback(() => {
    if (focusRequested && itemRef.current != null) {
      itemRef.current.focus();
      requestFocus(false);
    }
  }, [focusRequested]);
  React22.useEffect(() => {
    focusIfRequested();
  });
  React22.useDebugValue({
    id,
    disabled,
    label
  });
  const itemState = menuContext.getItemState(id != null ? id : "");
  const {
    highlighted
  } = itemState != null ? itemState : {
    highlighted: false
  };
  React22.useEffect(() => {
    requestFocus(highlighted && open);
  }, [highlighted, open]);
  if (id === void 0) {
    return {
      getRootProps: (other) => _extends({}, other, getButtonProps(other), {
        role: "menuitem"
      }),
      disabled: false,
      focusVisible
    };
  }
  return {
    getRootProps: (other) => {
      const optionProps = menuContext.getItemProps(id, other);
      return _extends({}, other, getButtonProps(other), {
        tabIndex: optionProps.tabIndex,
        id: optionProps.id,
        role: "menuitem"
      });
    },
    disabled: (_itemState$disabled = itemState == null ? void 0 : itemState.disabled) != null ? _itemState$disabled : false,
    focusVisible
  };
}
var React22;
var init_useMenuItem = __esm({
  "node_modules/@mui/base/MenuItemUnstyled/useMenuItem.js"() {
    init_extends();
    React22 = __toESM(require_react());
    init_esm();
    init_MenuUnstyled2();
    init_ButtonUnstyled2();
  }
});

// node_modules/@mui/base/MenuItemUnstyled/MenuItemUnstyled.js
function getUtilityClasses2(ownerState) {
  const {
    disabled,
    focusVisible
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  return composeClasses(slots, getMenuItemUnstyledUtilityClass, {});
}
var React23, import_prop_types13, import_jsx_runtime18, _excluded11, MenuItemUnstyled;
var init_MenuItemUnstyled = __esm({
  "node_modules/@mui/base/MenuItemUnstyled/MenuItemUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React23 = __toESM(require_react());
    import_prop_types13 = __toESM(require_prop_types());
    init_menuItemUnstyledClasses();
    init_useMenuItem();
    init_composeClasses();
    init_useSlotProps();
    import_jsx_runtime18 = __toESM(require_jsx_runtime());
    _excluded11 = ["children", "disabled", "component", "components", "componentsProps", "label"];
    MenuItemUnstyled = React23.forwardRef(function MenuItemUnstyled2(props, ref) {
      var _ref;
      const {
        children,
        disabled: disabledProp = false,
        component,
        components = {},
        componentsProps = {},
        label
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded11);
      const {
        getRootProps,
        disabled,
        focusVisible
      } = useMenuItem({
        disabled: disabledProp,
        ref,
        label
      });
      const ownerState = _extends({}, props, {
        disabled,
        focusVisible
      });
      const classes = getUtilityClasses2(ownerState);
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "li";
      const rootProps = useSlotProps({
        elementType: Root,
        getSlotProps: getRootProps,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        className: classes.root,
        ownerState
      });
      return (0, import_jsx_runtime18.jsx)(Root, _extends({}, rootProps, {
        children
      }));
    });
    true ? MenuItemUnstyled.propTypes = {
      children: import_prop_types13.default.node,
      component: import_prop_types13.default.elementType,
      components: import_prop_types13.default.shape({
        Root: import_prop_types13.default.elementType
      }),
      componentsProps: import_prop_types13.default.shape({
        root: import_prop_types13.default.oneOfType([import_prop_types13.default.func, import_prop_types13.default.object])
      }),
      disabled: import_prop_types13.default.bool,
      label: import_prop_types13.default.string
    } : void 0;
  }
});

// node_modules/@mui/base/MenuItemUnstyled/MenuItemUnstyled.types.js
var init_MenuItemUnstyled_types = __esm({
  "node_modules/@mui/base/MenuItemUnstyled/MenuItemUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/MenuItemUnstyled/useMenuItem.types.js
var init_useMenuItem_types = __esm({
  "node_modules/@mui/base/MenuItemUnstyled/useMenuItem.types.js"() {
  }
});

// node_modules/@mui/base/MenuItemUnstyled/index.js
var init_MenuItemUnstyled2 = __esm({
  "node_modules/@mui/base/MenuItemUnstyled/index.js"() {
    init_MenuItemUnstyled();
    init_MenuItemUnstyled_types();
    init_menuItemUnstyledClasses();
    init_menuItemUnstyledClasses();
    init_useMenuItem();
    init_useMenuItem_types();
  }
});

// node_modules/@mui/base/SelectUnstyled/useSelect.types.js
function isOptionGroup(child) {
  return !!child.options;
}
var init_useSelect_types = __esm({
  "node_modules/@mui/base/SelectUnstyled/useSelect.types.js"() {
  }
});

// node_modules/@mui/base/SelectUnstyled/utils.js
function getOptionsFromChildren(children) {
  if (children == null) {
    return [];
  }
  const selectChildren = [];
  import_react.default.Children.forEach(children, (node) => {
    var _props, _props2, _element$props$disabl2;
    const nodeChildren = node == null ? void 0 : (_props = node.props) == null ? void 0 : _props.children;
    if ((node == null ? void 0 : (_props2 = node.props) == null ? void 0 : _props2.value) === void 0) {
      if (nodeChildren != null) {
        var _element$props$disabl;
        const element2 = node;
        const group = {
          options: getOptionsFromChildren(nodeChildren),
          label: element2.props.label,
          disabled: (_element$props$disabl = element2.props.disabled) != null ? _element$props$disabl : false
        };
        selectChildren.push(group);
      }
      return;
    }
    const element = node;
    const option = {
      value: element.props.value,
      label: element.props.label || element.props.children,
      disabled: (_element$props$disabl2 = element.props.disabled) != null ? _element$props$disabl2 : false
    };
    selectChildren.push(option);
  });
  return selectChildren != null ? selectChildren : [];
}
function flattenOptionGroups(groupedOptions, isGroupDisabled = false) {
  let flatOptions = [];
  groupedOptions.forEach((optionOrGroup) => {
    if (isOptionGroup(optionOrGroup)) {
      flatOptions = flatOptions.concat(flattenOptionGroups(optionOrGroup.options, optionOrGroup.disabled));
    } else {
      flatOptions.push(_extends({}, optionOrGroup, {
        disabled: isGroupDisabled || optionOrGroup.disabled
      }));
    }
  });
  return flatOptions;
}
var import_react;
var init_utils2 = __esm({
  "node_modules/@mui/base/SelectUnstyled/utils.js"() {
    init_extends();
    import_react = __toESM(require_react());
    init_useSelect_types();
  }
});

// node_modules/@mui/base/SelectUnstyled/defaultOptionStringifier.js
var defaultOptionStringifier2, defaultOptionStringifier_default;
var init_defaultOptionStringifier = __esm({
  "node_modules/@mui/base/SelectUnstyled/defaultOptionStringifier.js"() {
    defaultOptionStringifier2 = (option) => {
      const {
        label,
        value
      } = option;
      if (typeof label === "string") {
        return label;
      }
      if (typeof value === "string") {
        return value;
      }
      return String(option);
    };
    defaultOptionStringifier_default = defaultOptionStringifier2;
  }
});

// node_modules/@mui/base/SelectUnstyled/useSelect.js
function useSelect(props) {
  const {
    buttonRef: buttonRefProp,
    defaultValue,
    disabled = false,
    listboxId,
    listboxRef: listboxRefProp,
    multiple = false,
    onChange,
    onOpenChange,
    open = false,
    options,
    optionStringifier = defaultOptionStringifier_default,
    value: valueProp
  } = props;
  const buttonRef = React25.useRef(null);
  const handleButtonRef = useForkRef(buttonRefProp, buttonRef);
  const listboxRef = React25.useRef(null);
  const [value, setValue] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "SelectUnstyled",
    state: "value"
  });
  const ignoreEnterKeyUp = React25.useRef(false);
  const ignoreClick = React25.useRef(false);
  const [listboxFocusRequested, requestListboxFocus] = React25.useState(false);
  const focusListboxIfRequested = React25.useCallback(() => {
    if (listboxFocusRequested && listboxRef.current != null) {
      listboxRef.current.focus();
      requestListboxFocus(false);
    }
  }, [listboxFocusRequested]);
  const updateListboxRef = (listboxElement) => {
    listboxRef.current = listboxElement;
    focusListboxIfRequested();
  };
  const handleListboxRef = useForkRef(useForkRef(listboxRefProp, listboxRef), updateListboxRef);
  React25.useEffect(() => {
    focusListboxIfRequested();
  }, [focusListboxIfRequested]);
  React25.useEffect(() => {
    requestListboxFocus(open);
  }, [open]);
  const createHandleMouseDown = (otherHandlers) => (event) => {
    var _otherHandlers$onMous;
    otherHandlers == null ? void 0 : (_otherHandlers$onMous = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);
    if (!event.defaultPrevented && open) {
      ignoreClick.current = true;
    }
  };
  const createHandleButtonClick = (otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    otherHandlers == null ? void 0 : (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
    if (!event.defaultPrevented && !ignoreClick.current) {
      onOpenChange == null ? void 0 : onOpenChange(!open);
    }
    ignoreClick.current = false;
  };
  const createHandleButtonKeyDown = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    otherHandlers == null ? void 0 : (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    if (event.key === "Enter") {
      ignoreEnterKeyUp.current = true;
    }
    if (event.key === "ArrowDown" || event.key === "ArrowUp") {
      event.preventDefault();
      onOpenChange == null ? void 0 : onOpenChange(true);
    }
  };
  const createHandleListboxKeyUp = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyU;
    otherHandlers == null ? void 0 : (_otherHandlers$onKeyU = otherHandlers.onKeyUp) == null ? void 0 : _otherHandlers$onKeyU.call(otherHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    const closingKeys = multiple ? ["Escape"] : ["Escape", "Enter", " "];
    if (open && !ignoreEnterKeyUp.current && closingKeys.includes(event.key)) {
      var _buttonRef$current;
      buttonRef == null ? void 0 : (_buttonRef$current = buttonRef.current) == null ? void 0 : _buttonRef$current.focus();
    }
    ignoreEnterKeyUp.current = false;
  };
  const createHandleListboxItemClick = (otherHandlers) => (event) => {
    var _otherHandlers$onClic2;
    otherHandlers == null ? void 0 : (_otherHandlers$onClic2 = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic2.call(otherHandlers, event);
    if (event.defaultPrevented) {
      return;
    }
    if (!multiple) {
      onOpenChange == null ? void 0 : onOpenChange(false);
    }
  };
  const createHandleListboxBlur = (otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    otherHandlers == null ? void 0 : (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
    if (!event.defaultPrevented) {
      onOpenChange == null ? void 0 : onOpenChange(false);
    }
  };
  const listboxReducer = (state, action) => {
    const newState = defaultListboxReducer(state, action);
    if (action.type === ActionTypes.keyDown && !open && (action.event.key === "ArrowUp" || action.event.key === "ArrowDown")) {
      return _extends({}, newState, {
        selectedValue: newState.highlightedValue
      });
    }
    if (action.type === ActionTypes.blur || action.type === ActionTypes.setValue || action.type === ActionTypes.optionsChange) {
      return _extends({}, newState, {
        highlightedValue: newState.selectedValue
      });
    }
    return newState;
  };
  const {
    getRootProps: getButtonRootProps,
    active: buttonActive,
    focusVisible: buttonFocusVisible
  } = useButton({
    disabled,
    ref: handleButtonRef
  });
  const selectedOption = React25.useMemo(() => {
    var _props$options$find;
    return props.multiple ? props.options.filter((o) => value.includes(o.value)) : (_props$options$find = props.options.find((o) => o.value === value)) != null ? _props$options$find : null;
  }, [props.multiple, props.options, value]);
  let useListboxParameters;
  if (props.multiple) {
    useListboxParameters = {
      id: listboxId,
      isOptionDisabled: (o) => {
        var _o$disabled;
        return (_o$disabled = o == null ? void 0 : o.disabled) != null ? _o$disabled : false;
      },
      optionComparer: (o, v) => (o == null ? void 0 : o.value) === (v == null ? void 0 : v.value),
      listboxRef: handleListboxRef,
      multiple: true,
      onChange: (newOptions) => {
        const newValues = newOptions.map((o) => o.value);
        setValue(newValues);
        onChange == null ? void 0 : onChange(newValues);
      },
      options,
      optionStringifier,
      value: selectedOption
    };
  } else {
    useListboxParameters = {
      id: listboxId,
      isOptionDisabled: (o) => {
        var _o$disabled2;
        return (_o$disabled2 = o == null ? void 0 : o.disabled) != null ? _o$disabled2 : false;
      },
      optionComparer: (o, v) => (o == null ? void 0 : o.value) === (v == null ? void 0 : v.value),
      listboxRef: handleListboxRef,
      multiple: false,
      onChange: (option) => {
        var _option$value, _option$value2;
        setValue((_option$value = option == null ? void 0 : option.value) != null ? _option$value : null);
        onChange == null ? void 0 : onChange((_option$value2 = option == null ? void 0 : option.value) != null ? _option$value2 : null);
      },
      options,
      optionStringifier,
      stateReducer: listboxReducer,
      value: selectedOption
    };
  }
  const {
    getRootProps: getListboxRootProps,
    getOptionProps: getListboxOptionProps,
    getOptionState,
    highlightedOption,
    selectedOption: listboxSelectedOption
  } = useListbox(useListboxParameters);
  const getButtonProps = (otherHandlers = {}) => {
    return _extends({}, getButtonRootProps(_extends({}, otherHandlers, {
      onClick: createHandleButtonClick(otherHandlers),
      onMouseDown: createHandleMouseDown(otherHandlers),
      onKeyDown: createHandleButtonKeyDown(otherHandlers)
    })), {
      "aria-expanded": open,
      "aria-haspopup": "listbox"
    });
  };
  const getListboxProps = (otherHandlers = {}) => getListboxRootProps(_extends({}, otherHandlers, {
    onBlur: createHandleListboxBlur(otherHandlers),
    onKeyUp: createHandleListboxKeyUp(otherHandlers)
  }));
  const getOptionProps = (option, otherHandlers = {}) => {
    return getListboxOptionProps(option, _extends({}, otherHandlers, {
      onClick: createHandleListboxItemClick(otherHandlers)
    }));
  };
  React25.useDebugValue({
    selectedOption: listboxSelectedOption,
    highlightedOption,
    open
  });
  return {
    buttonActive,
    buttonFocusVisible,
    disabled,
    getButtonProps,
    getListboxProps,
    getOptionProps,
    getOptionState,
    open,
    value
  };
}
var React25, useSelect_default;
var init_useSelect = __esm({
  "node_modules/@mui/base/SelectUnstyled/useSelect.js"() {
    init_extends();
    React25 = __toESM(require_react());
    init_esm();
    init_ButtonUnstyled2();
    init_ListboxUnstyled();
    init_defaultOptionStringifier();
    useSelect_default = useSelect;
  }
});

// node_modules/@mui/base/SelectUnstyled/SelectUnstyledContext.js
var React26, SelectUnstyledContext;
var init_SelectUnstyledContext = __esm({
  "node_modules/@mui/base/SelectUnstyled/SelectUnstyledContext.js"() {
    React26 = __toESM(require_react());
    SelectUnstyledContext = React26.createContext(void 0);
  }
});

// node_modules/@mui/base/SelectUnstyled/selectUnstyledClasses.js
function getSelectUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiSelectUnstyled", slot);
}
var selectUnstyledClasses;
var init_selectUnstyledClasses = __esm({
  "node_modules/@mui/base/SelectUnstyled/selectUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    selectUnstyledClasses = generateUtilityClasses("MuiSelectUnstyled", ["root", "button", "listbox", "popper", "active", "expanded", "disabled", "focusVisible"]);
  }
});

// node_modules/@mui/base/MultiSelectUnstyled/MultiSelectUnstyled.js
function defaultRenderMultipleValues(selectedOptions) {
  return (0, import_jsx_runtime19.jsx)(React27.Fragment, {
    children: selectedOptions.map((o) => o.label).join(", ")
  });
}
function defaultFormValueProvider(selectedOptions) {
  if (selectedOptions.length === 0) {
    return "";
  }
  if (selectedOptions.every((o) => typeof o.value === "string" || typeof o.value === "number" || typeof o.value === "boolean")) {
    return selectedOptions.map((o) => String(o.value));
  }
  return JSON.stringify(selectedOptions.map((o) => o.value));
}
function useUtilityClasses6(ownerState) {
  const {
    active,
    disabled,
    open,
    focusVisible
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible", active && "active", open && "expanded"],
    listbox: ["listbox", disabled && "disabled"],
    popper: ["popper"]
  };
  return composeClasses(slots, getSelectUnstyledUtilityClass, {});
}
var React27, import_prop_types14, import_jsx_runtime19, import_jsx_runtime20, _excluded12, MultiSelectUnstyled;
var init_MultiSelectUnstyled = __esm({
  "node_modules/@mui/base/MultiSelectUnstyled/MultiSelectUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React27 = __toESM(require_react());
    import_prop_types14 = __toESM(require_prop_types());
    init_esm();
    init_utils2();
    init_useSelect();
    init_utils();
    init_PopperUnstyled2();
    init_SelectUnstyledContext();
    init_composeClasses();
    init_selectUnstyledClasses();
    init_defaultOptionStringifier();
    import_jsx_runtime19 = __toESM(require_jsx_runtime());
    import_jsx_runtime20 = __toESM(require_jsx_runtime());
    _excluded12 = ["autoFocus", "children", "component", "components", "componentsProps", "defaultListboxOpen", "defaultValue", "disabled", "getSerializedValue", "listboxId", "listboxOpen", "name", "onChange", "onListboxOpenChange", "optionStringifier", "value"];
    MultiSelectUnstyled = React27.forwardRef(function MultiSelectUnstyled2(props, forwardedRef) {
      var _props$renderValue, _ref, _components$Listbox, _components$Popper;
      const {
        autoFocus,
        children,
        component,
        components = {},
        componentsProps = {},
        defaultListboxOpen = false,
        defaultValue = [],
        disabled: disabledProp,
        getSerializedValue = defaultFormValueProvider,
        listboxId,
        listboxOpen: listboxOpenProp,
        name,
        onChange,
        onListboxOpenChange,
        optionStringifier = defaultOptionStringifier_default,
        value: valueProp
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded12);
      const renderValue = (_props$renderValue = props.renderValue) != null ? _props$renderValue : defaultRenderMultipleValues;
      const [groupedOptions, setGroupedOptions] = React27.useState([]);
      const options = React27.useMemo(() => flattenOptionGroups(groupedOptions), [groupedOptions]);
      const [listboxOpen, setListboxOpen] = useControlled({
        controlled: listboxOpenProp,
        default: defaultListboxOpen,
        name: "MultiSelectUnstyled",
        state: "listboxOpen"
      });
      React27.useEffect(() => {
        setGroupedOptions(getOptionsFromChildren(children));
      }, [children]);
      const [buttonDefined, setButtonDefined] = React27.useState(false);
      const buttonRef = React27.useRef(null);
      const listboxRef = React27.useRef(null);
      const Button = (_ref = component != null ? component : components.Root) != null ? _ref : "button";
      const ListboxRoot = (_components$Listbox = components.Listbox) != null ? _components$Listbox : "ul";
      const Popper = (_components$Popper = components.Popper) != null ? _components$Popper : PopperUnstyled_default;
      const handleButtonRefChange = React27.useCallback((element) => {
        setButtonDefined(element != null);
      }, []);
      const handleButtonRef = useForkRef(forwardedRef, useForkRef(buttonRef, handleButtonRefChange));
      React27.useEffect(() => {
        if (autoFocus) {
          buttonRef.current.focus();
        }
      }, [autoFocus]);
      const handleOpenChange = (isOpen) => {
        setListboxOpen(isOpen);
        onListboxOpenChange == null ? void 0 : onListboxOpenChange(isOpen);
      };
      const {
        buttonActive,
        buttonFocusVisible,
        disabled,
        getButtonProps,
        getListboxProps,
        getOptionProps,
        getOptionState,
        value
      } = useSelect_default({
        buttonRef: handleButtonRef,
        defaultValue,
        disabled: disabledProp,
        listboxId,
        multiple: true,
        onChange,
        onOpenChange: handleOpenChange,
        open: listboxOpen,
        options,
        optionStringifier,
        value: valueProp
      });
      const ownerState = _extends({}, props, {
        active: buttonActive,
        defaultListboxOpen,
        disabled,
        focusVisible: buttonFocusVisible,
        open: listboxOpen,
        renderValue,
        value
      });
      const classes = useUtilityClasses6(ownerState);
      const selectedOptions = React27.useMemo(() => {
        if (value == null) {
          return [];
        }
        return options.filter((o) => value.includes(o.value));
      }, [options, value]);
      const buttonProps = useSlotProps({
        elementType: Button,
        getSlotProps: getButtonProps,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        ownerState,
        className: classes.root
      });
      const listboxProps = useSlotProps({
        elementType: ListboxRoot,
        getSlotProps: getListboxProps,
        externalSlotProps: componentsProps.listbox,
        additionalProps: {
          ref: listboxRef
        },
        ownerState,
        className: classes.listbox
      });
      const popperProps = useSlotProps({
        elementType: Popper,
        externalSlotProps: componentsProps.popper,
        additionalProps: {
          anchorEl: buttonRef.current,
          disablePortal: true,
          open: listboxOpen,
          placement: "bottom-start",
          role: void 0
        },
        ownerState,
        className: classes.popper
      });
      const context = {
        getOptionProps,
        getOptionState,
        listboxRef
      };
      return (0, import_jsx_runtime20.jsxs)(React27.Fragment, {
        children: [(0, import_jsx_runtime19.jsx)(Button, _extends({}, buttonProps, {
          children: renderValue(selectedOptions)
        })), buttonDefined && (0, import_jsx_runtime19.jsx)(Popper, _extends({}, popperProps, {
          children: (0, import_jsx_runtime19.jsx)(ListboxRoot, _extends({}, listboxProps, {
            children: (0, import_jsx_runtime19.jsx)(SelectUnstyledContext.Provider, {
              value: context,
              children
            })
          }))
        })), name && (0, import_jsx_runtime19.jsx)("input", {
          type: "hidden",
          name,
          value: getSerializedValue(selectedOptions)
        })]
      });
    });
    true ? MultiSelectUnstyled.propTypes = {
      autoFocus: import_prop_types14.default.bool,
      children: import_prop_types14.default.node,
      component: import_prop_types14.default.elementType,
      components: import_prop_types14.default.shape({
        Listbox: import_prop_types14.default.elementType,
        Popper: import_prop_types14.default.elementType,
        Root: import_prop_types14.default.elementType
      }),
      componentsProps: import_prop_types14.default.shape({
        listbox: import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object]),
        popper: import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object]),
        root: import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object])
      }),
      defaultListboxOpen: import_prop_types14.default.bool,
      defaultValue: import_prop_types14.default.array,
      disabled: import_prop_types14.default.bool,
      getSerializedValue: import_prop_types14.default.func,
      listboxId: import_prop_types14.default.string,
      listboxOpen: import_prop_types14.default.bool,
      name: import_prop_types14.default.string,
      onChange: import_prop_types14.default.func,
      onListboxOpenChange: import_prop_types14.default.func,
      optionStringifier: import_prop_types14.default.func,
      renderValue: import_prop_types14.default.func,
      value: import_prop_types14.default.array
    } : void 0;
  }
});

// node_modules/@mui/base/MultiSelectUnstyled/MultiSelectUnstyled.types.js
var init_MultiSelectUnstyled_types = __esm({
  "node_modules/@mui/base/MultiSelectUnstyled/MultiSelectUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/MultiSelectUnstyled/index.js
var init_MultiSelectUnstyled2 = __esm({
  "node_modules/@mui/base/MultiSelectUnstyled/index.js"() {
    init_MultiSelectUnstyled();
    init_MultiSelectUnstyled_types();
  }
});

// node_modules/@mui/base/OptionGroupUnstyled/optionGroupUnstyledClasses.js
function getOptionGroupUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiOptionGroupUnstyled", slot);
}
var optionGroupUnstyledClasses;
var init_optionGroupUnstyledClasses = __esm({
  "node_modules/@mui/base/OptionGroupUnstyled/optionGroupUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    optionGroupUnstyledClasses = generateUtilityClasses("MuiOptionGroupUnstyled", ["root", "label", "list"]);
  }
});

// node_modules/@mui/base/OptionGroupUnstyled/OptionGroupUnstyled.js
function useUtilityClasses7(disabled) {
  const slots = {
    root: ["root", disabled && "disabled"],
    label: ["label"],
    list: ["list"]
  };
  return composeClasses(slots, getOptionGroupUnstyledUtilityClass, {});
}
var import_react2, import_prop_types15, import_jsx_runtime21, import_jsx_runtime22, _excluded13, OptionGroupUnstyled;
var init_OptionGroupUnstyled = __esm({
  "node_modules/@mui/base/OptionGroupUnstyled/OptionGroupUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    import_react2 = __toESM(require_react());
    import_prop_types15 = __toESM(require_prop_types());
    init_composeClasses();
    init_optionGroupUnstyledClasses();
    init_utils();
    import_jsx_runtime21 = __toESM(require_jsx_runtime());
    import_jsx_runtime22 = __toESM(require_jsx_runtime());
    _excluded13 = ["component", "components", "disabled", "componentsProps"];
    OptionGroupUnstyled = import_react2.default.forwardRef(function OptionGroupUnstyled2(props, ref) {
      const {
        component,
        components = {},
        disabled = false,
        componentsProps = {}
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded13);
      const Root = component || (components == null ? void 0 : components.Root) || "li";
      const Label = (components == null ? void 0 : components.Label) || "span";
      const List = (components == null ? void 0 : components.List) || "ul";
      const classes = useUtilityClasses7(disabled);
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref
        },
        ownerState: props,
        className: classes.root
      });
      const labelProps = useSlotProps({
        elementType: Label,
        externalSlotProps: componentsProps.label,
        ownerState: props,
        className: classes.label
      });
      const listProps = useSlotProps({
        elementType: List,
        externalSlotProps: componentsProps.list,
        ownerState: props,
        className: classes.list
      });
      return (0, import_jsx_runtime22.jsxs)(Root, _extends({}, rootProps, {
        children: [(0, import_jsx_runtime21.jsx)(Label, _extends({}, labelProps, {
          children: props.label
        })), (0, import_jsx_runtime21.jsx)(List, _extends({}, listProps, {
          children: props.children
        }))]
      }));
    });
    true ? OptionGroupUnstyled.propTypes = {
      children: import_prop_types15.default.node,
      component: import_prop_types15.default.elementType,
      components: import_prop_types15.default.shape({
        Label: import_prop_types15.default.elementType,
        List: import_prop_types15.default.elementType,
        Root: import_prop_types15.default.elementType
      }),
      componentsProps: import_prop_types15.default.shape({
        label: import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.object]),
        list: import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.object]),
        root: import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.object])
      }),
      disabled: import_prop_types15.default.bool,
      label: import_prop_types15.default.node
    } : void 0;
  }
});

// node_modules/@mui/base/OptionGroupUnstyled/OptionGroupUnstyled.types.js
var init_OptionGroupUnstyled_types = __esm({
  "node_modules/@mui/base/OptionGroupUnstyled/OptionGroupUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/OptionGroupUnstyled/index.js
var init_OptionGroupUnstyled2 = __esm({
  "node_modules/@mui/base/OptionGroupUnstyled/index.js"() {
    init_OptionGroupUnstyled();
    init_OptionGroupUnstyled_types();
    init_optionGroupUnstyledClasses();
    init_optionGroupUnstyledClasses();
  }
});

// node_modules/@mui/base/OptionUnstyled/optionUnstyledClasses.js
function getOptionUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiOptionUnstyled", slot);
}
var optionUnstyledClasses;
var init_optionUnstyledClasses = __esm({
  "node_modules/@mui/base/OptionUnstyled/optionUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    optionUnstyledClasses = generateUtilityClasses("MuiOptionUnstyled", ["root", "disabled", "selected", "highlighted"]);
  }
});

// node_modules/@mui/base/OptionUnstyled/OptionUnstyled.js
function useUtilityClasses8(ownerState) {
  const {
    disabled,
    highlighted,
    selected
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", highlighted && "highlighted", selected && "selected"]
  };
  return composeClasses(slots, getOptionUnstyledUtilityClass, {});
}
var import_react3, import_prop_types16, import_jsx_runtime23, _excluded14, OptionUnstyled, OptionUnstyled_default;
var init_OptionUnstyled = __esm({
  "node_modules/@mui/base/OptionUnstyled/OptionUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    import_react3 = __toESM(require_react());
    import_prop_types16 = __toESM(require_prop_types());
    init_esm();
    init_composeClasses();
    init_SelectUnstyledContext();
    init_optionUnstyledClasses();
    init_utils();
    import_jsx_runtime23 = __toESM(require_jsx_runtime());
    _excluded14 = ["children", "component", "components", "componentsProps", "disabled", "value", "label"];
    OptionUnstyled = import_react3.default.forwardRef(function OptionUnstyled2(props, ref) {
      const {
        children,
        component,
        components = {},
        componentsProps = {},
        disabled,
        value,
        label
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded14);
      const selectContext = import_react3.default.useContext(SelectUnstyledContext);
      if (!selectContext) {
        throw new Error("OptionUnstyled must be used within a SelectUnstyled");
      }
      const Root = component || components.Root || "li";
      const selectOption = {
        value,
        label: label || children,
        disabled
      };
      const optionState = selectContext.getOptionState(selectOption);
      const optionProps = selectContext.getOptionProps(selectOption);
      const listboxRef = selectContext.listboxRef;
      const ownerState = _extends({}, props, optionState);
      const optionRef = import_react3.default.useRef(null);
      const handleRef = useForkRef(ref, optionRef);
      import_react3.default.useEffect(() => {
        if (optionState.highlighted) {
          if (!listboxRef.current || !optionRef.current) {
            return;
          }
          const listboxClientRect = listboxRef.current.getBoundingClientRect();
          const optionClientRect = optionRef.current.getBoundingClientRect();
          if (optionClientRect.top < listboxClientRect.top) {
            listboxRef.current.scrollTop -= listboxClientRect.top - optionClientRect.top;
          } else if (optionClientRect.bottom > listboxClientRect.bottom) {
            listboxRef.current.scrollTop += optionClientRect.bottom - listboxClientRect.bottom;
          }
        }
      }, [optionState.highlighted, listboxRef]);
      const classes = useUtilityClasses8(ownerState);
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: _extends({}, optionProps, {
          ref: handleRef
        }),
        className: classes.root,
        ownerState
      });
      return (0, import_jsx_runtime23.jsx)(Root, _extends({}, rootProps, {
        children
      }));
    });
    true ? OptionUnstyled.propTypes = {
      children: import_prop_types16.default.node,
      component: import_prop_types16.default.elementType,
      components: import_prop_types16.default.shape({
        Root: import_prop_types16.default.elementType
      }),
      componentsProps: import_prop_types16.default.shape({
        root: import_prop_types16.default.oneOfType([import_prop_types16.default.func, import_prop_types16.default.object])
      }),
      disabled: import_prop_types16.default.bool,
      label: import_prop_types16.default.string,
      value: import_prop_types16.default.any.isRequired
    } : void 0;
    OptionUnstyled_default = import_react3.default.memo(OptionUnstyled);
  }
});

// node_modules/@mui/base/OptionUnstyled/OptionUnstyled.types.js
var init_OptionUnstyled_types = __esm({
  "node_modules/@mui/base/OptionUnstyled/OptionUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/OptionUnstyled/index.js
var init_OptionUnstyled2 = __esm({
  "node_modules/@mui/base/OptionUnstyled/index.js"() {
    init_OptionUnstyled();
    init_OptionUnstyled_types();
    init_optionUnstyledClasses();
    init_optionUnstyledClasses();
  }
});

// node_modules/@mui/base/SelectUnstyled/SelectUnstyled.js
function defaultRenderSingleValue(selectedOption) {
  var _selectedOption$label;
  return (_selectedOption$label = selectedOption == null ? void 0 : selectedOption.label) != null ? _selectedOption$label : "";
}
function defaultFormValueProvider2(selectedOption) {
  if ((selectedOption == null ? void 0 : selectedOption.value) == null) {
    return "";
  }
  if (typeof selectedOption.value === "string" || typeof selectedOption.value === "number") {
    return selectedOption.value;
  }
  return JSON.stringify(selectedOption.value);
}
function useUtilityClasses9(ownerState) {
  const {
    active,
    disabled,
    open,
    focusVisible
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible", active && "active", open && "expanded"],
    listbox: ["listbox", disabled && "disabled"],
    popper: ["popper"]
  };
  return composeClasses(slots, getSelectUnstyledUtilityClass, {});
}
var React30, import_prop_types17, import_jsx_runtime24, import_jsx_runtime25, _excluded15, SelectUnstyled;
var init_SelectUnstyled = __esm({
  "node_modules/@mui/base/SelectUnstyled/SelectUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React30 = __toESM(require_react());
    import_prop_types17 = __toESM(require_prop_types());
    init_esm();
    init_utils2();
    init_useSelect();
    init_utils();
    init_PopperUnstyled2();
    init_SelectUnstyledContext();
    init_composeClasses();
    init_selectUnstyledClasses();
    init_defaultOptionStringifier();
    import_jsx_runtime24 = __toESM(require_jsx_runtime());
    import_jsx_runtime25 = __toESM(require_jsx_runtime());
    _excluded15 = ["autoFocus", "children", "component", "components", "componentsProps", "defaultValue", "defaultListboxOpen", "disabled", "getSerializedValue", "listboxId", "listboxOpen", "name", "onChange", "onListboxOpenChange", "optionStringifier", "renderValue", "value"];
    SelectUnstyled = React30.forwardRef(function SelectUnstyled2(props, forwardedRef) {
      var _ref, _components$Listbox, _components$Popper;
      const {
        autoFocus,
        children,
        component,
        components = {},
        componentsProps = {},
        defaultValue,
        defaultListboxOpen = false,
        disabled: disabledProp,
        getSerializedValue = defaultFormValueProvider2,
        listboxId,
        listboxOpen: listboxOpenProp,
        name,
        onChange,
        onListboxOpenChange,
        optionStringifier = defaultOptionStringifier_default,
        renderValue: renderValueProp,
        value: valueProp
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded15);
      const renderValue = renderValueProp != null ? renderValueProp : defaultRenderSingleValue;
      const [groupedOptions, setGroupedOptions] = React30.useState([]);
      const options = React30.useMemo(() => flattenOptionGroups(groupedOptions), [groupedOptions]);
      const [listboxOpen, setListboxOpen] = useControlled({
        controlled: listboxOpenProp,
        default: defaultListboxOpen,
        name: "SelectUnstyled",
        state: "listboxOpen"
      });
      React30.useEffect(() => {
        setGroupedOptions(getOptionsFromChildren(children));
      }, [children]);
      const [buttonDefined, setButtonDefined] = React30.useState(false);
      const buttonRef = React30.useRef(null);
      const listboxRef = React30.useRef(null);
      const Button = (_ref = component != null ? component : components.Root) != null ? _ref : "button";
      const ListboxRoot = (_components$Listbox = components.Listbox) != null ? _components$Listbox : "ul";
      const Popper = (_components$Popper = components.Popper) != null ? _components$Popper : PopperUnstyled_default;
      const handleButtonRefChange = React30.useCallback((element) => {
        setButtonDefined(element != null);
      }, []);
      const handleButtonRef = useForkRef(forwardedRef, useForkRef(buttonRef, handleButtonRefChange));
      React30.useEffect(() => {
        if (autoFocus) {
          buttonRef.current.focus();
        }
      }, [autoFocus]);
      const handleOpenChange = (isOpen) => {
        setListboxOpen(isOpen);
        onListboxOpenChange == null ? void 0 : onListboxOpenChange(isOpen);
      };
      const {
        buttonActive,
        buttonFocusVisible,
        disabled,
        getButtonProps,
        getListboxProps,
        getOptionProps,
        getOptionState,
        value
      } = useSelect_default({
        buttonRef: handleButtonRef,
        defaultValue,
        disabled: disabledProp,
        listboxId,
        multiple: false,
        onChange,
        onOpenChange: handleOpenChange,
        open: listboxOpen,
        options,
        optionStringifier,
        value: valueProp
      });
      const ownerState = _extends({}, props, {
        active: buttonActive,
        defaultListboxOpen,
        disabled,
        focusVisible: buttonFocusVisible,
        open: listboxOpen,
        renderValue,
        value
      });
      const classes = useUtilityClasses9(ownerState);
      const selectedOption = React30.useMemo(() => {
        var _options$find;
        return (_options$find = options.find((o) => value === o.value)) != null ? _options$find : null;
      }, [options, value]);
      const buttonProps = useSlotProps({
        elementType: Button,
        getSlotProps: getButtonProps,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        ownerState,
        className: classes.root
      });
      const listboxProps = useSlotProps({
        elementType: ListboxRoot,
        getSlotProps: getListboxProps,
        externalSlotProps: componentsProps.listbox,
        additionalProps: {
          ref: listboxRef
        },
        ownerState,
        className: classes.listbox
      });
      const popperProps = useSlotProps({
        elementType: Popper,
        externalSlotProps: componentsProps.popper,
        additionalProps: {
          anchorEl: buttonRef.current,
          disablePortal: true,
          open: listboxOpen,
          placement: "bottom-start",
          role: void 0
        },
        ownerState,
        className: classes.popper
      });
      const context = {
        getOptionProps,
        getOptionState,
        listboxRef
      };
      return (0, import_jsx_runtime25.jsxs)(React30.Fragment, {
        children: [(0, import_jsx_runtime24.jsx)(Button, _extends({}, buttonProps, {
          children: renderValue(selectedOption)
        })), buttonDefined && (0, import_jsx_runtime24.jsx)(Popper, _extends({}, popperProps, {
          children: (0, import_jsx_runtime24.jsx)(ListboxRoot, _extends({}, listboxProps, {
            children: (0, import_jsx_runtime24.jsx)(SelectUnstyledContext.Provider, {
              value: context,
              children
            })
          }))
        })), name && (0, import_jsx_runtime24.jsx)("input", {
          type: "hidden",
          name,
          value: getSerializedValue(selectedOption)
        })]
      });
    });
    true ? SelectUnstyled.propTypes = {
      autoFocus: import_prop_types17.default.bool,
      children: import_prop_types17.default.node,
      component: import_prop_types17.default.elementType,
      components: import_prop_types17.default.shape({
        Listbox: import_prop_types17.default.elementType,
        Popper: import_prop_types17.default.elementType,
        Root: import_prop_types17.default.elementType
      }),
      componentsProps: import_prop_types17.default.shape({
        listbox: import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object]),
        popper: import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object]),
        root: import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object])
      }),
      defaultListboxOpen: import_prop_types17.default.bool,
      defaultValue: import_prop_types17.default.any,
      disabled: import_prop_types17.default.bool,
      getSerializedValue: import_prop_types17.default.func,
      listboxId: import_prop_types17.default.string,
      listboxOpen: import_prop_types17.default.bool,
      name: import_prop_types17.default.string,
      onChange: import_prop_types17.default.func,
      onListboxOpenChange: import_prop_types17.default.func,
      optionStringifier: import_prop_types17.default.func,
      renderValue: import_prop_types17.default.func,
      value: import_prop_types17.default.any
    } : void 0;
  }
});

// node_modules/@mui/base/SelectUnstyled/SelectUnstyled.types.js
var init_SelectUnstyled_types = __esm({
  "node_modules/@mui/base/SelectUnstyled/SelectUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/SelectUnstyled/index.js
var init_SelectUnstyled2 = __esm({
  "node_modules/@mui/base/SelectUnstyled/index.js"() {
    init_SelectUnstyled();
    init_SelectUnstyledContext();
    init_selectUnstyledClasses();
    init_selectUnstyledClasses();
    init_SelectUnstyled_types();
    init_useSelect();
    init_useSelect_types();
    init_utils2();
  }
});

// node_modules/@mui/base/SliderUnstyled/sliderUnstyledClasses.js
function getSliderUtilityClass(slot) {
  return generateUtilityClass("MuiSlider", slot);
}
var sliderUnstyledClasses, sliderUnstyledClasses_default;
var init_sliderUnstyledClasses = __esm({
  "node_modules/@mui/base/SliderUnstyled/sliderUnstyledClasses.js"() {
    init_generateUtilityClasses();
    init_generateUtilityClass();
    sliderUnstyledClasses = generateUtilityClasses("MuiSlider", ["root", "active", "focusVisible", "disabled", "dragging", "marked", "vertical", "trackInverted", "trackFalse", "rail", "track", "mark", "markActive", "markLabel", "markLabelActive", "thumb", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel"]);
    sliderUnstyledClasses_default = sliderUnstyledClasses;
  }
});

// node_modules/@mui/base/SliderUnstyled/SliderValueLabelUnstyled.js
function SliderValueLabelUnstyled(props) {
  const {
    children,
    className,
    value,
    theme
  } = props;
  const classes = useValueLabelClasses(props);
  return React31.cloneElement(children, {
    className: clsx_m_default(children.props.className)
  }, (0, import_jsx_runtime27.jsxs)(React31.Fragment, {
    children: [children.props.children, (0, import_jsx_runtime26.jsx)("span", {
      className: clsx_m_default(classes.offset, className),
      theme,
      "aria-hidden": true,
      children: (0, import_jsx_runtime26.jsx)("span", {
        className: classes.circle,
        children: (0, import_jsx_runtime26.jsx)("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}
var React31, import_prop_types18, import_jsx_runtime26, import_jsx_runtime27, useValueLabelClasses;
var init_SliderValueLabelUnstyled = __esm({
  "node_modules/@mui/base/SliderUnstyled/SliderValueLabelUnstyled.js"() {
    React31 = __toESM(require_react());
    import_prop_types18 = __toESM(require_prop_types());
    init_clsx_m();
    init_sliderUnstyledClasses();
    import_jsx_runtime26 = __toESM(require_jsx_runtime());
    import_jsx_runtime27 = __toESM(require_jsx_runtime());
    useValueLabelClasses = (props) => {
      const {
        open
      } = props;
      const utilityClasses = {
        offset: clsx_m_default(open && sliderUnstyledClasses_default.valueLabelOpen),
        circle: sliderUnstyledClasses_default.valueLabelCircle,
        label: sliderUnstyledClasses_default.valueLabelLabel
      };
      return utilityClasses;
    };
    true ? SliderValueLabelUnstyled.propTypes = {
      children: import_prop_types18.default.element.isRequired,
      className: import_prop_types18.default.string,
      theme: import_prop_types18.default.any,
      value: import_prop_types18.default.node
    } : void 0;
  }
});

// node_modules/@mui/base/SliderUnstyled/useSlider.js
function asc(a, b) {
  return a - b;
}
function clamp(value, min, max) {
  if (value == null) {
    return min;
  }
  return Math.min(Math.max(min, value), max);
}
function findClosest(values, currentValue) {
  var _values$reduce;
  const {
    index: closestIndex
  } = (_values$reduce = values.reduce((acc, value, index) => {
    const distance = Math.abs(currentValue - value);
    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index
      };
    }
    return acc;
  }, null)) != null ? _values$reduce : {};
  return closestIndex;
}
function trackFinger(event, touchId) {
  if (touchId.current !== void 0 && event.changedTouches) {
    const touchEvent = event;
    for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {
      const touch = touchEvent.changedTouches[i];
      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}
function percentToValue(percent, min, max) {
  return (max - min) * percent + min;
}
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min) {
  const nearest = Math.round((value - min) / step) * step + min;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function setValueIndex({
  values,
  newValue,
  index
}) {
  const output = values.slice();
  output[index] = newValue;
  return output.sort(asc);
}
function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  var _sliderRef$current, _doc$activeElement;
  const doc = ownerDocument(sliderRef.current);
  if (!((_sliderRef$current = sliderRef.current) != null && _sliderRef$current.contains(doc.activeElement)) || Number(doc == null ? void 0 : (_doc$activeElement = doc.activeElement) == null ? void 0 : _doc$activeElement.getAttribute("data-index")) !== activeIndex) {
    var _sliderRef$current2;
    (_sliderRef$current2 = sliderRef.current) == null ? void 0 : _sliderRef$current2.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
  }
  if (setActive) {
    setActive(activeIndex);
  }
}
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === void 0) {
    if (typeof CSS !== "undefined" && typeof CSS.supports === "function") {
      cachedSupportsTouchActionNone = CSS.supports("touch-action", "none");
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
function useSlider(parameters) {
  const {
    "aria-labelledby": ariaLabelledby,
    defaultValue,
    disabled = false,
    disableSwap = false,
    isRtl = false,
    marks: marksProp = false,
    max = 100,
    min = 0,
    name,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    ref,
    scale = Identity,
    step = 1,
    tabIndex,
    value: valueProp
  } = parameters;
  const touchId = React32.useRef();
  const [active, setActive] = React32.useState(-1);
  const [open, setOpen] = React32.useState(-1);
  const [dragging, setDragging] = React32.useState(false);
  const moveCount = React32.useRef(0);
  const [valueDerived, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : min,
    name: "Slider"
  });
  const handleChange = onChange && ((event, value, thumbIndex) => {
    const nativeEvent = event.nativeEvent || event;
    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, "target", {
      writable: true,
      value: {
        value,
        name
      }
    });
    onChange(clonedEvent, value, thumbIndex);
  });
  const range = Array.isArray(valueDerived);
  let values = range ? valueDerived.slice().sort(asc) : [valueDerived];
  values = values.map((value) => clamp(value, min, max));
  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max - min) / step) + 1)].map((_, index) => ({
    value: min + step * index
  })) : marksProp || [];
  const marksValues = marks.map((mark) => mark.value);
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusedThumbIndex, setFocusedThumbIndex] = React32.useState(-1);
  const sliderRef = React32.useRef();
  const handleFocusRef = useForkRef(focusVisibleRef, sliderRef);
  const handleRef = useForkRef(ref, handleFocusRef);
  const createHandleHiddenInputFocus = (otherHandlers) => (event) => {
    var _otherHandlers$onFocu;
    const index = Number(event.currentTarget.getAttribute("data-index"));
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusedThumbIndex(index);
    }
    setOpen(index);
    otherHandlers == null ? void 0 : (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
  };
  const createHandleHiddenInputBlur = (otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusedThumbIndex(-1);
    }
    setOpen(-1);
    otherHandlers == null ? void 0 : (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
  };
  useEnhancedEffect_default(() => {
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      var _document$activeEleme;
      (_document$activeEleme = document.activeElement) == null ? void 0 : _document$activeEleme.blur();
    }
  }, [disabled]);
  if (disabled && active !== -1) {
    setActive(-1);
  }
  if (disabled && focusedThumbIndex !== -1) {
    setFocusedThumbIndex(-1);
  }
  const createHandleHiddenInputChange = (otherHandlers) => (event) => {
    var _otherHandlers$onChan;
    (_otherHandlers$onChan = otherHandlers.onChange) == null ? void 0 : _otherHandlers$onChan.call(otherHandlers, event);
    const index = Number(event.currentTarget.getAttribute("data-index"));
    const value = values[index];
    const marksIndex = marksValues.indexOf(value);
    let newValue = event.target.valueAsNumber;
    if (marks && step == null) {
      newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
    }
    newValue = clamp(newValue, min, max);
    if (marks && step == null) {
      const currentMarkIndex = marksValues.indexOf(values[index]);
      newValue = newValue < values[index] ? marksValues[currentMarkIndex - 1] : marksValues[currentMarkIndex + 1];
    }
    if (range) {
      if (disableSwap) {
        newValue = clamp(newValue, values[index - 1] || -Infinity, values[index + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values,
        newValue,
        index
      });
      let activeIndex = index;
      if (!disableSwap) {
        activeIndex = newValue.indexOf(previousValue);
      }
      focusThumb({
        sliderRef,
        activeIndex
      });
    }
    setValueState(newValue);
    setFocusedThumbIndex(index);
    if (handleChange) {
      handleChange(event, newValue, index);
    }
    if (onChangeCommitted) {
      onChangeCommitted(event, newValue);
    }
  };
  const previousIndex = React32.useRef();
  let axis = orientation;
  if (isRtl && orientation === "horizontal") {
    axis += "-reverse";
  }
  const getFingerNewValue = ({
    finger,
    move = false,
    values: values2
  }) => {
    const {
      current: slider
    } = sliderRef;
    const {
      width,
      height,
      bottom,
      left
    } = slider.getBoundingClientRect();
    let percent;
    if (axis.indexOf("vertical") === 0) {
      percent = (bottom - finger.y) / height;
    } else {
      percent = (finger.x - left) / width;
    }
    if (axis.indexOf("-reverse") !== -1) {
      percent = 1 - percent;
    }
    let newValue;
    newValue = percentToValue(percent, min, max);
    if (step) {
      newValue = roundValueToStep(newValue, step, min);
    } else {
      const closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }
    newValue = clamp(newValue, min, max);
    let activeIndex = 0;
    if (range) {
      if (!move) {
        activeIndex = findClosest(values2, newValue);
      } else {
        activeIndex = previousIndex.current;
      }
      if (disableSwap) {
        newValue = clamp(newValue, values2[activeIndex - 1] || -Infinity, values2[activeIndex + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index: activeIndex
      });
      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }
    return {
      newValue,
      activeIndex
    };
  };
  const handleTouchMove = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    if (!finger) {
      return;
    }
    moveCount.current += 1;
    if (nativeEvent.type === "mousemove" && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    const {
      newValue,
      activeIndex
    } = getFingerNewValue({
      finger,
      move: true,
      values
    });
    focusThumb({
      sliderRef,
      activeIndex,
      setActive
    });
    setValueState(newValue);
    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
      setDragging(true);
    }
    if (handleChange) {
      handleChange(nativeEvent, newValue, activeIndex);
    }
  });
  const handleTouchEnd = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    setDragging(false);
    if (!finger) {
      return;
    }
    const {
      newValue
    } = getFingerNewValue({
      finger,
      move: true,
      values
    });
    setActive(-1);
    if (nativeEvent.type === "touchend") {
      setOpen(-1);
    }
    if (onChangeCommitted) {
      onChangeCommitted(nativeEvent, newValue);
    }
    touchId.current = void 0;
    stopListening();
  });
  const handleTouchStart = useEventCallback((nativeEvent) => {
    if (disabled) {
      return;
    }
    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      touchId.current = touch.identifier;
    }
    const finger = trackFinger(nativeEvent, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger,
        values
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange) {
        handleChange(nativeEvent, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("touchmove", handleTouchMove);
    doc.addEventListener("touchend", handleTouchEnd);
  });
  const stopListening = React32.useCallback(() => {
    const doc = ownerDocument(sliderRef.current);
    doc.removeEventListener("mousemove", handleTouchMove);
    doc.removeEventListener("mouseup", handleTouchEnd);
    doc.removeEventListener("touchmove", handleTouchMove);
    doc.removeEventListener("touchend", handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  React32.useEffect(() => {
    const {
      current: slider
    } = sliderRef;
    slider.addEventListener("touchstart", handleTouchStart, {
      passive: doesSupportTouchActionNone()
    });
    return () => {
      slider.removeEventListener("touchstart", handleTouchStart, {
        passive: doesSupportTouchActionNone()
      });
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  React32.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const createHandleMouseDown = (otherHandlers) => (event) => {
    var _otherHandlers$onMous;
    (_otherHandlers$onMous = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);
    if (disabled) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    const finger = trackFinger(event, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger,
        values
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange) {
        handleChange(event, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("mousemove", handleTouchMove);
    doc.addEventListener("mouseup", handleTouchEnd);
  };
  const trackOffset = valueToPercent(range ? values[0] : min, min, max);
  const trackLeap = valueToPercent(values[values.length - 1], min, max) - trackOffset;
  const getRootProps = (otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseDown: createHandleMouseDown(otherHandlers || {})
    };
    const mergedEventHandlers = _extends({}, otherHandlers, ownEventHandlers);
    return _extends({
      ref: handleRef
    }, mergedEventHandlers);
  };
  const createHandleMouseOver = (otherHandlers) => (event) => {
    var _otherHandlers$onMous2;
    (_otherHandlers$onMous2 = otherHandlers.onMouseOver) == null ? void 0 : _otherHandlers$onMous2.call(otherHandlers, event);
    const index = Number(event.currentTarget.getAttribute("data-index"));
    setOpen(index);
  };
  const createHandleMouseLeave = (otherHandlers) => (event) => {
    var _otherHandlers$onMous3;
    (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) == null ? void 0 : _otherHandlers$onMous3.call(otherHandlers, event);
    setOpen(-1);
  };
  const getThumbProps = (otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseOver: createHandleMouseOver(otherHandlers || {}),
      onMouseLeave: createHandleMouseLeave(otherHandlers || {})
    };
    return _extends({}, otherHandlers, ownEventHandlers);
  };
  const getHiddenInputProps = (otherHandlers = {}) => {
    var _parameters$step;
    const ownEventHandlers = {
      onChange: createHandleHiddenInputChange(otherHandlers || {}),
      onFocus: createHandleHiddenInputFocus(otherHandlers || {}),
      onBlur: createHandleHiddenInputBlur(otherHandlers || {})
    };
    const mergedEventHandlers = _extends({}, otherHandlers, ownEventHandlers);
    return _extends({
      tabIndex,
      "aria-labelledby": ariaLabelledby,
      "aria-orientation": orientation,
      "aria-valuemax": scale(max),
      "aria-valuemin": scale(min),
      name,
      type: "range",
      min: parameters.min,
      max: parameters.max,
      step: (_parameters$step = parameters.step) != null ? _parameters$step : void 0,
      disabled
    }, mergedEventHandlers, {
      style: _extends({}, visuallyHidden_default, {
        direction: isRtl ? "rtl" : "ltr",
        width: "100%",
        height: "100%"
      })
    });
  };
  return {
    active,
    axis,
    axisProps,
    dragging,
    focusedThumbIndex,
    getHiddenInputProps,
    getRootProps,
    getThumbProps,
    marks,
    open,
    range,
    trackLeap,
    trackOffset,
    values
  };
}
var React32, INTENTIONAL_DRAG_COUNT_THRESHOLD, axisProps, Identity, cachedSupportsTouchActionNone;
var init_useSlider = __esm({
  "node_modules/@mui/base/SliderUnstyled/useSlider.js"() {
    init_extends();
    React32 = __toESM(require_react());
    init_esm();
    INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
    axisProps = {
      horizontal: {
        offset: (percent) => ({
          left: `${percent}%`
        }),
        leap: (percent) => ({
          width: `${percent}%`
        })
      },
      "horizontal-reverse": {
        offset: (percent) => ({
          right: `${percent}%`
        }),
        leap: (percent) => ({
          width: `${percent}%`
        })
      },
      vertical: {
        offset: (percent) => ({
          bottom: `${percent}%`
        }),
        leap: (percent) => ({
          height: `${percent}%`
        })
      }
    };
    Identity = (x) => x;
  }
});

// node_modules/@mui/base/SliderUnstyled/SliderUnstyled.js
var React33, import_prop_types19, import_jsx_runtime28, import_jsx_runtime29, _excluded16, Identity2, useUtilityClasses10, Forward, SliderUnstyled, SliderUnstyled_default;
var init_SliderUnstyled = __esm({
  "node_modules/@mui/base/SliderUnstyled/SliderUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React33 = __toESM(require_react());
    import_prop_types19 = __toESM(require_prop_types());
    init_clsx_m();
    init_esm();
    init_isHostComponent();
    init_composeClasses();
    init_sliderUnstyledClasses();
    init_SliderValueLabelUnstyled();
    init_useSlider();
    init_useSlotProps();
    import_jsx_runtime28 = __toESM(require_jsx_runtime());
    import_jsx_runtime29 = __toESM(require_jsx_runtime());
    _excluded16 = ["aria-label", "aria-valuetext", "className", "component", "classes", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "orientation", "scale", "step", "tabIndex", "track", "value", "valueLabelDisplay", "valueLabelFormat", "isRtl", "components", "componentsProps"];
    Identity2 = (x) => x;
    useUtilityClasses10 = (ownerState) => {
      const {
        disabled,
        dragging,
        marked,
        orientation,
        track,
        classes
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", dragging && "dragging", marked && "marked", orientation === "vertical" && "vertical", track === "inverted" && "trackInverted", track === false && "trackFalse"],
        rail: ["rail"],
        track: ["track"],
        mark: ["mark"],
        markActive: ["markActive"],
        markLabel: ["markLabel"],
        markLabelActive: ["markLabelActive"],
        valueLabel: ["valueLabel"],
        thumb: ["thumb", disabled && "disabled"],
        active: ["active"],
        disabled: ["disabled"],
        focusVisible: ["focusVisible"]
      };
      return composeClasses(slots, getSliderUtilityClass, classes);
    };
    Forward = ({
      children
    }) => children;
    SliderUnstyled = React33.forwardRef(function SliderUnstyled2(props, ref) {
      var _ref, _components$Rail, _components$Track, _components$Thumb, _components$ValueLabe, _components$Mark, _components$MarkLabel;
      const {
        "aria-label": ariaLabel,
        "aria-valuetext": ariaValuetext,
        className,
        component,
        classes: classesProp,
        disableSwap = false,
        disabled = false,
        getAriaLabel,
        getAriaValueText,
        marks: marksProp = false,
        max = 100,
        min = 0,
        orientation = "horizontal",
        scale = Identity2,
        step = 1,
        track = "normal",
        valueLabelDisplay = "off",
        valueLabelFormat = Identity2,
        isRtl = false,
        components = {},
        componentsProps = {}
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded16);
      const ownerState = _extends({}, props, {
        marks: marksProp,
        classes: classesProp,
        disabled,
        isRtl,
        max,
        min,
        orientation,
        scale,
        step,
        track,
        valueLabelDisplay,
        valueLabelFormat
      });
      const {
        axisProps: axisProps2,
        getRootProps,
        getHiddenInputProps,
        getThumbProps,
        open,
        active,
        axis,
        range,
        focusedThumbIndex,
        dragging,
        marks,
        values,
        trackOffset,
        trackLeap
      } = useSlider(_extends({}, ownerState, {
        ref
      }));
      ownerState.marked = marks.length > 0 && marks.some((mark) => mark.label);
      ownerState.dragging = dragging;
      ownerState.focusedThumbIndex = focusedThumbIndex;
      const classes = useUtilityClasses10(ownerState);
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "span";
      const rootProps = useSlotProps({
        elementType: Root,
        getSlotProps: getRootProps,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        ownerState,
        className: [classes.root, className]
      });
      const Rail = (_components$Rail = components.Rail) != null ? _components$Rail : "span";
      const railProps = useSlotProps({
        elementType: Rail,
        externalSlotProps: componentsProps.rail,
        ownerState,
        className: classes.rail
      });
      const Track = (_components$Track = components.Track) != null ? _components$Track : "span";
      const trackProps = useSlotProps({
        elementType: Track,
        externalSlotProps: componentsProps.track,
        additionalProps: {
          style: _extends({}, axisProps2[axis].offset(trackOffset), axisProps2[axis].leap(trackLeap))
        },
        ownerState,
        className: classes.track
      });
      const Thumb = (_components$Thumb = components.Thumb) != null ? _components$Thumb : "span";
      const thumbProps = useSlotProps({
        elementType: Thumb,
        getSlotProps: getThumbProps,
        externalSlotProps: componentsProps.thumb,
        ownerState
      });
      const ValueLabel = (_components$ValueLabe = components.ValueLabel) != null ? _components$ValueLabe : SliderValueLabelUnstyled;
      const valueLabelProps = useSlotProps({
        elementType: ValueLabel,
        externalSlotProps: componentsProps.valueLabel,
        ownerState
      });
      const Mark = (_components$Mark = components.Mark) != null ? _components$Mark : "span";
      const markProps = useSlotProps({
        elementType: Mark,
        externalSlotProps: componentsProps.mark,
        ownerState,
        className: classes.mark
      });
      const MarkLabel = (_components$MarkLabel = components.MarkLabel) != null ? _components$MarkLabel : "span";
      const markLabelProps = useSlotProps({
        elementType: MarkLabel,
        externalSlotProps: componentsProps.markLabel,
        ownerState
      });
      const Input = components.Input || "input";
      const inputProps = useSlotProps({
        elementType: Input,
        getSlotProps: getHiddenInputProps,
        externalSlotProps: componentsProps.input,
        ownerState
      });
      return (0, import_jsx_runtime29.jsxs)(Root, _extends({}, rootProps, {
        children: [(0, import_jsx_runtime28.jsx)(Rail, _extends({}, railProps)), (0, import_jsx_runtime28.jsx)(Track, _extends({}, trackProps)), marks.filter((mark) => mark.value >= min && mark.value <= max).map((mark, index) => {
          const percent = valueToPercent(mark.value, min, max);
          const style = axisProps2[axis].offset(percent);
          let markActive;
          if (track === false) {
            markActive = values.indexOf(mark.value) !== -1;
          } else {
            markActive = track === "normal" && (range ? mark.value >= values[0] && mark.value <= values[values.length - 1] : mark.value <= values[0]) || track === "inverted" && (range ? mark.value <= values[0] || mark.value >= values[values.length - 1] : mark.value >= values[0]);
          }
          return (0, import_jsx_runtime29.jsxs)(React33.Fragment, {
            children: [(0, import_jsx_runtime28.jsx)(Mark, _extends({
              "data-index": index
            }, markProps, !isHostComponent_default(Mark) && {
              markActive
            }, {
              style: _extends({}, style, markProps.style),
              className: clsx_m_default(markProps.className, markActive && classes.markActive)
            })), mark.label != null ? (0, import_jsx_runtime28.jsx)(MarkLabel, _extends({
              "aria-hidden": true,
              "data-index": index
            }, markLabelProps, !isHostComponent_default(MarkLabel) && {
              markLabelActive: markActive
            }, {
              style: _extends({}, style, markLabelProps.style),
              className: clsx_m_default(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
              children: mark.label
            })) : null]
          }, mark.value);
        }), values.map((value, index) => {
          const percent = valueToPercent(value, min, max);
          const style = axisProps2[axis].offset(percent);
          const ValueLabelComponent = valueLabelDisplay === "off" ? Forward : ValueLabel;
          return (0, import_jsx_runtime28.jsx)(React33.Fragment, {
            children: (0, import_jsx_runtime28.jsx)(ValueLabelComponent, _extends({}, !isHostComponent_default(ValueLabelComponent) && {
              valueLabelFormat,
              valueLabelDisplay,
              value: typeof valueLabelFormat === "function" ? valueLabelFormat(scale(value), index) : valueLabelFormat,
              index,
              open: open === index || active === index || valueLabelDisplay === "on",
              disabled
            }, valueLabelProps, {
              className: clsx_m_default(classes.valueLabel, valueLabelProps.className),
              children: (0, import_jsx_runtime28.jsx)(Thumb, _extends({
                "data-index": index,
                "data-focusvisible": focusedThumbIndex === index
              }, thumbProps, {
                className: clsx_m_default(classes.thumb, thumbProps.className, active === index && classes.active, focusedThumbIndex === index && classes.focusVisible),
                style: _extends({}, style, {
                  pointerEvents: disableSwap && active !== index ? "none" : void 0
                }, thumbProps.style),
                children: (0, import_jsx_runtime28.jsx)(Input, _extends({
                  "data-index": index,
                  "aria-label": getAriaLabel ? getAriaLabel(index) : ariaLabel,
                  "aria-valuenow": scale(value),
                  "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index) : ariaValuetext,
                  value: values[index]
                }, inputProps))
              }))
            }))
          }, index);
        })]
      }));
    });
    true ? SliderUnstyled.propTypes = {
      "aria-label": chainPropTypes(import_prop_types19.default.string, (props) => {
        const range = Array.isArray(props.value || props.defaultValue);
        if (range && props["aria-label"] != null) {
          return new Error("MUI: You need to use the `getAriaLabel` prop instead of `aria-label` when using a range slider.");
        }
        return null;
      }),
      "aria-labelledby": import_prop_types19.default.string,
      "aria-valuetext": chainPropTypes(import_prop_types19.default.string, (props) => {
        const range = Array.isArray(props.value || props.defaultValue);
        if (range && props["aria-valuetext"] != null) {
          return new Error("MUI: You need to use the `getAriaValueText` prop instead of `aria-valuetext` when using a range slider.");
        }
        return null;
      }),
      children: import_prop_types19.default.node,
      classes: import_prop_types19.default.object,
      className: import_prop_types19.default.string,
      component: import_prop_types19.default.elementType,
      components: import_prop_types19.default.shape({
        Input: import_prop_types19.default.elementType,
        Mark: import_prop_types19.default.elementType,
        MarkLabel: import_prop_types19.default.elementType,
        Rail: import_prop_types19.default.elementType,
        Root: import_prop_types19.default.elementType,
        Thumb: import_prop_types19.default.elementType,
        Track: import_prop_types19.default.elementType,
        ValueLabel: import_prop_types19.default.elementType
      }),
      componentsProps: import_prop_types19.default.shape({
        input: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object]),
        mark: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object]),
        markLabel: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object]),
        rail: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object]),
        root: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object]),
        thumb: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object]),
        track: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object]),
        valueLabel: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.shape({
          children: import_prop_types19.default.element,
          className: import_prop_types19.default.string,
          components: import_prop_types19.default.shape({
            Root: import_prop_types19.default.elementType
          }),
          open: import_prop_types19.default.bool,
          style: import_prop_types19.default.object,
          value: import_prop_types19.default.number,
          valueLabelDisplay: import_prop_types19.default.oneOf(["auto", "off", "on"])
        })])
      }),
      defaultValue: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.number), import_prop_types19.default.number]),
      disabled: import_prop_types19.default.bool,
      disableSwap: import_prop_types19.default.bool,
      getAriaLabel: import_prop_types19.default.func,
      getAriaValueText: import_prop_types19.default.func,
      isRtl: import_prop_types19.default.bool,
      marks: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.shape({
        label: import_prop_types19.default.node,
        value: import_prop_types19.default.number.isRequired
      })), import_prop_types19.default.bool]),
      max: import_prop_types19.default.number,
      min: import_prop_types19.default.number,
      name: import_prop_types19.default.string,
      onChange: import_prop_types19.default.func,
      onChangeCommitted: import_prop_types19.default.func,
      orientation: import_prop_types19.default.oneOf(["horizontal", "vertical"]),
      scale: import_prop_types19.default.func,
      step: import_prop_types19.default.number,
      tabIndex: import_prop_types19.default.number,
      track: import_prop_types19.default.oneOf(["inverted", "normal", false]),
      value: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.number), import_prop_types19.default.number]),
      valueLabelDisplay: import_prop_types19.default.oneOf(["auto", "off", "on"]),
      valueLabelFormat: import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.string])
    } : void 0;
    SliderUnstyled_default = SliderUnstyled;
  }
});

// node_modules/@mui/base/SliderUnstyled/index.js
var init_SliderUnstyled2 = __esm({
  "node_modules/@mui/base/SliderUnstyled/index.js"() {
    init_SliderUnstyled();
    init_SliderValueLabelUnstyled();
    init_sliderUnstyledClasses();
    init_useSlider();
    init_sliderUnstyledClasses();
  }
});

// node_modules/@mui/base/SwitchUnstyled/useSwitch.js
function useSwitch(props) {
  const {
    checked: checkedProp,
    defaultChecked,
    disabled,
    onBlur,
    onChange,
    onFocus,
    onFocusVisible,
    readOnly,
    required
  } = props;
  const [checked, setCheckedState] = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "Switch",
    state: "checked"
  });
  const createHandleInputChange = (otherProps) => (event) => {
    var _otherProps$onChange;
    if (event.nativeEvent.defaultPrevented) {
      return;
    }
    setCheckedState(event.target.checked);
    onChange == null ? void 0 : onChange(event);
    (_otherProps$onChange = otherProps.onChange) == null ? void 0 : _otherProps$onChange.call(otherProps, event);
  };
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = React34.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  React34.useEffect(() => {
    isFocusVisibleRef.current = focusVisible;
  }, [focusVisible, isFocusVisibleRef]);
  const inputRef = React34.useRef(null);
  const createHandleFocus = (otherProps) => (event) => {
    var _otherProps$onFocus;
    if (!inputRef.current) {
      inputRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      onFocusVisible == null ? void 0 : onFocusVisible(event);
    }
    onFocus == null ? void 0 : onFocus(event);
    (_otherProps$onFocus = otherProps.onFocus) == null ? void 0 : _otherProps$onFocus.call(otherProps, event);
  };
  const createHandleBlur = (otherProps) => (event) => {
    var _otherProps$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    onBlur == null ? void 0 : onBlur(event);
    (_otherProps$onBlur = otherProps.onBlur) == null ? void 0 : _otherProps$onBlur.call(otherProps, event);
  };
  const handleRefChange = useForkRef(focusVisibleRef, inputRef);
  const getInputProps = (otherProps = {}) => _extends({
    checked: checkedProp,
    defaultChecked,
    disabled,
    readOnly,
    ref: handleRefChange,
    required,
    type: "checkbox"
  }, otherProps, {
    onChange: createHandleInputChange(otherProps),
    onFocus: createHandleFocus(otherProps),
    onBlur: createHandleBlur(otherProps)
  });
  return {
    checked,
    disabled: Boolean(disabled),
    focusVisible,
    getInputProps,
    readOnly: Boolean(readOnly)
  };
}
var React34;
var init_useSwitch = __esm({
  "node_modules/@mui/base/SwitchUnstyled/useSwitch.js"() {
    init_extends();
    React34 = __toESM(require_react());
    init_esm();
  }
});

// node_modules/@mui/base/SwitchUnstyled/switchUnstyledClasses.js
function getSwitchUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiSwitch", slot);
}
var switchUnstyledClasses;
var init_switchUnstyledClasses = __esm({
  "node_modules/@mui/base/SwitchUnstyled/switchUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    switchUnstyledClasses = generateUtilityClasses("MuiSwitch", ["root", "input", "track", "thumb", "checked", "disabled", "focusVisible", "readOnly"]);
  }
});

// node_modules/@mui/base/SwitchUnstyled/SwitchUnstyled.js
var React35, import_prop_types20, import_jsx_runtime30, import_jsx_runtime31, _excluded17, useUtilityClasses11, SwitchUnstyled;
var init_SwitchUnstyled = __esm({
  "node_modules/@mui/base/SwitchUnstyled/SwitchUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React35 = __toESM(require_react());
    import_prop_types20 = __toESM(require_prop_types());
    init_composeClasses();
    init_useSwitch();
    init_switchUnstyledClasses();
    init_utils();
    import_jsx_runtime30 = __toESM(require_jsx_runtime());
    import_jsx_runtime31 = __toESM(require_jsx_runtime());
    _excluded17 = ["checked", "component", "components", "componentsProps", "defaultChecked", "disabled", "onBlur", "onChange", "onFocus", "onFocusVisible", "readOnly", "required"];
    useUtilityClasses11 = (ownerState) => {
      const {
        checked,
        disabled,
        focusVisible,
        readOnly
      } = ownerState;
      const slots = {
        root: ["root", checked && "checked", disabled && "disabled", focusVisible && "focusVisible", readOnly && "readOnly"],
        thumb: ["thumb"],
        input: ["input"],
        track: ["track"]
      };
      return composeClasses(slots, getSwitchUnstyledUtilityClass, {});
    };
    SwitchUnstyled = React35.forwardRef(function SwitchUnstyled2(props, ref) {
      var _ref, _components$Thumb, _components$Input, _components$Track;
      const {
        checked: checkedProp,
        component,
        components = {},
        componentsProps = {},
        defaultChecked,
        disabled: disabledProp,
        onBlur,
        onChange,
        onFocus,
        onFocusVisible,
        readOnly: readOnlyProp
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded17);
      const useSwitchProps = {
        checked: checkedProp,
        defaultChecked,
        disabled: disabledProp,
        onBlur,
        onChange,
        onFocus,
        onFocusVisible,
        readOnly: readOnlyProp
      };
      const {
        getInputProps,
        checked,
        disabled,
        focusVisible,
        readOnly
      } = useSwitch(useSwitchProps);
      const ownerState = _extends({}, props, {
        checked,
        disabled,
        focusVisible,
        readOnly
      });
      const classes = useUtilityClasses11(ownerState);
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "span";
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref
        },
        ownerState,
        className: classes.root
      });
      const Thumb = (_components$Thumb = components.Thumb) != null ? _components$Thumb : "span";
      const thumbProps = useSlotProps({
        elementType: Thumb,
        externalSlotProps: componentsProps.thumb,
        ownerState,
        className: classes.thumb
      });
      const Input = (_components$Input = components.Input) != null ? _components$Input : "input";
      const inputProps = useSlotProps({
        elementType: Input,
        getSlotProps: getInputProps,
        externalSlotProps: componentsProps.input,
        ownerState,
        className: classes.input
      });
      const Track = components.Track === null ? () => null : (_components$Track = components.Track) != null ? _components$Track : "span";
      const trackProps = useSlotProps({
        elementType: Track,
        externalSlotProps: componentsProps.track,
        ownerState,
        className: classes.track
      });
      return (0, import_jsx_runtime31.jsxs)(Root, _extends({}, rootProps, {
        children: [(0, import_jsx_runtime30.jsx)(Track, _extends({}, trackProps)), (0, import_jsx_runtime30.jsx)(Thumb, _extends({}, thumbProps)), (0, import_jsx_runtime30.jsx)(Input, _extends({}, inputProps))]
      }));
    });
    true ? SwitchUnstyled.propTypes = {
      checked: import_prop_types20.default.bool,
      children: import_prop_types20.default.node,
      component: import_prop_types20.default.elementType,
      components: import_prop_types20.default.shape({
        Input: import_prop_types20.default.elementType,
        Root: import_prop_types20.default.elementType,
        Thumb: import_prop_types20.default.elementType,
        Track: import_prop_types20.default.oneOfType([import_prop_types20.default.elementType, import_prop_types20.default.oneOf([null])])
      }),
      componentsProps: import_prop_types20.default.shape({
        input: import_prop_types20.default.oneOfType([import_prop_types20.default.func, import_prop_types20.default.object]),
        root: import_prop_types20.default.oneOfType([import_prop_types20.default.func, import_prop_types20.default.object]),
        thumb: import_prop_types20.default.oneOfType([import_prop_types20.default.func, import_prop_types20.default.object]),
        track: import_prop_types20.default.oneOfType([import_prop_types20.default.func, import_prop_types20.default.object])
      }),
      defaultChecked: import_prop_types20.default.bool,
      disabled: import_prop_types20.default.bool,
      onBlur: import_prop_types20.default.func,
      onChange: import_prop_types20.default.func,
      onFocus: import_prop_types20.default.func,
      onFocusVisible: import_prop_types20.default.func,
      readOnly: import_prop_types20.default.bool,
      required: import_prop_types20.default.bool
    } : void 0;
  }
});

// node_modules/@mui/base/SwitchUnstyled/SwitchUnstyled.types.js
var init_SwitchUnstyled_types = __esm({
  "node_modules/@mui/base/SwitchUnstyled/SwitchUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/SwitchUnstyled/useSwitch.types.js
var init_useSwitch_types = __esm({
  "node_modules/@mui/base/SwitchUnstyled/useSwitch.types.js"() {
  }
});

// node_modules/@mui/base/SwitchUnstyled/index.js
var init_SwitchUnstyled2 = __esm({
  "node_modules/@mui/base/SwitchUnstyled/index.js"() {
    init_SwitchUnstyled();
    init_SwitchUnstyled_types();
    init_useSwitch();
    init_useSwitch_types();
    init_switchUnstyledClasses();
    init_switchUnstyledClasses();
  }
});

// node_modules/@mui/base/TablePaginationUnstyled/TablePaginationActionsUnstyled.js
function defaultGetAriaLabel(type) {
  return `Go to ${type} page`;
}
var React36, import_jsx_runtime32, import_jsx_runtime33, _excluded18, _span, _span2, _span3, _span4, LastPageIconDefault, FirstPageIconDefault, NextPageIconDefault, BackPageIconDefault, TablePaginationActionsUnstyled, TablePaginationActionsUnstyled_default;
var init_TablePaginationActionsUnstyled = __esm({
  "node_modules/@mui/base/TablePaginationUnstyled/TablePaginationActionsUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React36 = __toESM(require_react());
    init_utils();
    import_jsx_runtime32 = __toESM(require_jsx_runtime());
    import_jsx_runtime33 = __toESM(require_jsx_runtime());
    _excluded18 = ["component", "components", "componentsProps", "count", "getItemAriaLabel", "onPageChange", "page", "rowsPerPage", "showFirstButton", "showLastButton", "direction", "ownerState"];
    LastPageIconDefault = () => _span || (_span = (0, import_jsx_runtime32.jsx)("span", {
      children: "\u21FE|"
    }));
    FirstPageIconDefault = () => _span2 || (_span2 = (0, import_jsx_runtime32.jsx)("span", {
      children: "|\u21FD"
    }));
    NextPageIconDefault = () => _span3 || (_span3 = (0, import_jsx_runtime32.jsx)("span", {
      children: "\u21FE"
    }));
    BackPageIconDefault = () => _span4 || (_span4 = (0, import_jsx_runtime32.jsx)("span", {
      children: "\u21FD"
    }));
    TablePaginationActionsUnstyled = React36.forwardRef(function TablePaginationActionsUnstyled2(props, ref) {
      var _ref, _components$Root, _components$FirstButt, _components$LastButto, _components$NextButto, _components$BackButto, _components$LastPageI, _components$FirstPage, _components$NextPageI, _components$BackPageI;
      const {
        component,
        components = {},
        componentsProps = {},
        count,
        getItemAriaLabel = defaultGetAriaLabel,
        onPageChange,
        page,
        rowsPerPage,
        showFirstButton = false,
        showLastButton = false,
        direction
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded18);
      const ownerState = props;
      const handleFirstPageButtonClick = (event) => {
        onPageChange(event, 0);
      };
      const handleBackButtonClick = (event) => {
        onPageChange(event, page - 1);
      };
      const handleNextButtonClick = (event) => {
        onPageChange(event, page + 1);
      };
      const handleLastPageButtonClick = (event) => {
        onPageChange(event, Math.max(0, Math.ceil(count / rowsPerPage) - 1));
      };
      const Root = (_ref = (_components$Root = components.Root) != null ? _components$Root : component) != null ? _ref : "div";
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref
        },
        ownerState
      });
      const FirstButton = (_components$FirstButt = components.FirstButton) != null ? _components$FirstButt : "button";
      const firstButtonProps = useSlotProps({
        elementType: FirstButton,
        externalSlotProps: componentsProps.firstButton,
        additionalProps: {
          onClick: handleFirstPageButtonClick,
          disabled: page === 0,
          "aria-label": getItemAriaLabel("first", page),
          title: getItemAriaLabel("first", page)
        },
        ownerState
      });
      const LastButton = (_components$LastButto = components.LastButton) != null ? _components$LastButto : "button";
      const lastButtonProps = useSlotProps({
        elementType: LastButton,
        externalSlotProps: componentsProps.lastButton,
        additionalProps: {
          onClick: handleLastPageButtonClick,
          disabled: page >= Math.ceil(count / rowsPerPage) - 1,
          "aria-label": getItemAriaLabel("last", page),
          title: getItemAriaLabel("last", page)
        },
        ownerState
      });
      const NextButton = (_components$NextButto = components.NextButton) != null ? _components$NextButto : "button";
      const nextButtonProps = useSlotProps({
        elementType: NextButton,
        externalSlotProps: componentsProps.nextButton,
        additionalProps: {
          onClick: handleNextButtonClick,
          disabled: count !== -1 ? page >= Math.ceil(count / rowsPerPage) - 1 : false,
          "aria-label": getItemAriaLabel("next", page),
          title: getItemAriaLabel("next", page)
        },
        ownerState
      });
      const BackButton = (_components$BackButto = components.BackButton) != null ? _components$BackButto : "button";
      const backButtonProps = useSlotProps({
        elementType: BackButton,
        externalSlotProps: componentsProps.backButton,
        additionalProps: {
          onClick: handleBackButtonClick,
          disabled: page === 0,
          "aria-label": getItemAriaLabel("previous", page),
          title: getItemAriaLabel("previous", page)
        },
        ownerState
      });
      const LastPageIcon = (_components$LastPageI = components.LastPageIcon) != null ? _components$LastPageI : LastPageIconDefault;
      const FirstPageIcon = (_components$FirstPage = components.FirstPageIcon) != null ? _components$FirstPage : FirstPageIconDefault;
      const NextPageIcon = (_components$NextPageI = components.NextPageIcon) != null ? _components$NextPageI : NextPageIconDefault;
      const BackPageIcon = (_components$BackPageI = components.BackPageIcon) != null ? _components$BackPageI : BackPageIconDefault;
      return (0, import_jsx_runtime33.jsxs)(Root, _extends({}, rootProps, {
        children: [showFirstButton && (0, import_jsx_runtime32.jsx)(FirstButton, _extends({}, firstButtonProps, {
          children: direction === "rtl" ? (0, import_jsx_runtime32.jsx)(LastPageIcon, {}) : (0, import_jsx_runtime32.jsx)(FirstPageIcon, {})
        })), (0, import_jsx_runtime32.jsx)(BackButton, _extends({}, backButtonProps, {
          children: direction === "rtl" ? (0, import_jsx_runtime32.jsx)(NextPageIcon, {}) : (0, import_jsx_runtime32.jsx)(BackPageIcon, {})
        })), (0, import_jsx_runtime32.jsx)(NextButton, _extends({}, nextButtonProps, {
          children: direction === "rtl" ? (0, import_jsx_runtime32.jsx)(BackPageIcon, {}) : (0, import_jsx_runtime32.jsx)(NextPageIcon, {})
        })), showLastButton && (0, import_jsx_runtime32.jsx)(LastButton, _extends({}, lastButtonProps, {
          children: direction === "rtl" ? (0, import_jsx_runtime32.jsx)(FirstPageIcon, {}) : (0, import_jsx_runtime32.jsx)(LastPageIcon, {})
        }))]
      }));
    });
    TablePaginationActionsUnstyled_default = TablePaginationActionsUnstyled;
  }
});

// node_modules/@mui/base/TablePaginationUnstyled/tablePaginationUnstyledClasses.js
function getTablePaginationUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiTablePaginationUnstyled", slot);
}
var tablePaginationClasses;
var init_tablePaginationUnstyledClasses = __esm({
  "node_modules/@mui/base/TablePaginationUnstyled/tablePaginationUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    tablePaginationClasses = generateUtilityClasses("MuiTablePaginationUnstyled", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]);
  }
});

// node_modules/@mui/base/TablePaginationUnstyled/TablePaginationUnstyled.js
function defaultLabelDisplayedRows({
  from,
  to,
  count
}) {
  return `${from}\u2013${to} of ${count !== -1 ? count : `more than ${to}`}`;
}
function defaultGetAriaLabel2(type) {
  return `Go to ${type} page`;
}
var React37, import_prop_types21, import_jsx_runtime34, import_react4, import_jsx_runtime35, _excluded19, useUtilityClasses12, TablePaginationUnstyled;
var init_TablePaginationUnstyled = __esm({
  "node_modules/@mui/base/TablePaginationUnstyled/TablePaginationUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React37 = __toESM(require_react());
    import_prop_types21 = __toESM(require_prop_types());
    init_esm();
    init_utils();
    init_composeClasses();
    init_isHostComponent();
    init_TablePaginationActionsUnstyled();
    init_tablePaginationUnstyledClasses();
    import_jsx_runtime34 = __toESM(require_jsx_runtime());
    import_react4 = __toESM(require_react());
    import_jsx_runtime35 = __toESM(require_jsx_runtime());
    _excluded19 = ["component", "components", "componentsProps", "colSpan", "count", "getItemAriaLabel", "labelDisplayedRows", "labelId", "labelRowsPerPage", "onPageChange", "onRowsPerPageChange", "page", "rowsPerPage", "rowsPerPageOptions", "selectId"];
    useUtilityClasses12 = () => {
      const slots = {
        root: ["root"],
        toolbar: ["toolbar"],
        spacer: ["spacer"],
        selectLabel: ["selectLabel"],
        select: ["select"],
        input: ["input"],
        selectIcon: ["selectIcon"],
        menuItem: ["menuItem"],
        displayedRows: ["displayedRows"],
        actions: ["actions"]
      };
      return composeClasses(slots, getTablePaginationUnstyledUtilityClass, {});
    };
    TablePaginationUnstyled = React37.forwardRef(function TablePaginationUnstyled2(props, ref) {
      var _ref, _components$Select, _components$Actions, _components$MenuItem, _components$SelectLab, _components$Displayed, _components$Toolbar, _components$Spacer;
      const {
        component,
        components = {},
        componentsProps = {},
        colSpan: colSpanProp,
        count,
        getItemAriaLabel = defaultGetAriaLabel2,
        labelDisplayedRows = defaultLabelDisplayedRows,
        labelId: labelIdProp,
        labelRowsPerPage = "Rows per page:",
        onPageChange,
        onRowsPerPageChange,
        page,
        rowsPerPage,
        rowsPerPageOptions = [10, 25, 50, 100],
        selectId: selectIdProp
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded19);
      const ownerState = props;
      const classes = useUtilityClasses12();
      let colSpan;
      if (!component || component === "td" || !isHostComponent_default(component)) {
        colSpan = colSpanProp || 1e3;
      }
      const getLabelDisplayedRowsTo = () => {
        if (count === -1) {
          return (page + 1) * rowsPerPage;
        }
        return rowsPerPage === -1 ? count : Math.min(count, (page + 1) * rowsPerPage);
      };
      const selectId = useId(selectIdProp);
      const labelId = useId(labelIdProp);
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "td";
      const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          colSpan,
          ref
        },
        ownerState,
        className: classes.root
      });
      const Select = (_components$Select = components.Select) != null ? _components$Select : "select";
      const selectProps = useSlotProps({
        elementType: Select,
        externalSlotProps: componentsProps.select,
        additionalProps: {
          value: rowsPerPage,
          id: selectId,
          onChange: (e) => onRowsPerPageChange && onRowsPerPageChange(e),
          "aria-label": rowsPerPage.toString(),
          "aria-labelledby": [labelId, selectId].filter(Boolean).join(" ") || void 0
        },
        ownerState,
        className: classes.select
      });
      const Actions = (_components$Actions = components.Actions) != null ? _components$Actions : TablePaginationActionsUnstyled_default;
      const actionsProps = useSlotProps({
        elementType: Actions,
        externalSlotProps: componentsProps.actions,
        additionalProps: {
          page,
          rowsPerPage,
          count,
          onPageChange,
          getItemAriaLabel
        },
        ownerState,
        className: classes.actions
      });
      const MenuItem = (_components$MenuItem = components.MenuItem) != null ? _components$MenuItem : "option";
      const menuItemProps = useSlotProps({
        elementType: MenuItem,
        externalSlotProps: componentsProps.menuItem,
        additionalProps: {
          value: void 0
        },
        ownerState,
        className: classes.menuItem
      });
      const SelectLabel = (_components$SelectLab = components.SelectLabel) != null ? _components$SelectLab : "p";
      const selectLabelProps = useSlotProps({
        elementType: SelectLabel,
        externalSlotProps: componentsProps.selectLabel,
        additionalProps: {
          id: labelId
        },
        ownerState,
        className: classes.selectLabel
      });
      const DisplayedRows = (_components$Displayed = components.DisplayedRows) != null ? _components$Displayed : "p";
      const displayedRowsProps = useSlotProps({
        elementType: DisplayedRows,
        externalSlotProps: componentsProps.displayedRows,
        ownerState,
        className: classes.displayedRows
      });
      const Toolbar = (_components$Toolbar = components.Toolbar) != null ? _components$Toolbar : "div";
      const toolbarProps = useSlotProps({
        elementType: Toolbar,
        externalSlotProps: componentsProps.toolbar,
        ownerState,
        className: classes.toolbar
      });
      const Spacer = (_components$Spacer = components.Spacer) != null ? _components$Spacer : "div";
      const spacerProps = useSlotProps({
        elementType: Spacer,
        externalSlotProps: componentsProps.spacer,
        ownerState,
        className: classes.spacer
      });
      return (0, import_jsx_runtime34.jsx)(Root, _extends({}, rootProps, {
        children: (0, import_jsx_runtime35.jsxs)(Toolbar, _extends({}, toolbarProps, {
          children: [(0, import_jsx_runtime34.jsx)(Spacer, _extends({}, spacerProps)), rowsPerPageOptions.length > 1 && (0, import_jsx_runtime34.jsx)(SelectLabel, _extends({}, selectLabelProps, {
            children: labelRowsPerPage
          })), rowsPerPageOptions.length > 1 && (0, import_jsx_runtime34.jsx)(Select, _extends({}, selectProps, {
            children: rowsPerPageOptions.map((rowsPerPageOption) => (0, import_react4.createElement)(MenuItem, _extends({}, menuItemProps, {
              key: typeof rowsPerPageOption !== "number" && rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption,
              value: typeof rowsPerPageOption !== "number" && rowsPerPageOption.value ? rowsPerPageOption.value : rowsPerPageOption
            }), typeof rowsPerPageOption !== "number" && rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption))
          })), (0, import_jsx_runtime34.jsx)(DisplayedRows, _extends({}, displayedRowsProps, {
            children: labelDisplayedRows({
              from: count === 0 ? 0 : page * rowsPerPage + 1,
              to: getLabelDisplayedRowsTo(),
              count: count === -1 ? -1 : count,
              page
            })
          })), (0, import_jsx_runtime34.jsx)(Actions, _extends({}, actionsProps))]
        }))
      }));
    });
    true ? TablePaginationUnstyled.propTypes = {
      children: import_prop_types21.default.node,
      colSpan: import_prop_types21.default.number,
      component: import_prop_types21.default.elementType,
      components: import_prop_types21.default.shape({
        Actions: import_prop_types21.default.elementType,
        DisplayedRows: import_prop_types21.default.elementType,
        MenuItem: import_prop_types21.default.elementType,
        Root: import_prop_types21.default.elementType,
        Select: import_prop_types21.default.elementType,
        SelectLabel: import_prop_types21.default.elementType,
        Spacer: import_prop_types21.default.elementType,
        Toolbar: import_prop_types21.default.elementType
      }),
      componentsProps: import_prop_types21.default.shape({
        actions: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
        displayedRows: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
        menuItem: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
        root: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
        select: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
        selectLabel: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
        spacer: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object]),
        toolbar: import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object])
      }),
      count: import_prop_types21.default.number.isRequired,
      getItemAriaLabel: import_prop_types21.default.func,
      labelDisplayedRows: import_prop_types21.default.func,
      labelId: import_prop_types21.default.string,
      labelRowsPerPage: import_prop_types21.default.node,
      onPageChange: import_prop_types21.default.func.isRequired,
      onRowsPerPageChange: import_prop_types21.default.func,
      page: chainPropTypes(integerPropType_default.isRequired, (props) => {
        const {
          count,
          page,
          rowsPerPage
        } = props;
        if (count === -1) {
          return null;
        }
        const newLastPage = Math.max(0, Math.ceil(count / rowsPerPage) - 1);
        if (page < 0 || page > newLastPage) {
          return new Error(`MUI: The page prop of a TablePaginationUnstyled is out of range (0 to ${newLastPage}, but page is ${page}).`);
        }
        return null;
      }),
      rowsPerPage: integerPropType_default.isRequired,
      rowsPerPageOptions: import_prop_types21.default.arrayOf(import_prop_types21.default.oneOfType([import_prop_types21.default.number, import_prop_types21.default.shape({
        label: import_prop_types21.default.string.isRequired,
        value: import_prop_types21.default.number.isRequired
      })]).isRequired),
      selectId: import_prop_types21.default.string
    } : void 0;
  }
});

// node_modules/@mui/base/TablePaginationUnstyled/TablePaginationUnstyled.types.js
var init_TablePaginationUnstyled_types = __esm({
  "node_modules/@mui/base/TablePaginationUnstyled/TablePaginationUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TablePaginationUnstyled/TablePaginationActionsUnstyled.types.js
var init_TablePaginationActionsUnstyled_types = __esm({
  "node_modules/@mui/base/TablePaginationUnstyled/TablePaginationActionsUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TablePaginationUnstyled/index.js
var init_TablePaginationUnstyled2 = __esm({
  "node_modules/@mui/base/TablePaginationUnstyled/index.js"() {
    init_TablePaginationUnstyled();
    init_TablePaginationUnstyled_types();
    init_TablePaginationActionsUnstyled();
    init_TablePaginationActionsUnstyled_types();
    init_tablePaginationUnstyledClasses();
    init_tablePaginationUnstyledClasses();
  }
});

// node_modules/@mui/base/TabPanelUnstyled/tabPanelUnstyledClasses.js
function getTabPanelUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabPanelUnstyled", slot);
}
var tabPanelUnstyledClasses;
var init_tabPanelUnstyledClasses = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/tabPanelUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    tabPanelUnstyledClasses = generateUtilityClasses("TabPanelUnstyled", ["root", "hidden"]);
  }
});

// node_modules/@mui/base/TabsUnstyled/tabsUnstyledClasses.js
function getTabsUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabsUnstyled", slot);
}
var tabsUnstyledClasses;
var init_tabsUnstyledClasses = __esm({
  "node_modules/@mui/base/TabsUnstyled/tabsUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    tabsUnstyledClasses = generateUtilityClasses("TabsUnstyled", ["root", "horizontal", "vertical"]);
  }
});

// node_modules/@mui/base/TabsUnstyled/useTabs.js
var React38, useTabs, useTabs_default;
var init_useTabs = __esm({
  "node_modules/@mui/base/TabsUnstyled/useTabs.js"() {
    React38 = __toESM(require_react());
    init_esm();
    useTabs = (parameters) => {
      const {
        value: valueProp,
        defaultValue,
        onChange,
        orientation,
        direction,
        selectionFollowsFocus
      } = parameters;
      const [value, setValue] = useControlled({
        controlled: valueProp,
        default: defaultValue,
        name: "Tabs",
        state: "value"
      });
      const idPrefix = useId();
      const onSelected = React38.useCallback((e, newValue) => {
        setValue(newValue);
        if (onChange) {
          onChange(e, newValue);
        }
      }, [onChange, setValue]);
      const tabsContextValue = React38.useMemo(() => {
        return {
          idPrefix,
          value,
          onSelected,
          orientation,
          direction,
          selectionFollowsFocus
        };
      }, [idPrefix, value, onSelected, orientation, direction, selectionFollowsFocus]);
      return {
        tabsContextValue
      };
    };
    useTabs_default = useTabs;
  }
});

// node_modules/@mui/base/TabsUnstyled/TabsContext.js
function useTabContext() {
  return React39.useContext(Context);
}
function getPanelId(context, value) {
  const {
    idPrefix
  } = context;
  if (idPrefix === null) {
    return null;
  }
  return `${context.idPrefix}-P-${value}`;
}
function getTabId(context, value) {
  const {
    idPrefix
  } = context;
  if (idPrefix === null) {
    return null;
  }
  return `${context.idPrefix}-T-${value}`;
}
var React39, Context, TabsContext_default;
var init_TabsContext = __esm({
  "node_modules/@mui/base/TabsUnstyled/TabsContext.js"() {
    React39 = __toESM(require_react());
    Context = React39.createContext(null);
    if (true) {
      Context.displayName = "TabsContext";
    }
    TabsContext_default = Context;
  }
});

// node_modules/@mui/base/TabsUnstyled/TabsUnstyled.js
var React40, import_prop_types22, import_jsx_runtime36, _excluded20, useUtilityClasses13, TabsUnstyled;
var init_TabsUnstyled = __esm({
  "node_modules/@mui/base/TabsUnstyled/TabsUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React40 = __toESM(require_react());
    import_prop_types22 = __toESM(require_prop_types());
    init_utils();
    init_composeClasses();
    init_tabsUnstyledClasses();
    init_useTabs();
    init_TabsContext();
    import_jsx_runtime36 = __toESM(require_jsx_runtime());
    _excluded20 = ["children", "value", "defaultValue", "orientation", "direction", "component", "components", "componentsProps", "onChange", "selectionFollowsFocus"];
    useUtilityClasses13 = (ownerState) => {
      const {
        orientation
      } = ownerState;
      const slots = {
        root: ["root", orientation]
      };
      return composeClasses(slots, getTabsUnstyledUtilityClass, {});
    };
    TabsUnstyled = React40.forwardRef((props, ref) => {
      var _ref;
      const {
        children,
        orientation = "horizontal",
        direction = "ltr",
        component,
        components = {},
        componentsProps = {}
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded20);
      const {
        tabsContextValue
      } = useTabs_default(props);
      const ownerState = _extends({}, props, {
        orientation,
        direction
      });
      const classes = useUtilityClasses13(ownerState);
      const TabsRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
      const tabsRootProps = useSlotProps({
        elementType: TabsRoot,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref
        },
        ownerState,
        className: classes.root
      });
      return (0, import_jsx_runtime36.jsx)(TabsRoot, _extends({}, tabsRootProps, {
        children: (0, import_jsx_runtime36.jsx)(TabsContext_default.Provider, {
          value: tabsContextValue,
          children
        })
      }));
    });
    true ? TabsUnstyled.propTypes = {
      children: import_prop_types22.default.node,
      component: import_prop_types22.default.elementType,
      components: import_prop_types22.default.shape({
        Root: import_prop_types22.default.elementType
      }),
      componentsProps: import_prop_types22.default.shape({
        root: import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object])
      }),
      defaultValue: import_prop_types22.default.oneOfType([import_prop_types22.default.oneOf([false]), import_prop_types22.default.number, import_prop_types22.default.string]),
      direction: import_prop_types22.default.oneOf(["ltr", "rtl"]),
      onChange: import_prop_types22.default.func,
      orientation: import_prop_types22.default.oneOf(["horizontal", "vertical"]),
      selectionFollowsFocus: import_prop_types22.default.bool,
      value: import_prop_types22.default.oneOfType([import_prop_types22.default.oneOf([false]), import_prop_types22.default.number, import_prop_types22.default.string])
    } : void 0;
  }
});

// node_modules/@mui/base/TabsUnstyled/TabsUnstyled.types.js
var init_TabsUnstyled_types = __esm({
  "node_modules/@mui/base/TabsUnstyled/TabsUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TabsUnstyled/index.js
var init_TabsUnstyled2 = __esm({
  "node_modules/@mui/base/TabsUnstyled/index.js"() {
    init_TabsUnstyled();
    init_TabsContext();
    init_TabsContext();
    init_tabsUnstyledClasses();
    init_tabsUnstyledClasses();
    init_TabsUnstyled_types();
    init_useTabs();
    init_useTabs();
  }
});

// node_modules/@mui/base/TabPanelUnstyled/useTabPanel.js
var useTabPanel, useTabPanel_default;
var init_useTabPanel = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/useTabPanel.js"() {
    init_TabsUnstyled2();
    useTabPanel = (parameters) => {
      const {
        value
      } = parameters;
      const context = useTabContext();
      if (context === null) {
        throw new Error("No TabContext provided");
      }
      const hidden = value !== context.value;
      const id = getPanelId(context, value);
      const tabId = getTabId(context, value);
      const getRootProps = () => {
        return {
          "aria-labelledby": tabId != null ? tabId : void 0,
          hidden,
          id: id != null ? id : void 0
        };
      };
      return {
        hidden,
        getRootProps
      };
    };
    useTabPanel_default = useTabPanel;
  }
});

// node_modules/@mui/base/TabPanelUnstyled/TabPanelUnstyled.js
var React41, import_prop_types23, import_jsx_runtime37, _excluded21, useUtilityClasses14, TabPanelUnstyled;
var init_TabPanelUnstyled = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/TabPanelUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React41 = __toESM(require_react());
    import_prop_types23 = __toESM(require_prop_types());
    init_utils();
    init_composeClasses();
    init_tabPanelUnstyledClasses();
    init_useTabPanel();
    import_jsx_runtime37 = __toESM(require_jsx_runtime());
    _excluded21 = ["children", "value", "components", "componentsProps", "component"];
    useUtilityClasses14 = (ownerState) => {
      const {
        hidden
      } = ownerState;
      const slots = {
        root: ["root", hidden && "hidden"]
      };
      return composeClasses(slots, getTabPanelUnstyledUtilityClass, {});
    };
    TabPanelUnstyled = React41.forwardRef(function TabPanelUnstyled2(props, ref) {
      var _ref;
      const {
        children,
        components = {},
        componentsProps = {},
        component
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded21);
      const {
        hidden,
        getRootProps
      } = useTabPanel_default(props);
      const ownerState = _extends({}, props, {
        hidden
      });
      const classes = useUtilityClasses14(ownerState);
      const TabPanelRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
      const tabPanelRootProps = useSlotProps({
        elementType: TabPanelRoot,
        getSlotProps: getRootProps,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          role: "tabpanel",
          ref
        },
        ownerState,
        className: classes.root
      });
      return (0, import_jsx_runtime37.jsx)(TabPanelRoot, _extends({}, tabPanelRootProps, {
        children: !hidden && children
      }));
    });
    true ? TabPanelUnstyled.propTypes = {
      children: import_prop_types23.default.node,
      component: import_prop_types23.default.elementType,
      components: import_prop_types23.default.shape({
        Root: import_prop_types23.default.elementType
      }),
      componentsProps: import_prop_types23.default.shape({
        root: import_prop_types23.default.oneOfType([import_prop_types23.default.func, import_prop_types23.default.object])
      }),
      value: import_prop_types23.default.oneOfType([import_prop_types23.default.number, import_prop_types23.default.string]).isRequired
    } : void 0;
  }
});

// node_modules/@mui/base/TabPanelUnstyled/TabPanelUnstyled.types.js
var init_TabPanelUnstyled_types = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/TabPanelUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TabPanelUnstyled/index.js
var init_TabPanelUnstyled2 = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/index.js"() {
    init_TabPanelUnstyled();
    init_TabPanelUnstyled_types();
    init_tabPanelUnstyledClasses();
    init_tabPanelUnstyledClasses();
    init_useTabPanel();
  }
});

// node_modules/@mui/base/TabsListUnstyled/tabsListUnstyledClasses.js
function getTabsListUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabsListUnstyled", slot);
}
var tabsListUnstyledClasses;
var init_tabsListUnstyledClasses = __esm({
  "node_modules/@mui/base/TabsListUnstyled/tabsListUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    tabsListUnstyledClasses = generateUtilityClasses("TabsListUnstyled", ["root", "horizontal", "vertical"]);
  }
});

// node_modules/@mui/base/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/@mui/base/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment10 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal3 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment2(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment10;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal3;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment2;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/@mui/base/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/@mui/base/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/@mui/base/TabsListUnstyled/useTabsList.js
var React42, import_react_is, nextItem, previousItem, moveFocus, useTabsList, useTabsList_default;
var init_useTabsList = __esm({
  "node_modules/@mui/base/TabsListUnstyled/useTabsList.js"() {
    init_extends();
    React42 = __toESM(require_react());
    init_esm();
    import_react_is = __toESM(require_react_is());
    init_TabsUnstyled2();
    init_extractEventHandlers();
    nextItem = (list, item) => {
      if (!list) {
        return null;
      }
      if (list === item) {
        return list.firstChild;
      }
      if (item && item.nextElementSibling) {
        return item.nextElementSibling;
      }
      return list.firstChild;
    };
    previousItem = (list, item) => {
      if (!list) {
        return null;
      }
      if (list === item) {
        return list.lastChild;
      }
      if (item && item.previousElementSibling) {
        return item.previousElementSibling;
      }
      return list.lastChild;
    };
    moveFocus = (list, currentFocus, traversalFunction) => {
      let wrappedOnce = false;
      let nextFocus = traversalFunction(list, currentFocus);
      while (list && nextFocus) {
        if (nextFocus === list.firstChild) {
          if (wrappedOnce) {
            return;
          }
          wrappedOnce = true;
        }
        const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
        if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
          nextFocus = traversalFunction(list, nextFocus);
        } else {
          nextFocus.focus();
          return;
        }
      }
    };
    useTabsList = (parameters) => {
      const {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        children,
        ref
      } = parameters;
      const tabsListRef = React42.createRef();
      const handleRef = useForkRef(tabsListRef, ref);
      const context = useTabContext();
      if (context === null) {
        throw new Error("No TabContext provided");
      }
      const {
        value,
        orientation = "horizontal",
        direction = "ltr"
      } = context;
      const isRtl = direction === "rtl";
      const handleKeyDown2 = (event) => {
        const list = tabsListRef.current;
        const currentFocus = ownerDocument(list).activeElement;
        const role = currentFocus == null ? void 0 : currentFocus.getAttribute("role");
        if (role !== "tab") {
          return;
        }
        let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
        let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
        if (orientation === "horizontal" && isRtl) {
          previousItemKey = "ArrowRight";
          nextItemKey = "ArrowLeft";
        }
        switch (event.key) {
          case previousItemKey:
            event.preventDefault();
            moveFocus(list, currentFocus, previousItem);
            break;
          case nextItemKey:
            event.preventDefault();
            moveFocus(list, currentFocus, nextItem);
            break;
          case "Home":
            event.preventDefault();
            moveFocus(list, null, nextItem);
            break;
          case "End":
            event.preventDefault();
            moveFocus(list, null, previousItem);
            break;
          default:
            break;
        }
      };
      const createHandleKeyDown = (otherHandlers) => (event) => {
        var _otherHandlers$onKeyD;
        handleKeyDown2(event);
        (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);
      };
      const getRootProps = (otherHandlers = {}) => {
        const propsEventHandlers = extractEventHandlers(parameters);
        const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);
        const ownEventHandlers = {
          onKeyDown: createHandleKeyDown(externalEventHandlers)
        };
        const mergedEventHandlers = _extends({}, externalEventHandlers, ownEventHandlers);
        return _extends({
          "aria-label": ariaLabel,
          "aria-labelledby": ariaLabelledBy,
          "aria-orientation": orientation === "vertical" ? "vertical" : void 0,
          role: "tablist",
          ref: handleRef
        }, mergedEventHandlers);
      };
      const processChildren = React42.useCallback(() => {
        const valueToIndex = /* @__PURE__ */ new Map();
        let childIndex = 0;
        const processedChildren = React42.Children.map(children, (child) => {
          if (!React42.isValidElement(child)) {
            return null;
          }
          if (true) {
            if ((0, import_react_is.isFragment)(child)) {
              console.error(["MUI: The Tabs component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join("\n"));
            }
          }
          const childValue = child.props.value === void 0 ? childIndex : child.props.value;
          valueToIndex.set(childValue, childIndex);
          childIndex += 1;
          return React42.cloneElement(child, _extends({
            value: childValue
          }, childIndex === 1 && value === false && !child.props.tabIndex || value === childValue ? {
            tabIndex: 0
          } : {
            tabIndex: -1
          }));
        });
        return processedChildren;
      }, [children, value]);
      return {
        isRtl,
        orientation,
        value,
        processChildren,
        getRootProps
      };
    };
    useTabsList_default = useTabsList;
  }
});

// node_modules/@mui/base/TabsListUnstyled/TabsListUnstyled.js
var React43, import_prop_types24, import_jsx_runtime38, _excluded23, useUtilityClasses15, TabsListUnstyled;
var init_TabsListUnstyled = __esm({
  "node_modules/@mui/base/TabsListUnstyled/TabsListUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React43 = __toESM(require_react());
    import_prop_types24 = __toESM(require_prop_types());
    init_composeClasses();
    init_utils();
    init_tabsListUnstyledClasses();
    init_useTabsList();
    import_jsx_runtime38 = __toESM(require_jsx_runtime());
    _excluded23 = ["children", "component", "components", "componentsProps"];
    useUtilityClasses15 = (ownerState) => {
      const {
        orientation
      } = ownerState;
      const slots = {
        root: ["root", orientation]
      };
      return composeClasses(slots, getTabsListUnstyledUtilityClass, {});
    };
    TabsListUnstyled = React43.forwardRef((props, ref) => {
      var _ref;
      const {
        component,
        components = {},
        componentsProps = {}
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded23);
      const {
        isRtl,
        orientation,
        getRootProps,
        processChildren
      } = useTabsList_default(_extends({}, props, {
        ref
      }));
      const ownerState = _extends({}, props, {
        isRtl,
        orientation
      });
      const classes = useUtilityClasses15(ownerState);
      const TabsListRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
      const tabsListRootProps = useSlotProps({
        elementType: TabsListRoot,
        getSlotProps: getRootProps,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        ownerState,
        className: classes.root
      });
      const processedChildren = processChildren();
      return (0, import_jsx_runtime38.jsx)(TabsListRoot, _extends({}, tabsListRootProps, {
        children: processedChildren
      }));
    });
    true ? TabsListUnstyled.propTypes = {
      children: import_prop_types24.default.node,
      component: import_prop_types24.default.elementType,
      components: import_prop_types24.default.shape({
        Root: import_prop_types24.default.elementType
      }),
      componentsProps: import_prop_types24.default.shape({
        root: import_prop_types24.default.oneOfType([import_prop_types24.default.func, import_prop_types24.default.object])
      })
    } : void 0;
  }
});

// node_modules/@mui/base/TabsListUnstyled/TabsListUnstyled.types.js
var init_TabsListUnstyled_types = __esm({
  "node_modules/@mui/base/TabsListUnstyled/TabsListUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TabsListUnstyled/useTabsList.types.js
var init_useTabsList_types = __esm({
  "node_modules/@mui/base/TabsListUnstyled/useTabsList.types.js"() {
  }
});

// node_modules/@mui/base/TabsListUnstyled/index.js
var init_TabsListUnstyled2 = __esm({
  "node_modules/@mui/base/TabsListUnstyled/index.js"() {
    init_TabsListUnstyled();
    init_TabsListUnstyled_types();
    init_tabsListUnstyledClasses();
    init_tabsListUnstyledClasses();
    init_useTabsList();
    init_useTabsList_types();
  }
});

// node_modules/@mui/base/TabUnstyled/tabUnstyledClasses.js
function getTabUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabUnstyled", slot);
}
var tabUnstyledClasses;
var init_tabUnstyledClasses = __esm({
  "node_modules/@mui/base/TabUnstyled/tabUnstyledClasses.js"() {
    init_generateUtilityClass();
    init_generateUtilityClasses();
    tabUnstyledClasses = generateUtilityClasses("TabUnstyled", ["root", "selected", "disabled"]);
  }
});

// node_modules/@mui/base/TabUnstyled/useTab.js
var _excluded24, useTab, useTab_default;
var init_useTab = __esm({
  "node_modules/@mui/base/TabUnstyled/useTab.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_TabsUnstyled2();
    init_ButtonUnstyled2();
    _excluded24 = ["getRootProps"];
    useTab = (parameters) => {
      var _getPanelId, _getTabId;
      const {
        value: valueProp,
        onChange,
        onClick,
        onFocus
      } = parameters;
      const _useButton = useButton(parameters), {
        getRootProps: getRootPropsButton
      } = _useButton, otherButtonProps = _objectWithoutPropertiesLoose(_useButton, _excluded24);
      const context = useTabContext();
      if (context === null) {
        throw new Error("No TabContext provided");
      }
      const value = valueProp != null ? valueProp : 0;
      const selected = context.value === value;
      const selectionFollowsFocus = context.selectionFollowsFocus;
      const a11yAttributes = {
        role: "tab",
        "aria-controls": (_getPanelId = getPanelId(context, value)) != null ? _getPanelId : void 0,
        id: (_getTabId = getTabId(context, value)) != null ? _getTabId : void 0,
        "aria-selected": selected,
        disabled: otherButtonProps.disabled
      };
      const createHandleFocus = (otherHandlers) => (event) => {
        var _otherHandlers$onFocu;
        (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
        if (event.defaultPrevented) {
          return;
        }
        if (selectionFollowsFocus && !selected) {
          if (onChange) {
            onChange(event, value);
          }
          context.onSelected(event, value);
        }
        if (onFocus) {
          onFocus(event);
        }
      };
      const createHandleClick = (otherHandlers) => (event) => {
        var _otherHandlers$onClic;
        (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
        if (event.defaultPrevented) {
          return;
        }
        if (!selected) {
          if (onChange) {
            onChange(event, value);
          }
          context.onSelected(event, value);
        }
        if (onClick) {
          onClick(event);
        }
      };
      const getRootProps = (otherHandlers = {}) => {
        const buttonResolvedProps = getRootPropsButton(_extends({}, otherHandlers, {
          onClick: createHandleClick(otherHandlers),
          onFocus: createHandleFocus(otherHandlers)
        }));
        return _extends({}, buttonResolvedProps, a11yAttributes);
      };
      return _extends({
        getRootProps
      }, otherButtonProps, {
        selected
      });
    };
    useTab_default = useTab;
  }
});

// node_modules/@mui/base/TabUnstyled/TabUnstyled.js
var React44, import_prop_types25, import_jsx_runtime39, _excluded25, useUtilityClasses16, TabUnstyled;
var init_TabUnstyled = __esm({
  "node_modules/@mui/base/TabUnstyled/TabUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React44 = __toESM(require_react());
    import_prop_types25 = __toESM(require_prop_types());
    init_esm();
    init_composeClasses();
    init_tabUnstyledClasses();
    init_useTab();
    init_utils();
    import_jsx_runtime39 = __toESM(require_jsx_runtime());
    _excluded25 = ["action", "children", "value", "disabled", "onChange", "onClick", "onFocus", "component", "components", "componentsProps"];
    useUtilityClasses16 = (ownerState) => {
      const {
        selected,
        disabled
      } = ownerState;
      const slots = {
        root: ["root", selected && "selected", disabled && "disabled"]
      };
      return composeClasses(slots, getTabUnstyledUtilityClass, {});
    };
    TabUnstyled = React44.forwardRef(function TabUnstyled2(props, ref) {
      var _ref;
      const {
        action,
        children,
        disabled = false,
        component,
        components = {},
        componentsProps = {}
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded25);
      const tabRef = React44.useRef();
      const handleRef = useForkRef(tabRef, ref);
      const {
        active,
        focusVisible,
        setFocusVisible,
        selected,
        getRootProps
      } = useTab_default(_extends({}, props, {
        ref: handleRef
      }));
      React44.useImperativeHandle(action, () => ({
        focusVisible: () => {
          setFocusVisible(true);
          tabRef.current.focus();
        }
      }), [setFocusVisible]);
      const ownerState = _extends({}, props, {
        active,
        focusVisible,
        disabled,
        selected
      });
      const classes = useUtilityClasses16(ownerState);
      const TabRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "button";
      const tabRootProps = useSlotProps({
        elementType: TabRoot,
        getSlotProps: getRootProps,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref
        },
        ownerState,
        className: classes.root
      });
      return (0, import_jsx_runtime39.jsx)(TabRoot, _extends({}, tabRootProps, {
        children
      }));
    });
    true ? TabUnstyled.propTypes = {
      action: import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.shape({
        current: import_prop_types25.default.shape({
          focusVisible: import_prop_types25.default.func.isRequired
        })
      })]),
      children: import_prop_types25.default.node,
      component: import_prop_types25.default.elementType,
      components: import_prop_types25.default.shape({
        Root: import_prop_types25.default.elementType
      }),
      componentsProps: import_prop_types25.default.shape({
        root: import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.object])
      }),
      disabled: import_prop_types25.default.bool,
      onChange: import_prop_types25.default.func,
      onClick: import_prop_types25.default.func,
      onFocus: import_prop_types25.default.func,
      value: import_prop_types25.default.oneOfType([import_prop_types25.default.number, import_prop_types25.default.string])
    } : void 0;
  }
});

// node_modules/@mui/base/TabUnstyled/TabUnstyled.types.js
var init_TabUnstyled_types = __esm({
  "node_modules/@mui/base/TabUnstyled/TabUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TabUnstyled/useTab.types.js
var init_useTab_types = __esm({
  "node_modules/@mui/base/TabUnstyled/useTab.types.js"() {
  }
});

// node_modules/@mui/base/TabUnstyled/index.js
var init_TabUnstyled2 = __esm({
  "node_modules/@mui/base/TabUnstyled/index.js"() {
    init_TabUnstyled();
    init_TabUnstyled_types();
    init_tabUnstyledClasses();
    init_tabUnstyledClasses();
    init_useTab();
    init_useTab_types();
  }
});

// node_modules/@mui/base/index.js
var init_base = __esm({
  "node_modules/@mui/base/index.js"() {
    init_utils();
    init_AutocompleteUnstyled();
    init_BadgeUnstyled2();
    init_BadgeUnstyled2();
    init_ButtonUnstyled2();
    init_ButtonUnstyled2();
    init_ClickAwayListener2();
    init_composeClasses();
    init_generateUtilityClass();
    init_generateUtilityClass();
    init_generateUtilityClasses();
    init_FormControlUnstyled2();
    init_FormControlUnstyled2();
    init_InputUnstyled2();
    init_InputUnstyled2();
    init_ListboxUnstyled();
    init_MenuUnstyled2();
    init_MenuUnstyled2();
    init_MenuItemUnstyled2();
    init_MenuItemUnstyled2();
    init_ModalUnstyled2();
    init_ModalUnstyled2();
    init_MultiSelectUnstyled2();
    init_MultiSelectUnstyled2();
    init_NoSsr2();
    init_OptionGroupUnstyled2();
    init_OptionGroupUnstyled2();
    init_OptionUnstyled2();
    init_OptionUnstyled2();
    init_PopperUnstyled2();
    init_Portal2();
    init_SelectUnstyled2();
    init_SelectUnstyled2();
    init_SliderUnstyled2();
    init_SliderUnstyled2();
    init_SwitchUnstyled2();
    init_SwitchUnstyled2();
    init_TablePaginationUnstyled2();
    init_TablePaginationUnstyled2();
    init_TabPanelUnstyled2();
    init_TabPanelUnstyled2();
    init_TabsListUnstyled2();
    init_TabsListUnstyled2();
    init_TabsUnstyled2();
    init_TabsUnstyled2();
    init_TabUnstyled2();
    init_TabUnstyled2();
    init_TextareaAutosize2();
    init_TrapFocus2();
  }
});

// node_modules/@mui/material/esm/styles/createMixins.js
function createMixins(breakpoints, mixins) {
  return _extends({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
var init_createMixins = __esm({
  "node_modules/@mui/material/esm/styles/createMixins.js"() {
    init_extends();
  }
});

// node_modules/@mui/material/esm/colors/common.js
var common, common_default;
var init_common = __esm({
  "node_modules/@mui/material/esm/colors/common.js"() {
    common = {
      black: "#000",
      white: "#fff"
    };
    common_default = common;
  }
});

// node_modules/@mui/material/esm/colors/grey.js
var grey, grey_default;
var init_grey = __esm({
  "node_modules/@mui/material/esm/colors/grey.js"() {
    grey = {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#eeeeee",
      300: "#e0e0e0",
      400: "#bdbdbd",
      500: "#9e9e9e",
      600: "#757575",
      700: "#616161",
      800: "#424242",
      900: "#212121",
      A100: "#f5f5f5",
      A200: "#eeeeee",
      A400: "#bdbdbd",
      A700: "#616161"
    };
    grey_default = grey;
  }
});

// node_modules/@mui/material/esm/colors/purple.js
var purple, purple_default;
var init_purple = __esm({
  "node_modules/@mui/material/esm/colors/purple.js"() {
    purple = {
      50: "#f3e5f5",
      100: "#e1bee7",
      200: "#ce93d8",
      300: "#ba68c8",
      400: "#ab47bc",
      500: "#9c27b0",
      600: "#8e24aa",
      700: "#7b1fa2",
      800: "#6a1b9a",
      900: "#4a148c",
      A100: "#ea80fc",
      A200: "#e040fb",
      A400: "#d500f9",
      A700: "#aa00ff"
    };
    purple_default = purple;
  }
});

// node_modules/@mui/material/esm/colors/red.js
var red, red_default;
var init_red = __esm({
  "node_modules/@mui/material/esm/colors/red.js"() {
    red = {
      50: "#ffebee",
      100: "#ffcdd2",
      200: "#ef9a9a",
      300: "#e57373",
      400: "#ef5350",
      500: "#f44336",
      600: "#e53935",
      700: "#d32f2f",
      800: "#c62828",
      900: "#b71c1c",
      A100: "#ff8a80",
      A200: "#ff5252",
      A400: "#ff1744",
      A700: "#d50000"
    };
    red_default = red;
  }
});

// node_modules/@mui/material/esm/colors/orange.js
var orange, orange_default;
var init_orange = __esm({
  "node_modules/@mui/material/esm/colors/orange.js"() {
    orange = {
      50: "#fff3e0",
      100: "#ffe0b2",
      200: "#ffcc80",
      300: "#ffb74d",
      400: "#ffa726",
      500: "#ff9800",
      600: "#fb8c00",
      700: "#f57c00",
      800: "#ef6c00",
      900: "#e65100",
      A100: "#ffd180",
      A200: "#ffab40",
      A400: "#ff9100",
      A700: "#ff6d00"
    };
    orange_default = orange;
  }
});

// node_modules/@mui/material/esm/colors/blue.js
var blue, blue_default;
var init_blue = __esm({
  "node_modules/@mui/material/esm/colors/blue.js"() {
    blue = {
      50: "#e3f2fd",
      100: "#bbdefb",
      200: "#90caf9",
      300: "#64b5f6",
      400: "#42a5f5",
      500: "#2196f3",
      600: "#1e88e5",
      700: "#1976d2",
      800: "#1565c0",
      900: "#0d47a1",
      A100: "#82b1ff",
      A200: "#448aff",
      A400: "#2979ff",
      A700: "#2962ff"
    };
    blue_default = blue;
  }
});

// node_modules/@mui/material/esm/colors/lightBlue.js
var lightBlue, lightBlue_default;
var init_lightBlue = __esm({
  "node_modules/@mui/material/esm/colors/lightBlue.js"() {
    lightBlue = {
      50: "#e1f5fe",
      100: "#b3e5fc",
      200: "#81d4fa",
      300: "#4fc3f7",
      400: "#29b6f6",
      500: "#03a9f4",
      600: "#039be5",
      700: "#0288d1",
      800: "#0277bd",
      900: "#01579b",
      A100: "#80d8ff",
      A200: "#40c4ff",
      A400: "#00b0ff",
      A700: "#0091ea"
    };
    lightBlue_default = lightBlue;
  }
});

// node_modules/@mui/material/esm/colors/green.js
var green, green_default;
var init_green = __esm({
  "node_modules/@mui/material/esm/colors/green.js"() {
    green = {
      50: "#e8f5e9",
      100: "#c8e6c9",
      200: "#a5d6a7",
      300: "#81c784",
      400: "#66bb6a",
      500: "#4caf50",
      600: "#43a047",
      700: "#388e3c",
      800: "#2e7d32",
      900: "#1b5e20",
      A100: "#b9f6ca",
      A200: "#69f0ae",
      A400: "#00e676",
      A700: "#00c853"
    };
    green_default = green;
  }
});

// node_modules/@mui/material/esm/styles/createPalette.js
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue_default[200],
      light: blue_default[50],
      dark: blue_default[400]
    };
  }
  return {
    main: blue_default[700],
    light: blue_default[400],
    dark: blue_default[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple_default[200],
      light: purple_default[50],
      dark: purple_default[400]
    };
  }
  return {
    main: purple_default[500],
    light: purple_default[300],
    dark: purple_default[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red_default[500],
      light: red_default[300],
      dark: red_default[700]
    };
  }
  return {
    main: red_default[700],
    light: red_default[400],
    dark: red_default[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue_default[400],
      light: lightBlue_default[300],
      dark: lightBlue_default[700]
    };
  }
  return {
    main: lightBlue_default[700],
    light: lightBlue_default[500],
    dark: lightBlue_default[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green_default[400],
      light: green_default[300],
      dark: green_default[700]
    };
  }
  return {
    main: green_default[800],
    light: green_default[500],
    dark: green_default[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange_default[400],
      light: orange_default[300],
      dark: orange_default[700]
    };
  }
  return {
    main: "#ed6c02",
    light: orange_default[500],
    dark: orange_default[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette, other = _objectWithoutPropertiesLoose(palette, _excluded26);
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    if (true) {
      const contrast = getContrastRatio(background, contrastText);
      if (contrast < 3) {
        console.error([`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join("\n"));
      }
    }
    return contrastText;
  }
  const augmentColor = ({
    color,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color = _extends({}, color);
    if (!color.main && color[mainShade]) {
      color.main = color[mainShade];
    }
    if (!color.hasOwnProperty("main")) {
      throw new Error(true ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${mainShade}\` property.` : formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color.main !== "string") {
      throw new Error(true ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(color.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color.main)));
    }
    addLightOrDark(color, "light", lightShade, tonalOffset);
    addLightOrDark(color, "dark", darkShade, tonalOffset);
    if (!color.contrastText) {
      color.contrastText = getContrastText(color.main);
    }
    return color;
  };
  const modes = {
    dark,
    light
  };
  if (true) {
    if (!modes[mode]) {
      console.error(`MUI: The palette mode \`${mode}\` is not supported.`);
    }
  }
  const paletteOutput = deepmerge(_extends({
    common: _extends({}, common_default),
    mode,
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    error: augmentColor({
      color: error,
      name: "error"
    }),
    warning: augmentColor({
      color: warning,
      name: "warning"
    }),
    info: augmentColor({
      color: info,
      name: "info"
    }),
    success: augmentColor({
      color: success,
      name: "success"
    }),
    grey: grey_default,
    contrastThreshold,
    getContrastText,
    augmentColor,
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}
var _excluded26, light, dark;
var init_createPalette = __esm({
  "node_modules/@mui/material/esm/styles/createPalette.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm();
    init_esm();
    init_esm2();
    init_common();
    init_grey();
    init_purple();
    init_red();
    init_orange();
    init_blue();
    init_lightBlue();
    init_green();
    _excluded26 = ["mode", "contrastThreshold", "tonalOffset"];
    light = {
      text: {
        primary: "rgba(0, 0, 0, 0.87)",
        secondary: "rgba(0, 0, 0, 0.6)",
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      divider: "rgba(0, 0, 0, 0.12)",
      background: {
        paper: common_default.white,
        default: common_default.white
      },
      action: {
        active: "rgba(0, 0, 0, 0.54)",
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        disabled: "rgba(0, 0, 0, 0.26)",
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    };
    dark = {
      text: {
        primary: common_default.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: common_default.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
  }
});

// node_modules/@mui/material/esm/styles/createTypography.js
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
function createTypography(palette, typography) {
  const _ref = typeof typography === "function" ? typography(palette) : typography, {
    fontFamily = defaultFontFamily,
    fontSize = 14,
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    htmlFontSize = 16,
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded27);
  if (true) {
    if (typeof fontSize !== "number") {
      console.error("MUI: `fontSize` is required to be a number.");
    }
    if (typeof htmlFontSize !== "number") {
      console.error("MUI: `htmlFontSize` is required to be a number.");
    }
  }
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round(letterSpacing / size)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
  };
  return deepmerge(_extends({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
  });
}
var _excluded27, caseAllCaps, defaultFontFamily;
var init_createTypography = __esm({
  "node_modules/@mui/material/esm/styles/createTypography.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm();
    _excluded27 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
    caseAllCaps = {
      textTransform: "uppercase"
    };
    defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
  }
});

// node_modules/@mui/material/esm/styles/shadows.js
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
var shadowKeyUmbraOpacity, shadowKeyPenumbraOpacity, shadowAmbientShadowOpacity, shadows, shadows_default;
var init_shadows = __esm({
  "node_modules/@mui/material/esm/styles/shadows.js"() {
    shadowKeyUmbraOpacity = 0.2;
    shadowKeyPenumbraOpacity = 0.14;
    shadowAmbientShadowOpacity = 0.12;
    shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
    shadows_default = shadows;
  }
});

// node_modules/@mui/material/esm/styles/zIndex.js
var zIndex, zIndex_default;
var init_zIndex = __esm({
  "node_modules/@mui/material/esm/styles/zIndex.js"() {
    zIndex = {
      mobileStepper: 1e3,
      fab: 1050,
      speedDial: 1050,
      appBar: 1100,
      drawer: 1200,
      modal: 1300,
      snackbar: 1400,
      tooltip: 1500
    };
    zIndex_default = zIndex;
  }
});

// node_modules/@mui/material/esm/styles/createTheme.js
function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded28);
  if (options.vars) {
    throw new Error(true ? `MUI: \`vars\` is a private field used for CSS variables support.
Please use another name.` : formatMuiErrorMessage(18));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme_default(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    shadows: shadows_default.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends({}, zIndex_default)
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  if (true) {
    const stateClasses = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"];
    const traverse = (node, component) => {
      let key;
      for (key in node) {
        const child = node[key];
        if (stateClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
          if (true) {
            const stateClass = generateUtilityClass("", key);
            console.error([`MUI: The \`${component}\` component increases the CSS specificity of the \`${key}\` internal state.`, "You can not override it like this: ", JSON.stringify(node, null, 2), "", `Instead, you need to use the '&.${stateClass}' syntax:`, JSON.stringify({
              root: {
                [`&.${stateClass}`]: child
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join("\n"));
          }
          node[key] = {};
        }
      }
    };
    Object.keys(muiTheme.components).forEach((component) => {
      const styleOverrides = muiTheme.components[component].styleOverrides;
      if (styleOverrides && component.indexOf("Mui") === 0) {
        traverse(styleOverrides, component);
      }
    });
  }
  return muiTheme;
}
function createMuiTheme(...args) {
  if (true) {
    if (!warnedOnce) {
      warnedOnce = true;
      console.error(["MUI: the createMuiTheme function was renamed to createTheme.", "", "You should use `import { createTheme } from '@mui/material/styles'`"].join("\n"));
    }
  }
  return createTheme(...args);
}
var _excluded28, warnedOnce, createTheme_default2;
var init_createTheme = __esm({
  "node_modules/@mui/material/esm/styles/createTheme.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm();
    init_esm();
    init_base();
    init_esm2();
    init_createMixins();
    init_createPalette();
    init_createTypography();
    init_shadows();
    init_createTransitions();
    init_zIndex();
    _excluded28 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
    warnedOnce = false;
    createTheme_default2 = createTheme;
  }
});

// node_modules/@mui/material/esm/styles/defaultTheme.js
var defaultTheme, defaultTheme_default;
var init_defaultTheme = __esm({
  "node_modules/@mui/material/esm/styles/defaultTheme.js"() {
    init_createTheme();
    defaultTheme = createTheme_default2();
    defaultTheme_default = defaultTheme;
  }
});

// node_modules/@mui/material/esm/styles/useThemeProps.js
function useThemeProps2({
  props,
  name
}) {
  return useThemeProps({
    props,
    name,
    defaultTheme: defaultTheme_default
  });
}
var init_useThemeProps = __esm({
  "node_modules/@mui/material/esm/styles/useThemeProps.js"() {
    init_esm2();
    init_defaultTheme();
  }
});

// node_modules/@mui/material/esm/styles/styled.js
var rootShouldForwardProp, slotShouldForwardProp, styled, styled_default;
var init_styled = __esm({
  "node_modules/@mui/material/esm/styles/styled.js"() {
    init_esm2();
    init_defaultTheme();
    rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes";
    slotShouldForwardProp = shouldForwardProp;
    styled = createStyled({
      defaultTheme: defaultTheme_default,
      rootShouldForwardProp
    });
    styled_default = styled;
  }
});

export {
  isHostComponent_default,
  appendOwnerState,
  resolveComponentProps,
  init_utils,
  createFilterOptions,
  useAutocomplete,
  init_AutocompleteUnstyled,
  init_composeClasses,
  init_generateUtilityClasses,
  init_generateUtilityClass,
  BadgeUnstyled_default,
  init_BadgeUnstyled2 as init_BadgeUnstyled,
  ClickAwayListener_default,
  init_ClickAwayListener2 as init_ClickAwayListener,
  Portal_default,
  init_Portal2 as init_Portal,
  PopperUnstyled_default,
  init_PopperUnstyled2 as init_PopperUnstyled,
  ModalManager,
  getModalUtilityClass,
  modalUnstyledClasses_default,
  ModalUnstyled_default,
  init_ModalUnstyled2 as init_ModalUnstyled,
  NoSsr_default,
  init_NoSsr2 as init_NoSsr,
  getSliderUtilityClass,
  sliderUnstyledClasses_default,
  SliderValueLabelUnstyled,
  SliderUnstyled_default,
  init_SliderUnstyled2 as init_SliderUnstyled,
  TextareaAutosize_default,
  init_TextareaAutosize2 as init_TextareaAutosize,
  init_base,
  common_default,
  init_common,
  grey_default,
  init_grey,
  purple_default,
  init_purple,
  red_default,
  init_red,
  orange_default,
  init_orange,
  blue_default,
  init_blue,
  lightBlue_default,
  init_lightBlue,
  green_default,
  init_green,
  createTypography,
  init_createTypography,
  easing,
  duration,
  init_createTransitions,
  createMuiTheme,
  createTheme_default2 as createTheme_default,
  init_createTheme,
  defaultTheme_default,
  init_defaultTheme,
  useThemeProps2 as useThemeProps,
  init_useThemeProps,
  rootShouldForwardProp,
  slotShouldForwardProp,
  styled_default,
  init_styled
};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license MUI v5.0.0-alpha.96
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=chunk-7DQRMO6D.js.map
