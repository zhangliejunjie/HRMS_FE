import {
  es_exports,
  es_exports2,
  init_es,
  init_es2
} from "./chunk-HVQ2LMI2.js";
import {
  init_redux,
  redux_exports
} from "./chunk-FHZ4OFIZ.js";
import "./chunk-WTMLPC5P.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/immer/dist/immer.cjs.development.js
var require_immer_cjs_development = __commonJS({
  "node_modules/immer/dist/immer.cjs.development.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ref;
    var hasSymbol = typeof Symbol !== "undefined" && typeof Symbol("x") === "symbol";
    var hasMap = typeof Map !== "undefined";
    var hasSet = typeof Set !== "undefined";
    var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
    var NOTHING = hasSymbol ? Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
    var DRAFTABLE = hasSymbol ? Symbol.for("immer-draftable") : "__$immer_draftable";
    var DRAFT_STATE = hasSymbol ? Symbol.for("immer-state") : "__$immer_state";
    var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
    var errors = {
      0: "Illegal state",
      1: "Immer drafts cannot have computed properties",
      2: "This object has been frozen and should not be mutated",
      3: function _(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
      },
      4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
      5: "Immer forbids circular references",
      6: "The first or second argument to `produce` must be a function",
      7: "The third argument to `produce` must be a function or undefined",
      8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
      9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
      10: "The given draft is already finalized",
      11: "Object.defineProperty() cannot be used on an Immer draft",
      12: "Object.setPrototypeOf() cannot be used on an Immer draft",
      13: "Immer only supports deleting array indices",
      14: "Immer only supports setting array indices and the 'length' property",
      15: function _(path) {
        return "Cannot apply patch, path doesn't resolve: " + path;
      },
      16: 'Sets cannot have "replace" patches.',
      17: function _(op) {
        return "Unsupported patch operation: " + op;
      },
      18: function _(plugin) {
        return "The plugin for '" + plugin + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + plugin + "()` when initializing your application.";
      },
      20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
      21: function _(thing) {
        return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + thing + "'";
      },
      22: function _(thing) {
        return "'current' expects a draft, got: " + thing;
      },
      23: function _(thing) {
        return "'original' expects a draft, got: " + thing;
      },
      24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
    };
    function die(error) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      {
        var e = errors[error];
        var msg = !e ? "unknown error nr: " + error : typeof e === "function" ? e.apply(null, args) : e;
        throw new Error("[Immer] " + msg);
      }
    }
    function isDraft(value) {
      return !!value && !!value[DRAFT_STATE];
    }
    function isDraftable(value) {
      var _value$constructor;
      if (!value)
        return false;
      return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
    }
    var objectCtorString = Object.prototype.constructor.toString();
    function isPlainObject(value) {
      if (!value || typeof value !== "object")
        return false;
      var proto = Object.getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
    }
    function original(value) {
      if (!isDraft(value))
        die(23, value);
      return value[DRAFT_STATE].base_;
    }
    var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function(obj) {
      return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
    } : Object.getOwnPropertyNames;
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
      var res = {};
      ownKeys(target).forEach(function(key) {
        res[key] = Object.getOwnPropertyDescriptor(target, key);
      });
      return res;
    };
    function each(obj, iter, enumerableOnly) {
      if (enumerableOnly === void 0) {
        enumerableOnly = false;
      }
      if (getArchtype(obj) === 0) {
        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function(key) {
          if (!enumerableOnly || typeof key !== "symbol")
            iter(key, obj[key], obj);
        });
      } else {
        obj.forEach(function(entry, index) {
          return iter(index, entry, obj);
        });
      }
    }
    function getArchtype(thing) {
      var state = thing[DRAFT_STATE];
      return state ? state.type_ > 3 ? state.type_ - 4 : state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
    }
    function has(thing, prop) {
      return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
    }
    function get(thing, prop) {
      return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
    }
    function set(thing, propOrOldValue, value) {
      var t = getArchtype(thing);
      if (t === 2)
        thing.set(propOrOldValue, value);
      else if (t === 3) {
        thing.delete(propOrOldValue);
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    }
    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function isMap(target) {
      return hasMap && target instanceof Map;
    }
    function isSet(target) {
      return hasSet && target instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base) {
      if (Array.isArray(base))
        return Array.prototype.slice.call(base);
      var descriptors = getOwnPropertyDescriptors(base);
      delete descriptors[DRAFT_STATE];
      var keys = ownKeys(descriptors);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var desc = descriptors[key];
        if (desc.writable === false) {
          desc.writable = true;
          desc.configurable = true;
        }
        if (desc.get || desc.set)
          descriptors[key] = {
            configurable: true,
            writable: true,
            enumerable: desc.enumerable,
            value: base[key]
          };
      }
      return Object.create(Object.getPrototypeOf(base), descriptors);
    }
    function freeze(obj, deep) {
      if (deep === void 0) {
        deep = false;
      }
      if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
      }
      Object.freeze(obj);
      if (deep)
        each(obj, function(key, value) {
          return freeze(value, true);
        }, true);
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    function isFrozen(obj) {
      if (obj == null || typeof obj !== "object")
        return true;
      return Object.isFrozen(obj);
    }
    var plugins = {};
    function getPlugin(pluginKey) {
      var plugin = plugins[pluginKey];
      if (!plugin) {
        die(18, pluginKey);
      }
      return plugin;
    }
    function loadPlugin(pluginKey, implementation) {
      if (!plugins[pluginKey])
        plugins[pluginKey] = implementation;
    }
    var currentScope;
    function getCurrentScope() {
      if (!currentScope)
        die(0);
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope) {
      leaveScope(scope);
      scope.drafts_.forEach(revokeDraft);
      scope.drafts_ = null;
    }
    function leaveScope(scope) {
      if (scope === currentScope) {
        currentScope = scope.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      var state = draft[DRAFT_STATE];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult(result, scope) {
      scope.unfinalizedDrafts_ = scope.drafts_.length;
      var baseDraft = scope.drafts_[0];
      var isReplaced = result !== void 0 && result !== baseDraft;
      if (!scope.immer_.useProxies_)
        getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced);
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope);
          die(4);
        }
        if (isDraftable(result)) {
          result = finalize(scope, result);
          if (!scope.parent_)
            maybeFreeze(scope, result);
        }
        if (scope.patches_) {
          getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
        }
      } else {
        result = finalize(scope, baseDraft, []);
      }
      revokeScope(scope);
      if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value, path) {
      if (isFrozen(value))
        return value;
      var state = value[DRAFT_STATE];
      if (!state) {
        each(
          value,
          function(key, childValue) {
            return finalizeProperty(rootScope, state, value, key, childValue, path);
          },
          true
        );
        return value;
      }
      if (state.scope_ !== rootScope)
        return value;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        var result = state.type_ === 4 || state.type_ === 5 ? state.copy_ = shallowCopy(state.draft_) : state.copy_;
        each(state.type_ === 3 ? new Set(result) : result, function(key, childValue) {
          return finalizeProperty(rootScope, state, result, key, childValue, path);
        });
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath) {
      if (childValue === targetObject)
        die(5);
      if (isDraft(childValue)) {
        var path = rootPath && parentState && parentState.type_ !== 3 && !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        var res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      }
      if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        finalize(rootScope, childValue);
        if (!parentState || !parentState.scope_.parent_)
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope, value, deep) {
      if (deep === void 0) {
        deep = false;
      }
      if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
      }
    }
    function createProxyProxy(base, parent) {
      var isArray = Array.isArray(base);
      var state = {
        type_: isArray ? 1 : 0,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        assigned_: {},
        parent_: parent,
        base_: base,
        draft_: null,
        copy_: null,
        revoke_: null,
        isManual_: false
      };
      var target = state;
      var traps = objectTraps;
      if (isArray) {
        target = [state];
        traps = arrayTraps;
      }
      var _Proxy$revocable = Proxy.revocable(target, traps), revoke = _Proxy$revocable.revoke, proxy = _Proxy$revocable.proxy;
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get: function get2(state, prop) {
        if (prop === DRAFT_STATE)
          return state;
        var source = latest(state);
        if (!has(source, prop)) {
          return readPropFromProto(state, source, prop);
        }
        var value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value === peek(state.base_, prop)) {
          prepareCopy(state);
          return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);
        }
        return value;
      },
      has: function has2(state, prop) {
        return prop in latest(state);
      },
      ownKeys: function ownKeys2(state) {
        return Reflect.ownKeys(latest(state));
      },
      set: function set2(state, prop, value) {
        var desc = getDescriptorFromProto(latest(state), prop);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          var current2 = peek(latest(state), prop);
          var currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop] = value;
            state.assigned_[prop] = false;
            return true;
          }
          if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop] === value && typeof value !== "number" && (value !== void 0 || prop in state.copy_))
          return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
      },
      deleteProperty: function deleteProperty(state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_[prop] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop];
        }
        if (state.copy_)
          delete state.copy_[prop];
        return true;
      },
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
        var owner = latest(state);
        var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop !== "length",
          enumerable: desc.enumerable,
          value: owner[prop]
        };
      },
      defineProperty: function defineProperty() {
        die(11);
      },
      getPrototypeOf: function getPrototypeOf(state) {
        return Object.getPrototypeOf(state.base_);
      },
      setPrototypeOf: function setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, function(key, fn) {
      arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop) {
      if (isNaN(parseInt(prop)))
        die(13);
      return arrayTraps.set.call(this, state, prop, void 0);
    };
    arrayTraps.set = function(state, prop, value) {
      if (prop !== "length" && isNaN(parseInt(prop)))
        die(14);
      return objectTraps.set.call(this, state[0], prop, value, state[0]);
    };
    function peek(draft, prop) {
      var state = draft[DRAFT_STATE];
      var source = state ? latest(state) : draft;
      return source[prop];
    }
    function readPropFromProto(state, source, prop) {
      var _desc$get;
      var desc = getDescriptorFromProto(source, prop);
      return desc ? "value" in desc ? desc.value : (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : void 0;
    }
    function getDescriptorFromProto(source, prop) {
      if (!(prop in source))
        return void 0;
      var proto = Object.getPrototypeOf(source);
      while (proto) {
        var desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc)
          return desc;
        proto = Object.getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(state.base_);
      }
    }
    var Immer = function() {
      function Immer2(config) {
        var _this = this;
        this.useProxies_ = hasProxies;
        this.autoFreeze_ = true;
        this.produce = function(base, recipe, patchListener) {
          if (typeof base === "function" && typeof recipe !== "function") {
            var defaultBase = recipe;
            recipe = base;
            var self = _this;
            return function curriedProduce(base2) {
              var _this2 = this;
              if (base2 === void 0) {
                base2 = defaultBase;
              }
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return self.produce(base2, function(draft) {
                var _recipe;
                return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));
              });
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          var result;
          if (isDraftable(base)) {
            var scope = enterScope(_this);
            var proxy = createProxy(_this, base, void 0);
            var hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope);
              else
                leaveScope(scope);
            }
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then(function(result2) {
                usePatchesInScope(scope, patchListener);
                return processResult(result2, scope);
              }, function(error) {
                revokeScope(scope);
                throw error;
              });
            }
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          } else if (!base || typeof base !== "object") {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING)
              result = void 0;
            if (_this.autoFreeze_)
              freeze(result, true);
            if (patchListener) {
              var p = [];
              var ip = [];
              getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
              patchListener(p, ip);
            }
            return result;
          } else
            die(21, base);
        };
        this.produceWithPatches = function(base, recipe) {
          if (typeof base === "function") {
            return function(state) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              return _this.produceWithPatches(state, function(draft) {
                return base.apply(void 0, [draft].concat(args));
              });
            };
          }
          var patches, inversePatches;
          var result = _this.produce(base, recipe, function(p, ip) {
            patches = p;
            inversePatches = ip;
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then(function(nextState) {
              return [nextState, patches, inversePatches];
            });
          }
          return [result, patches, inversePatches];
        };
        if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === "boolean")
          this.setUseProxies(config.useProxies);
        if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean")
          this.setAutoFreeze(config.autoFreeze);
      }
      var _proto = Immer2.prototype;
      _proto.createDraft = function createDraft2(base) {
        if (!isDraftable(base))
          die(8);
        if (isDraft(base))
          base = current(base);
        var scope = enterScope(this);
        var proxy = createProxy(this, base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
      };
      _proto.finishDraft = function finishDraft2(draft, patchListener) {
        var state = draft && draft[DRAFT_STATE];
        {
          if (!state || !state.isManual_)
            die(9);
          if (state.finalized_)
            die(10);
        }
        var scope = state.scope_;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
      };
      _proto.setAutoFreeze = function setAutoFreeze2(value) {
        this.autoFreeze_ = value;
      };
      _proto.setUseProxies = function setUseProxies2(value) {
        if (value && !hasProxies) {
          die(20);
        }
        this.useProxies_ = value;
      };
      _proto.applyPatches = function applyPatches2(base, patches) {
        var i;
        for (i = patches.length - 1; i >= 0; i--) {
          var patch = patches[i];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i > -1) {
          patches = patches.slice(i + 1);
        }
        var applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(base, function(draft) {
          return applyPatchesImpl(draft, patches);
        });
      };
      return Immer2;
    }();
    function createProxy(immer2, value, parent) {
      var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : immer2.useProxies_ ? createProxyProxy(value, parent) : getPlugin("ES5").createES5Proxy_(value, parent);
      var scope = parent ? parent.scope_ : getCurrentScope();
      scope.drafts_.push(draft);
      return draft;
    }
    function current(value) {
      if (!isDraft(value))
        die(22, value);
      return currentImpl(value);
    }
    function currentImpl(value) {
      if (!isDraftable(value))
        return value;
      var state = value[DRAFT_STATE];
      var copy;
      var archType = getArchtype(value);
      if (state) {
        if (!state.modified_ && (state.type_ < 4 || !getPlugin("ES5").hasChanges_(state)))
          return state.base_;
        state.finalized_ = true;
        copy = copyHelper(value, archType);
        state.finalized_ = false;
      } else {
        copy = copyHelper(value, archType);
      }
      each(copy, function(key, childValue) {
        if (state && get(state.base_, key) === childValue)
          return;
        set(copy, key, currentImpl(childValue));
      });
      return archType === 3 ? new Set(copy) : copy;
    }
    function copyHelper(value, archType) {
      switch (archType) {
        case 2:
          return new Map(value);
        case 3:
          return Array.from(value);
      }
      return shallowCopy(value);
    }
    function enableES5() {
      function willFinalizeES5_(scope, result, isReplaced) {
        if (!isReplaced) {
          if (scope.patches_) {
            markChangesRecursively(scope.drafts_[0]);
          }
          markChangesSweep(scope.drafts_);
        } else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {
          markChangesSweep(scope.drafts_);
        }
      }
      function createES5Draft(isArray, base) {
        if (isArray) {
          var draft = new Array(base.length);
          for (var i = 0; i < base.length; i++) {
            Object.defineProperty(draft, "" + i, proxyProperty(i, true));
          }
          return draft;
        } else {
          var _descriptors = getOwnPropertyDescriptors(base);
          delete _descriptors[DRAFT_STATE];
          var keys = ownKeys(_descriptors);
          for (var _i = 0; _i < keys.length; _i++) {
            var key = keys[_i];
            _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);
          }
          return Object.create(Object.getPrototypeOf(base), _descriptors);
        }
      }
      function createES5Proxy_(base, parent) {
        var isArray = Array.isArray(base);
        var draft = createES5Draft(isArray, base);
        var state = {
          type_: isArray ? 5 : 4,
          scope_: parent ? parent.scope_ : getCurrentScope(),
          modified_: false,
          finalized_: false,
          assigned_: {},
          parent_: parent,
          base_: base,
          draft_: draft,
          copy_: null,
          revoked_: false,
          isManual_: false
        };
        Object.defineProperty(draft, DRAFT_STATE, {
          value: state,
          writable: true
        });
        return draft;
      }
      var descriptors = {};
      function proxyProperty(prop, enumerable) {
        var desc = descriptors[prop];
        if (desc) {
          desc.enumerable = enumerable;
        } else {
          descriptors[prop] = desc = {
            configurable: true,
            enumerable,
            get: function get2() {
              var state = this[DRAFT_STATE];
              assertUnrevoked(state);
              return objectTraps.get(state, prop);
            },
            set: function set2(value) {
              var state = this[DRAFT_STATE];
              assertUnrevoked(state);
              objectTraps.set(state, prop, value);
            }
          };
        }
        return desc;
      }
      function markChangesSweep(drafts) {
        for (var i = drafts.length - 1; i >= 0; i--) {
          var state = drafts[i][DRAFT_STATE];
          if (!state.modified_) {
            switch (state.type_) {
              case 5:
                if (hasArrayChanges(state))
                  markChanged(state);
                break;
              case 4:
                if (hasObjectChanges(state))
                  markChanged(state);
                break;
            }
          }
        }
      }
      function markChangesRecursively(object) {
        if (!object || typeof object !== "object")
          return;
        var state = object[DRAFT_STATE];
        if (!state)
          return;
        var base_ = state.base_, draft_ = state.draft_, assigned_ = state.assigned_, type_ = state.type_;
        if (type_ === 4) {
          each(draft_, function(key) {
            if (key === DRAFT_STATE)
              return;
            if (base_[key] === void 0 && !has(base_, key)) {
              assigned_[key] = true;
              markChanged(state);
            } else if (!assigned_[key]) {
              markChangesRecursively(draft_[key]);
            }
          });
          each(base_, function(key) {
            if (draft_[key] === void 0 && !has(draft_, key)) {
              assigned_[key] = false;
              markChanged(state);
            }
          });
        } else if (type_ === 5) {
          if (hasArrayChanges(state)) {
            markChanged(state);
            assigned_.length = true;
          }
          if (draft_.length < base_.length) {
            for (var i = draft_.length; i < base_.length; i++) {
              assigned_[i] = false;
            }
          } else {
            for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {
              assigned_[_i2] = true;
            }
          }
          var min = Math.min(draft_.length, base_.length);
          for (var _i3 = 0; _i3 < min; _i3++) {
            if (!draft_.hasOwnProperty(_i3)) {
              assigned_[_i3] = true;
            }
            if (assigned_[_i3] === void 0)
              markChangesRecursively(draft_[_i3]);
          }
        }
      }
      function hasObjectChanges(state) {
        var base_ = state.base_, draft_ = state.draft_;
        var keys = ownKeys(draft_);
        for (var i = keys.length - 1; i >= 0; i--) {
          var key = keys[i];
          if (key === DRAFT_STATE)
            continue;
          var baseValue = base_[key];
          if (baseValue === void 0 && !has(base_, key)) {
            return true;
          } else {
            var value = draft_[key];
            var _state = value && value[DRAFT_STATE];
            if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {
              return true;
            }
          }
        }
        var baseIsDraft = !!base_[DRAFT_STATE];
        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1);
      }
      function hasArrayChanges(state) {
        var draft_ = state.draft_;
        if (draft_.length !== state.base_.length)
          return true;
        var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1);
        if (descriptor && !descriptor.get)
          return true;
        for (var i = 0; i < draft_.length; i++) {
          if (!draft_.hasOwnProperty(i))
            return true;
        }
        return false;
      }
      function hasChanges_(state) {
        return state.type_ === 4 ? hasObjectChanges(state) : hasArrayChanges(state);
      }
      function assertUnrevoked(state) {
        if (state.revoked_)
          die(3, JSON.stringify(latest(state)));
      }
      loadPlugin("ES5", {
        createES5Proxy_,
        willFinalizeES5_,
        hasChanges_
      });
    }
    function enablePatches() {
      var REPLACE = "replace";
      var ADD = "add";
      var REMOVE = "remove";
      function generatePatches_(state, basePath, patches, inversePatches) {
        switch (state.type_) {
          case 0:
          case 4:
          case 2:
            return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
          case 5:
          case 1:
            return generateArrayPatches(state, basePath, patches, inversePatches);
          case 3:
            return generateSetPatches(state, basePath, patches, inversePatches);
        }
      }
      function generateArrayPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, assigned_ = state.assigned_;
        var copy_ = state.copy_;
        if (copy_.length < base_.length) {
          var _ref2 = [copy_, base_];
          base_ = _ref2[0];
          copy_ = _ref2[1];
          var _ref22 = [inversePatches, patches];
          patches = _ref22[0];
          inversePatches = _ref22[1];
        }
        for (var i = 0; i < base_.length; i++) {
          if (assigned_[i] && copy_[i] !== base_[i]) {
            var path = basePath.concat([i]);
            patches.push({
              op: REPLACE,
              path,
              value: clonePatchValueIfNeeded(copy_[i])
            });
            inversePatches.push({
              op: REPLACE,
              path,
              value: clonePatchValueIfNeeded(base_[i])
            });
          }
        }
        for (var _i = base_.length; _i < copy_.length; _i++) {
          var _path = basePath.concat([_i]);
          patches.push({
            op: ADD,
            path: _path,
            value: clonePatchValueIfNeeded(copy_[_i])
          });
        }
        if (base_.length < copy_.length) {
          inversePatches.push({
            op: REPLACE,
            path: basePath.concat(["length"]),
            value: base_.length
          });
        }
      }
      function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        each(state.assigned_, function(key, assignedValue) {
          var origValue = get(base_, key);
          var value = get(copy_, key);
          var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
          if (origValue === value && op === REPLACE)
            return;
          var path = basePath.concat(key);
          patches.push(op === REMOVE ? {
            op,
            path
          } : {
            op,
            path,
            value
          });
          inversePatches.push(op === ADD ? {
            op: REMOVE,
            path
          } : op === REMOVE ? {
            op: ADD,
            path,
            value: clonePatchValueIfNeeded(origValue)
          } : {
            op: REPLACE,
            path,
            value: clonePatchValueIfNeeded(origValue)
          });
        });
      }
      function generateSetPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        var i = 0;
        base_.forEach(function(value) {
          if (!copy_.has(value)) {
            var path = basePath.concat([i]);
            patches.push({
              op: REMOVE,
              path,
              value
            });
            inversePatches.unshift({
              op: ADD,
              path,
              value
            });
          }
          i++;
        });
        i = 0;
        copy_.forEach(function(value) {
          if (!base_.has(value)) {
            var path = basePath.concat([i]);
            patches.push({
              op: ADD,
              path,
              value
            });
            inversePatches.unshift({
              op: REMOVE,
              path,
              value
            });
          }
          i++;
        });
      }
      function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
        patches.push({
          op: REPLACE,
          path: [],
          value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches.push({
          op: REPLACE,
          path: [],
          value: baseValue
        });
      }
      function applyPatches_(draft, patches) {
        patches.forEach(function(patch) {
          var path = patch.path, op = patch.op;
          var base = draft;
          for (var i = 0; i < path.length - 1; i++) {
            var parentType = getArchtype(base);
            var p = "" + path[i];
            if ((parentType === 0 || parentType === 1) && (p === "__proto__" || p === "constructor"))
              die(24);
            if (typeof base === "function" && p === "prototype")
              die(24);
            base = get(base, p);
            if (typeof base !== "object")
              die(15, path.join("/"));
          }
          var type = getArchtype(base);
          var value = deepClonePatchValue(patch.value);
          var key = path[path.length - 1];
          switch (op) {
            case REPLACE:
              switch (type) {
                case 2:
                  return base.set(key, value);
                case 3:
                  die(16);
                default:
                  return base[key] = value;
              }
            case ADD:
              switch (type) {
                case 1:
                  return key === "-" ? base.push(value) : base.splice(key, 0, value);
                case 2:
                  return base.set(key, value);
                case 3:
                  return base.add(value);
                default:
                  return base[key] = value;
              }
            case REMOVE:
              switch (type) {
                case 1:
                  return base.splice(key, 1);
                case 2:
                  return base.delete(key);
                case 3:
                  return base.delete(patch.value);
                default:
                  return delete base[key];
              }
            default:
              die(17, op);
          }
        });
        return draft;
      }
      function deepClonePatchValue(obj) {
        if (!isDraftable(obj))
          return obj;
        if (Array.isArray(obj))
          return obj.map(deepClonePatchValue);
        if (isMap(obj))
          return new Map(Array.from(obj.entries()).map(function(_ref3) {
            var k = _ref3[0], v = _ref3[1];
            return [k, deepClonePatchValue(v)];
          }));
        if (isSet(obj))
          return new Set(Array.from(obj).map(deepClonePatchValue));
        var cloned = Object.create(Object.getPrototypeOf(obj));
        for (var key in obj) {
          cloned[key] = deepClonePatchValue(obj[key]);
        }
        if (has(obj, DRAFTABLE))
          cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
      }
      function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) {
          return deepClonePatchValue(obj);
        } else
          return obj;
      }
      loadPlugin("Patches", {
        applyPatches_,
        generatePatches_,
        generateReplacementPatches_
      });
    }
    function enableMapSet() {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
          }
        };
        return _extendStatics(d, b);
      };
      function __extends(d, b) {
        _extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = (__.prototype = b.prototype, new __());
      }
      var DraftMap = function(_super) {
        __extends(DraftMap2, _super);
        function DraftMap2(target, parent) {
          this[DRAFT_STATE] = {
            type_: 2,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            assigned_: void 0,
            base_: target,
            draft_: this,
            isManual_: false,
            revoked_: false
          };
          return this;
        }
        var p = DraftMap2.prototype;
        Object.defineProperty(p, "size", {
          get: function get2() {
            return latest(this[DRAFT_STATE]).size;
          }
        });
        p.has = function(key) {
          return latest(this[DRAFT_STATE]).has(key);
        };
        p.set = function(key, value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!latest(state).has(key) || latest(state).get(key) !== value) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_.set(key, true);
            state.copy_.set(key, value);
            state.assigned_.set(key, true);
          }
          return this;
        };
        p.delete = function(key) {
          if (!this.has(key)) {
            return false;
          }
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareMapCopy(state);
          markChanged(state);
          if (state.base_.has(key)) {
            state.assigned_.set(key, false);
          } else {
            state.assigned_.delete(key);
          }
          state.copy_.delete(key);
          return true;
        };
        p.clear = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_ = /* @__PURE__ */ new Map();
            each(state.base_, function(key) {
              state.assigned_.set(key, false);
            });
            state.copy_.clear();
          }
        };
        p.forEach = function(cb, thisArg) {
          var _this = this;
          var state = this[DRAFT_STATE];
          latest(state).forEach(function(_value, key, _map) {
            cb.call(thisArg, _this.get(key), key, _this);
          });
        };
        p.get = function(key) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          var value = latest(state).get(key);
          if (state.finalized_ || !isDraftable(value)) {
            return value;
          }
          if (value !== state.base_.get(key)) {
            return value;
          }
          var draft = createProxy(state.scope_.immer_, value, state);
          prepareMapCopy(state);
          state.copy_.set(key, draft);
          return draft;
        };
        p.keys = function() {
          return latest(this[DRAFT_STATE]).keys();
        };
        p.values = function() {
          var _this2 = this, _ref2;
          var iterator = this.keys();
          return _ref2 = {}, _ref2[iteratorSymbol] = function() {
            return _this2.values();
          }, _ref2.next = function next() {
            var r = iterator.next();
            if (r.done)
              return r;
            var value = _this2.get(r.value);
            return {
              done: false,
              value
            };
          }, _ref2;
        };
        p.entries = function() {
          var _this3 = this, _ref2;
          var iterator = this.keys();
          return _ref2 = {}, _ref2[iteratorSymbol] = function() {
            return _this3.entries();
          }, _ref2.next = function next() {
            var r = iterator.next();
            if (r.done)
              return r;
            var value = _this3.get(r.value);
            return {
              done: false,
              value: [r.value, value]
            };
          }, _ref2;
        };
        p[iteratorSymbol] = function() {
          return this.entries();
        };
        return DraftMap2;
      }(Map);
      function proxyMap_(target, parent) {
        return new DraftMap(target, parent);
      }
      function prepareMapCopy(state) {
        if (!state.copy_) {
          state.assigned_ = /* @__PURE__ */ new Map();
          state.copy_ = new Map(state.base_);
        }
      }
      var DraftSet = function(_super) {
        __extends(DraftSet2, _super);
        function DraftSet2(target, parent) {
          this[DRAFT_STATE] = {
            type_: 3,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            base_: target,
            draft_: this,
            drafts_: /* @__PURE__ */ new Map(),
            revoked_: false,
            isManual_: false
          };
          return this;
        }
        var p = DraftSet2.prototype;
        Object.defineProperty(p, "size", {
          get: function get2() {
            return latest(this[DRAFT_STATE]).size;
          }
        });
        p.has = function(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!state.copy_) {
            return state.base_.has(value);
          }
          if (state.copy_.has(value))
            return true;
          if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
            return true;
          return false;
        };
        p.add = function(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!this.has(value)) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.add(value);
          }
          return this;
        };
        p.delete = function(value) {
          if (!this.has(value)) {
            return false;
          }
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          markChanged(state);
          return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : false);
        };
        p.clear = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.clear();
          }
        };
        p.values = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.values();
        };
        p.entries = function entries() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.entries();
        };
        p.keys = function() {
          return this.values();
        };
        p[iteratorSymbol] = function() {
          return this.values();
        };
        p.forEach = function forEach(cb, thisArg) {
          var iterator = this.values();
          var result = iterator.next();
          while (!result.done) {
            cb.call(thisArg, result.value, result.value, this);
            result = iterator.next();
          }
        };
        return DraftSet2;
      }(Set);
      function proxySet_(target, parent) {
        return new DraftSet(target, parent);
      }
      function prepareSetCopy(state) {
        if (!state.copy_) {
          state.copy_ = /* @__PURE__ */ new Set();
          state.base_.forEach(function(value) {
            if (isDraftable(value)) {
              var draft = createProxy(state.scope_.immer_, value, state);
              state.drafts_.set(value, draft);
              state.copy_.add(draft);
            } else {
              state.copy_.add(value);
            }
          });
        }
      }
      function assertUnrevoked(state) {
        if (state.revoked_)
          die(3, JSON.stringify(latest(state)));
      }
      loadPlugin("MapSet", {
        proxyMap_,
        proxySet_
      });
    }
    function enableAllPlugins() {
      enableES5();
      enableMapSet();
      enablePatches();
    }
    var immer = new Immer();
    var produce = immer.produce;
    var produceWithPatches = immer.produceWithPatches.bind(immer);
    var setAutoFreeze = immer.setAutoFreeze.bind(immer);
    var setUseProxies = immer.setUseProxies.bind(immer);
    var applyPatches = immer.applyPatches.bind(immer);
    var createDraft = immer.createDraft.bind(immer);
    var finishDraft = immer.finishDraft.bind(immer);
    function castDraft(value) {
      return value;
    }
    function castImmutable(value) {
      return value;
    }
    exports.Immer = Immer;
    exports.applyPatches = applyPatches;
    exports.castDraft = castDraft;
    exports.castImmutable = castImmutable;
    exports.createDraft = createDraft;
    exports.current = current;
    exports.default = produce;
    exports.enableAllPlugins = enableAllPlugins;
    exports.enableES5 = enableES5;
    exports.enableMapSet = enableMapSet;
    exports.enablePatches = enablePatches;
    exports.finishDraft = finishDraft;
    exports.freeze = freeze;
    exports.immerable = DRAFTABLE;
    exports.isDraft = isDraft;
    exports.isDraftable = isDraftable;
    exports.nothing = NOTHING;
    exports.original = original;
    exports.produce = produce;
    exports.produceWithPatches = produceWithPatches;
    exports.setAutoFreeze = setAutoFreeze;
    exports.setUseProxies = setUseProxies;
  }
});

// node_modules/immer/dist/index.js
var require_dist = __commonJS({
  "node_modules/immer/dist/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_immer_cjs_development();
    }
  }
});

// node_modules/@reduxjs/toolkit/dist/redux-toolkit.cjs.development.js
var require_redux_toolkit_cjs_development = __commonJS({
  "node_modules/@reduxjs/toolkit/dist/redux-toolkit.cjs.development.js"(exports) {
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = function(obj, key, value) {
      return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    };
    var __spreadValues = function(a, b) {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++) {
          var prop = _c[_i];
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = function(a, b) {
      return __defProps(a, __getOwnPropDescs(b));
    };
    var __markAsModule = function(target) {
      return __defProp(target, "__esModule", { value: true });
    };
    var __export = function(target, all) {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = function(target, module2, desc) {
      if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        var _loop_1 = function(key2) {
          if (!__hasOwnProp.call(target, key2) && key2 !== "default")
            __defProp(target, key2, { get: function() {
              return module2[key2];
            }, enumerable: !(desc = __getOwnPropDesc(module2, key2)) || desc.enumerable });
        };
        for (var _i = 0, _c = __getOwnPropNames(module2); _i < _c.length; _i++) {
          var key = _c[_i];
          _loop_1(key);
        }
      }
      return target;
    };
    var __toModule = function(module2) {
      return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: function() {
        return module2.default;
      }, enumerable: true } : { value: module2, enumerable: true })), module2);
    };
    var __async = function(__this, __arguments, generator) {
      return new Promise(function(resolve, reject) {
        var fulfilled = function(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = function(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = function(x) {
          return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        };
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    __markAsModule(exports);
    __export(exports, {
      MiddlewareArray: function() {
        return MiddlewareArray;
      },
      TaskAbortError: function() {
        return TaskAbortError;
      },
      addListener: function() {
        return addListener;
      },
      clearAllListeners: function() {
        return clearAllListeners;
      },
      configureStore: function() {
        return configureStore;
      },
      createAction: function() {
        return createAction;
      },
      createAsyncThunk: function() {
        return createAsyncThunk;
      },
      createDraftSafeSelector: function() {
        return createDraftSafeSelector;
      },
      createEntityAdapter: function() {
        return createEntityAdapter;
      },
      createImmutableStateInvariantMiddleware: function() {
        return createImmutableStateInvariantMiddleware;
      },
      createListenerMiddleware: function() {
        return createListenerMiddleware;
      },
      createNextState: function() {
        return import_immer6.default;
      },
      createReducer: function() {
        return createReducer;
      },
      createSelector: function() {
        return import_reselect2.createSelector;
      },
      createSerializableStateInvariantMiddleware: function() {
        return createSerializableStateInvariantMiddleware;
      },
      createSlice: function() {
        return createSlice;
      },
      current: function() {
        return import_immer6.current;
      },
      findNonSerializableValue: function() {
        return findNonSerializableValue;
      },
      freeze: function() {
        return import_immer6.freeze;
      },
      getDefaultMiddleware: function() {
        return getDefaultMiddleware;
      },
      getType: function() {
        return getType;
      },
      isAllOf: function() {
        return isAllOf;
      },
      isAnyOf: function() {
        return isAnyOf;
      },
      isAsyncThunkAction: function() {
        return isAsyncThunkAction;
      },
      isDraft: function() {
        return import_immer6.isDraft;
      },
      isFulfilled: function() {
        return isFulfilled;
      },
      isImmutableDefault: function() {
        return isImmutableDefault;
      },
      isPending: function() {
        return isPending;
      },
      isPlain: function() {
        return isPlain;
      },
      isPlainObject: function() {
        return isPlainObject;
      },
      isRejected: function() {
        return isRejected;
      },
      isRejectedWithValue: function() {
        return isRejectedWithValue;
      },
      miniSerializeError: function() {
        return miniSerializeError;
      },
      nanoid: function() {
        return nanoid;
      },
      original: function() {
        return import_immer6.original;
      },
      removeListener: function() {
        return removeListener;
      },
      unwrapResult: function() {
        return unwrapResult;
      }
    });
    var import_immer5 = __toModule(require_dist());
    __reExport(exports, __toModule((init_redux(), __toCommonJS(redux_exports))));
    var import_immer6 = __toModule(require_dist());
    var import_reselect2 = __toModule((init_es(), __toCommonJS(es_exports)));
    var import_immer = __toModule(require_dist());
    var import_reselect = __toModule((init_es(), __toCommonJS(es_exports)));
    var createDraftSafeSelector = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var selector = (0, import_reselect.createSelector).apply(void 0, args);
      var wrappedSelector = function(value) {
        var rest = [];
        for (var _i2 = 1; _i2 < arguments.length; _i2++) {
          rest[_i2 - 1] = arguments[_i2];
        }
        return selector.apply(void 0, __spreadArray([(0, import_immer.isDraft)(value) ? (0, import_immer.current)(value) : value], rest));
      };
      return wrappedSelector;
    };
    var import_redux2 = __toModule((init_redux(), __toCommonJS(redux_exports)));
    var import_redux = __toModule((init_redux(), __toCommonJS(redux_exports)));
    var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
      if (arguments.length === 0)
        return void 0;
      if (typeof arguments[0] === "object")
        return import_redux.compose;
      return import_redux.compose.apply(null, arguments);
    };
    var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
      return function(noop2) {
        return noop2;
      };
    };
    function isPlainObject(value) {
      if (typeof value !== "object" || value === null)
        return false;
      var proto = Object.getPrototypeOf(value);
      if (proto === null)
        return true;
      var baseProto = proto;
      while (Object.getPrototypeOf(baseProto) !== null) {
        baseProto = Object.getPrototypeOf(baseProto);
      }
      return proto === baseProto;
    }
    var import_redux_thunk = __toModule((init_es2(), __toCommonJS(es_exports2)));
    var import_immer2 = __toModule(require_dist());
    function getTimeMeasureUtils(maxDelay, fnName) {
      var elapsed = 0;
      return {
        measureTime: function(fn) {
          var started = Date.now();
          try {
            return fn();
          } finally {
            var finished = Date.now();
            elapsed += finished - started;
          }
        },
        warnIfExceeded: function() {
          if (elapsed > maxDelay) {
            console.warn(fnName + " took " + elapsed + "ms, which is more than the warning threshold of " + maxDelay + "ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.");
          }
        }
      };
    }
    var MiddlewareArray = function(_super) {
      __extends(MiddlewareArray2, _super);
      function MiddlewareArray2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var _this = _super.apply(this, args) || this;
        Object.setPrototypeOf(_this, MiddlewareArray2.prototype);
        return _this;
      }
      Object.defineProperty(MiddlewareArray2, Symbol.species, {
        get: function() {
          return MiddlewareArray2;
        },
        enumerable: false,
        configurable: true
      });
      MiddlewareArray2.prototype.concat = function() {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          arr[_i] = arguments[_i];
        }
        return _super.prototype.concat.apply(this, arr);
      };
      MiddlewareArray2.prototype.prepend = function() {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          arr[_i] = arguments[_i];
        }
        if (arr.length === 1 && Array.isArray(arr[0])) {
          return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr[0].concat(this))))();
        }
        return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr.concat(this))))();
      };
      return MiddlewareArray2;
    }(Array);
    function freezeDraftable(val) {
      return (0, import_immer2.isDraftable)(val) ? (0, import_immer2.default)(val, function() {
      }) : val;
    }
    var isProduction = false;
    var prefix = "Invariant failed";
    function invariant(condition, message) {
      if (condition) {
        return;
      }
      if (isProduction) {
        throw new Error(prefix);
      }
      throw new Error(prefix + ": " + (message || ""));
    }
    function stringify(obj, serializer, indent, decycler) {
      return JSON.stringify(obj, getSerialize(serializer, decycler), indent);
    }
    function getSerialize(serializer, decycler) {
      var stack = [], keys = [];
      if (!decycler)
        decycler = function(_, value) {
          if (stack[0] === value)
            return "[Circular ~]";
          return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
        };
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value))
            value = decycler.call(this, key, value);
        } else
          stack.push(value);
        return serializer == null ? value : serializer.call(this, key, value);
      };
    }
    function isImmutableDefault(value) {
      return typeof value !== "object" || value == null || Object.isFrozen(value);
    }
    function trackForMutations(isImmutable, ignorePaths, obj) {
      var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
      return {
        detectMutations: function() {
          return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
        }
      };
    }
    function trackProperties(isImmutable, ignorePaths, obj, path) {
      if (ignorePaths === void 0) {
        ignorePaths = [];
      }
      if (path === void 0) {
        path = "";
      }
      var tracked = { value: obj };
      if (!isImmutable(obj)) {
        tracked.children = {};
        for (var key in obj) {
          var childPath = path ? path + "." + key : key;
          if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
            continue;
          }
          tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
        }
      }
      return tracked;
    }
    function detectMutations(isImmutable, ignorePaths, trackedProperty, obj, sameParentRef, path) {
      if (ignorePaths === void 0) {
        ignorePaths = [];
      }
      if (sameParentRef === void 0) {
        sameParentRef = false;
      }
      if (path === void 0) {
        path = "";
      }
      var prevObj = trackedProperty ? trackedProperty.value : void 0;
      var sameRef = prevObj === obj;
      if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
        return { wasMutated: true, path };
      }
      if (isImmutable(prevObj) || isImmutable(obj)) {
        return { wasMutated: false };
      }
      var keysToDetect = {};
      for (var key in trackedProperty.children) {
        keysToDetect[key] = true;
      }
      for (var key in obj) {
        keysToDetect[key] = true;
      }
      for (var key in keysToDetect) {
        var childPath = path ? path + "." + key : key;
        if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
          continue;
        }
        var result = detectMutations(isImmutable, ignorePaths, trackedProperty.children[key], obj[key], sameRef, childPath);
        if (result.wasMutated) {
          return result;
        }
      }
      return { wasMutated: false };
    }
    function createImmutableStateInvariantMiddleware(options) {
      if (options === void 0) {
        options = {};
      }
      if (false) {
        return function() {
          return function(next) {
            return function(action) {
              return next(action);
            };
          };
        };
      }
      var _c = options.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options.ignoredPaths, _d = options.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options.ignore;
      ignoredPaths = ignoredPaths || ignore;
      var track = trackForMutations.bind(null, isImmutable, ignoredPaths);
      return function(_c2) {
        var getState = _c2.getState;
        var state = getState();
        var tracker = track(state);
        var result;
        return function(next) {
          return function(action) {
            var measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
            measureUtils.measureTime(function() {
              state = getState();
              result = tracker.detectMutations();
              tracker = track(state);
              invariant(!result.wasMutated, "A state mutation was detected between dispatches, in the path '" + (result.path || "") + "'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
            });
            var dispatchedAction = next(action);
            measureUtils.measureTime(function() {
              state = getState();
              result = tracker.detectMutations();
              tracker = track(state);
              result.wasMutated && invariant(!result.wasMutated, "A state mutation was detected inside a dispatch, in the path: " + (result.path || "") + ". Take a look at the reducer(s) handling the action " + stringify(action) + ". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
            });
            measureUtils.warnIfExceeded();
            return dispatchedAction;
          };
        };
      };
    }
    function isPlain(val) {
      var type = typeof val;
      return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject(val);
    }
    function findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths) {
      if (path === void 0) {
        path = "";
      }
      if (isSerializable === void 0) {
        isSerializable = isPlain;
      }
      if (ignoredPaths === void 0) {
        ignoredPaths = [];
      }
      var foundNestedSerializable;
      if (!isSerializable(value)) {
        return {
          keyPath: path || "<root>",
          value
        };
      }
      if (typeof value !== "object" || value === null) {
        return false;
      }
      var entries = getEntries != null ? getEntries(value) : Object.entries(value);
      var hasIgnoredPaths = ignoredPaths.length > 0;
      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];
        var nestedPath = path ? path + "." + key : key;
        if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath) >= 0) {
          continue;
        }
        if (!isSerializable(nestedValue)) {
          return {
            keyPath: nestedPath,
            value: nestedValue
          };
        }
        if (typeof nestedValue === "object") {
          foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths);
          if (foundNestedSerializable) {
            return foundNestedSerializable;
          }
        }
      }
      return false;
    }
    function createSerializableStateInvariantMiddleware(options) {
      if (options === void 0) {
        options = {};
      }
      if (false) {
        return function() {
          return function(next) {
            return function(action) {
              return next(action);
            };
          };
        };
      }
      var _c = options.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options.getEntries, _d = options.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? ["meta.arg", "meta.baseQueryMeta"] : _e, _f = options.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options.ignoreActions, ignoreActions = _j === void 0 ? false : _j;
      return function(storeAPI) {
        return function(next) {
          return function(action) {
            var result = next(action);
            var measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
            if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
              measureUtils.measureTime(function() {
                var foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths);
                if (foundActionNonSerializableValue) {
                  var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;
                  console.error("A non-serializable value was detected in an action, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
                }
              });
            }
            if (!ignoreState) {
              measureUtils.measureTime(function() {
                var state = storeAPI.getState();
                var foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths);
                if (foundStateNonSerializableValue) {
                  var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;
                  console.error("A non-serializable value was detected in the state, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the reducer(s) handling this action type: " + action.type + ".\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)");
                }
              });
              measureUtils.warnIfExceeded();
            }
            return result;
          };
        };
      };
    }
    function isBoolean(x) {
      return typeof x === "boolean";
    }
    function curryGetDefaultMiddleware() {
      return function curriedGetDefaultMiddleware(options) {
        return getDefaultMiddleware(options);
      };
    }
    function getDefaultMiddleware(options) {
      if (options === void 0) {
        options = {};
      }
      var _c = options.thunk, thunk = _c === void 0 ? true : _c, _d = options.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options.serializableCheck, serializableCheck = _e === void 0 ? true : _e;
      var middlewareArray = new MiddlewareArray();
      if (thunk) {
        if (isBoolean(thunk)) {
          middlewareArray.push(import_redux_thunk.default);
        } else {
          middlewareArray.push(import_redux_thunk.default.withExtraArgument(thunk.extraArgument));
        }
      }
      if (true) {
        if (immutableCheck) {
          var immutableOptions = {};
          if (!isBoolean(immutableCheck)) {
            immutableOptions = immutableCheck;
          }
          middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
        }
        if (serializableCheck) {
          var serializableOptions = {};
          if (!isBoolean(serializableCheck)) {
            serializableOptions = serializableCheck;
          }
          middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
        }
      }
      return middlewareArray;
    }
    var IS_PRODUCTION = false;
    function configureStore(options) {
      var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
      var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
      var rootReducer;
      if (typeof reducer === "function") {
        rootReducer = reducer;
      } else if (isPlainObject(reducer)) {
        rootReducer = (0, import_redux2.combineReducers)(reducer);
      } else {
        throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
      }
      var finalMiddleware = middleware;
      if (typeof finalMiddleware === "function") {
        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {
          throw new Error("when using a middleware builder function, an array of middleware must be returned");
        }
      }
      if (!IS_PRODUCTION && finalMiddleware.some(function(item) {
        return typeof item !== "function";
      })) {
        throw new Error("each middleware provided to configureStore must be a function");
      }
      var middlewareEnhancer = (0, import_redux2.applyMiddleware).apply(void 0, finalMiddleware);
      var finalCompose = import_redux2.compose;
      if (devTools) {
        finalCompose = composeWithDevTools(__spreadValues({
          trace: !IS_PRODUCTION
        }, typeof devTools === "object" && devTools));
      }
      var storeEnhancers = [middlewareEnhancer];
      if (Array.isArray(enhancers)) {
        storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
      } else if (typeof enhancers === "function") {
        storeEnhancers = enhancers(storeEnhancers);
      }
      var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
      return (0, import_redux2.createStore)(rootReducer, preloadedState, composedEnhancer);
    }
    function createAction(type, prepareAction) {
      function actionCreator() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (prepareAction) {
          var prepared = prepareAction.apply(void 0, args);
          if (!prepared) {
            throw new Error("prepareAction did not return an object");
          }
          return __spreadValues(__spreadValues({
            type,
            payload: prepared.payload
          }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
        }
        return { type, payload: args[0] };
      }
      actionCreator.toString = function() {
        return "" + type;
      };
      actionCreator.type = type;
      actionCreator.match = function(action) {
        return action.type === type;
      };
      return actionCreator;
    }
    function isFSA(action) {
      return isPlainObject(action) && typeof action.type === "string" && Object.keys(action).every(isValidKey);
    }
    function isValidKey(key) {
      return ["type", "payload", "error", "meta"].indexOf(key) > -1;
    }
    function getType(actionCreator) {
      return "" + actionCreator;
    }
    var import_immer3 = __toModule(require_dist());
    function executeReducerBuilderCallback(builderCallback) {
      var actionsMap = {};
      var actionMatchers = [];
      var defaultCaseReducer;
      var builder = {
        addCase: function(typeOrActionCreator, reducer) {
          if (true) {
            if (actionMatchers.length > 0) {
              throw new Error("`builder.addCase` should only be called before calling `builder.addMatcher`");
            }
            if (defaultCaseReducer) {
              throw new Error("`builder.addCase` should only be called before calling `builder.addDefaultCase`");
            }
          }
          var type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
          if (type in actionsMap) {
            throw new Error("addCase cannot be called with two reducers for the same action type");
          }
          actionsMap[type] = reducer;
          return builder;
        },
        addMatcher: function(matcher, reducer) {
          if (true) {
            if (defaultCaseReducer) {
              throw new Error("`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
            }
          }
          actionMatchers.push({ matcher, reducer });
          return builder;
        },
        addDefaultCase: function(reducer) {
          if (true) {
            if (defaultCaseReducer) {
              throw new Error("`builder.addDefaultCase` can only be called once");
            }
          }
          defaultCaseReducer = reducer;
          return builder;
        }
      };
      builderCallback(builder);
      return [actionsMap, actionMatchers, defaultCaseReducer];
    }
    function isStateFunction(x) {
      return typeof x === "function";
    }
    function createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
      if (actionMatchers === void 0) {
        actionMatchers = [];
      }
      var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];
      var getInitialState;
      if (isStateFunction(initialState)) {
        getInitialState = function() {
          return freezeDraftable(initialState());
        };
      } else {
        var frozenInitialState_1 = freezeDraftable(initialState);
        getInitialState = function() {
          return frozenInitialState_1;
        };
      }
      function reducer(state, action) {
        if (state === void 0) {
          state = getInitialState();
        }
        var caseReducers = __spreadArray([
          actionsMap[action.type]
        ], finalActionMatchers.filter(function(_c2) {
          var matcher = _c2.matcher;
          return matcher(action);
        }).map(function(_c2) {
          var reducer2 = _c2.reducer;
          return reducer2;
        }));
        if (caseReducers.filter(function(cr) {
          return !!cr;
        }).length === 0) {
          caseReducers = [finalDefaultCaseReducer];
        }
        return caseReducers.reduce(function(previousState, caseReducer) {
          if (caseReducer) {
            if ((0, import_immer3.isDraft)(previousState)) {
              var draft = previousState;
              var result = caseReducer(draft, action);
              if (result === void 0) {
                return previousState;
              }
              return result;
            } else if (!(0, import_immer3.isDraftable)(previousState)) {
              var result = caseReducer(previousState, action);
              if (result === void 0) {
                if (previousState === null) {
                  return previousState;
                }
                throw Error("A case reducer on a non-draftable value must not return undefined");
              }
              return result;
            } else {
              return (0, import_immer3.default)(previousState, function(draft2) {
                return caseReducer(draft2, action);
              });
            }
          }
          return previousState;
        }, state);
      }
      reducer.getInitialState = getInitialState;
      return reducer;
    }
    function getType2(slice, actionKey) {
      return slice + "/" + actionKey;
    }
    function createSlice(options) {
      var name = options.name;
      if (!name) {
        throw new Error("`name` is a required option for createSlice");
      }
      if (typeof process !== "undefined" && true) {
        if (options.initialState === void 0) {
          console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
        }
      }
      var initialState = typeof options.initialState == "function" ? options.initialState : freezeDraftable(options.initialState);
      var reducers = options.reducers || {};
      var reducerNames = Object.keys(reducers);
      var sliceCaseReducersByName = {};
      var sliceCaseReducersByType = {};
      var actionCreators = {};
      reducerNames.forEach(function(reducerName) {
        var maybeReducerWithPrepare = reducers[reducerName];
        var type = getType2(name, reducerName);
        var caseReducer;
        var prepareCallback;
        if ("reducer" in maybeReducerWithPrepare) {
          caseReducer = maybeReducerWithPrepare.reducer;
          prepareCallback = maybeReducerWithPrepare.prepare;
        } else {
          caseReducer = maybeReducerWithPrepare;
        }
        sliceCaseReducersByName[reducerName] = caseReducer;
        sliceCaseReducersByType[type] = caseReducer;
        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
      });
      function buildReducer() {
        var _c = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
        var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
        return createReducer(initialState, finalCaseReducers, actionMatchers, defaultCaseReducer);
      }
      var _reducer;
      return {
        name,
        reducer: function(state, action) {
          if (!_reducer)
            _reducer = buildReducer();
          return _reducer(state, action);
        },
        actions: actionCreators,
        caseReducers: sliceCaseReducersByName,
        getInitialState: function() {
          if (!_reducer)
            _reducer = buildReducer();
          return _reducer.getInitialState();
        }
      };
    }
    function getInitialEntityState() {
      return {
        ids: [],
        entities: {}
      };
    }
    function createInitialStateFactory() {
      function getInitialState(additionalState) {
        if (additionalState === void 0) {
          additionalState = {};
        }
        return Object.assign(getInitialEntityState(), additionalState);
      }
      return { getInitialState };
    }
    function createSelectorsFactory() {
      function getSelectors(selectState) {
        var selectIds = function(state) {
          return state.ids;
        };
        var selectEntities = function(state) {
          return state.entities;
        };
        var selectAll = createDraftSafeSelector(selectIds, selectEntities, function(ids, entities) {
          return ids.map(function(id) {
            return entities[id];
          });
        });
        var selectId = function(_, id) {
          return id;
        };
        var selectById = function(entities, id) {
          return entities[id];
        };
        var selectTotal = createDraftSafeSelector(selectIds, function(ids) {
          return ids.length;
        });
        if (!selectState) {
          return {
            selectIds,
            selectEntities,
            selectAll,
            selectTotal,
            selectById: createDraftSafeSelector(selectEntities, selectId, selectById)
          };
        }
        var selectGlobalizedEntities = createDraftSafeSelector(selectState, selectEntities);
        return {
          selectIds: createDraftSafeSelector(selectState, selectIds),
          selectEntities: selectGlobalizedEntities,
          selectAll: createDraftSafeSelector(selectState, selectAll),
          selectTotal: createDraftSafeSelector(selectState, selectTotal),
          selectById: createDraftSafeSelector(selectGlobalizedEntities, selectId, selectById)
        };
      }
      return { getSelectors };
    }
    var import_immer4 = __toModule(require_dist());
    function createSingleArgumentStateOperator(mutator) {
      var operator = createStateOperator(function(_, state) {
        return mutator(state);
      });
      return function operation(state) {
        return operator(state, void 0);
      };
    }
    function createStateOperator(mutator) {
      return function operation(state, arg) {
        function isPayloadActionArgument(arg2) {
          return isFSA(arg2);
        }
        var runMutator = function(draft) {
          if (isPayloadActionArgument(arg)) {
            mutator(arg.payload, draft);
          } else {
            mutator(arg, draft);
          }
        };
        if ((0, import_immer4.isDraft)(state)) {
          runMutator(state);
          return state;
        } else {
          return (0, import_immer4.default)(state, runMutator);
        }
      };
    }
    function selectIdValue(entity, selectId) {
      var key = selectId(entity);
      if (key === void 0) {
        console.warn("The entity passed to the `selectId` implementation returned undefined.", "You should probably provide your own `selectId` implementation.", "The entity that was passed:", entity, "The `selectId` implementation:", selectId.toString());
      }
      return key;
    }
    function ensureEntitiesArray(entities) {
      if (!Array.isArray(entities)) {
        entities = Object.values(entities);
      }
      return entities;
    }
    function splitAddedUpdatedEntities(newEntities, selectId, state) {
      newEntities = ensureEntitiesArray(newEntities);
      var added = [];
      var updated = [];
      for (var _i = 0, newEntities_1 = newEntities; _i < newEntities_1.length; _i++) {
        var entity = newEntities_1[_i];
        var id = selectIdValue(entity, selectId);
        if (id in state.entities) {
          updated.push({ id, changes: entity });
        } else {
          added.push(entity);
        }
      }
      return [added, updated];
    }
    function createUnsortedStateAdapter(selectId) {
      function addOneMutably(entity, state) {
        var key = selectIdValue(entity, selectId);
        if (key in state.entities) {
          return;
        }
        state.ids.push(key);
        state.entities[key] = entity;
      }
      function addManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        for (var _i = 0, newEntities_2 = newEntities; _i < newEntities_2.length; _i++) {
          var entity = newEntities_2[_i];
          addOneMutably(entity, state);
        }
      }
      function setOneMutably(entity, state) {
        var key = selectIdValue(entity, selectId);
        if (!(key in state.entities)) {
          state.ids.push(key);
        }
        state.entities[key] = entity;
      }
      function setManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        for (var _i = 0, newEntities_3 = newEntities; _i < newEntities_3.length; _i++) {
          var entity = newEntities_3[_i];
          setOneMutably(entity, state);
        }
      }
      function setAllMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        state.ids = [];
        state.entities = {};
        addManyMutably(newEntities, state);
      }
      function removeOneMutably(key, state) {
        return removeManyMutably([key], state);
      }
      function removeManyMutably(keys, state) {
        var didMutate = false;
        keys.forEach(function(key) {
          if (key in state.entities) {
            delete state.entities[key];
            didMutate = true;
          }
        });
        if (didMutate) {
          state.ids = state.ids.filter(function(id) {
            return id in state.entities;
          });
        }
      }
      function removeAllMutably(state) {
        Object.assign(state, {
          ids: [],
          entities: {}
        });
      }
      function takeNewKey(keys, update, state) {
        var original2 = state.entities[update.id];
        var updated = Object.assign({}, original2, update.changes);
        var newKey = selectIdValue(updated, selectId);
        var hasNewKey = newKey !== update.id;
        if (hasNewKey) {
          keys[update.id] = newKey;
          delete state.entities[update.id];
        }
        state.entities[newKey] = updated;
        return hasNewKey;
      }
      function updateOneMutably(update, state) {
        return updateManyMutably([update], state);
      }
      function updateManyMutably(updates, state) {
        var newKeys = {};
        var updatesPerEntity = {};
        updates.forEach(function(update) {
          if (update.id in state.entities) {
            updatesPerEntity[update.id] = {
              id: update.id,
              changes: __spreadValues(__spreadValues({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)
            };
          }
        });
        updates = Object.values(updatesPerEntity);
        var didMutateEntities = updates.length > 0;
        if (didMutateEntities) {
          var didMutateIds = updates.filter(function(update) {
            return takeNewKey(newKeys, update, state);
          }).length > 0;
          if (didMutateIds) {
            state.ids = Object.keys(state.entities);
          }
        }
      }
      function upsertOneMutably(entity, state) {
        return upsertManyMutably([entity], state);
      }
      function upsertManyMutably(newEntities, state) {
        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];
        updateManyMutably(updated, state);
        addManyMutably(added, state);
      }
      return {
        removeAll: createSingleArgumentStateOperator(removeAllMutably),
        addOne: createStateOperator(addOneMutably),
        addMany: createStateOperator(addManyMutably),
        setOne: createStateOperator(setOneMutably),
        setMany: createStateOperator(setManyMutably),
        setAll: createStateOperator(setAllMutably),
        updateOne: createStateOperator(updateOneMutably),
        updateMany: createStateOperator(updateManyMutably),
        upsertOne: createStateOperator(upsertOneMutably),
        upsertMany: createStateOperator(upsertManyMutably),
        removeOne: createStateOperator(removeOneMutably),
        removeMany: createStateOperator(removeManyMutably)
      };
    }
    function createSortedStateAdapter(selectId, sort) {
      var _c = createUnsortedStateAdapter(selectId), removeOne = _c.removeOne, removeMany = _c.removeMany, removeAll = _c.removeAll;
      function addOneMutably(entity, state) {
        return addManyMutably([entity], state);
      }
      function addManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        var models = newEntities.filter(function(model) {
          return !(selectIdValue(model, selectId) in state.entities);
        });
        if (models.length !== 0) {
          merge(models, state);
        }
      }
      function setOneMutably(entity, state) {
        return setManyMutably([entity], state);
      }
      function setManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        if (newEntities.length !== 0) {
          merge(newEntities, state);
        }
      }
      function setAllMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        state.entities = {};
        state.ids = [];
        addManyMutably(newEntities, state);
      }
      function updateOneMutably(update, state) {
        return updateManyMutably([update], state);
      }
      function updateManyMutably(updates, state) {
        var appliedUpdates = false;
        for (var _i = 0, updates_1 = updates; _i < updates_1.length; _i++) {
          var update = updates_1[_i];
          var entity = state.entities[update.id];
          if (!entity) {
            continue;
          }
          appliedUpdates = true;
          Object.assign(entity, update.changes);
          var newId = selectId(entity);
          if (update.id !== newId) {
            delete state.entities[update.id];
            state.entities[newId] = entity;
          }
        }
        if (appliedUpdates) {
          resortEntities(state);
        }
      }
      function upsertOneMutably(entity, state) {
        return upsertManyMutably([entity], state);
      }
      function upsertManyMutably(newEntities, state) {
        var _c2 = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c2[0], updated = _c2[1];
        updateManyMutably(updated, state);
        addManyMutably(added, state);
      }
      function areArraysEqual(a, b) {
        if (a.length !== b.length) {
          return false;
        }
        for (var i = 0; i < a.length && i < b.length; i++) {
          if (a[i] === b[i]) {
            continue;
          }
          return false;
        }
        return true;
      }
      function merge(models, state) {
        models.forEach(function(model) {
          state.entities[selectId(model)] = model;
        });
        resortEntities(state);
      }
      function resortEntities(state) {
        var allEntities = Object.values(state.entities);
        allEntities.sort(sort);
        var newSortedIds = allEntities.map(selectId);
        var ids = state.ids;
        if (!areArraysEqual(ids, newSortedIds)) {
          state.ids = newSortedIds;
        }
      }
      return {
        removeOne,
        removeMany,
        removeAll,
        addOne: createStateOperator(addOneMutably),
        updateOne: createStateOperator(updateOneMutably),
        upsertOne: createStateOperator(upsertOneMutably),
        setOne: createStateOperator(setOneMutably),
        setMany: createStateOperator(setManyMutably),
        setAll: createStateOperator(setAllMutably),
        addMany: createStateOperator(addManyMutably),
        updateMany: createStateOperator(updateManyMutably),
        upsertMany: createStateOperator(upsertManyMutably)
      };
    }
    function createEntityAdapter(options) {
      if (options === void 0) {
        options = {};
      }
      var _c = __spreadValues({
        sortComparer: false,
        selectId: function(instance) {
          return instance.id;
        }
      }, options), selectId = _c.selectId, sortComparer = _c.sortComparer;
      var stateFactory = createInitialStateFactory();
      var selectorsFactory = createSelectorsFactory();
      var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);
      return __spreadValues(__spreadValues(__spreadValues({
        selectId,
        sortComparer
      }, stateFactory), selectorsFactory), stateAdapter);
    }
    var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
    var nanoid = function(size) {
      if (size === void 0) {
        size = 21;
      }
      var id = "";
      var i = size;
      while (i--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    var commonProperties = [
      "name",
      "message",
      "stack",
      "code"
    ];
    var RejectWithValue = function() {
      function RejectWithValue2(payload, meta) {
        this.payload = payload;
        this.meta = meta;
      }
      return RejectWithValue2;
    }();
    var FulfillWithMeta = function() {
      function FulfillWithMeta2(payload, meta) {
        this.payload = payload;
        this.meta = meta;
      }
      return FulfillWithMeta2;
    }();
    var miniSerializeError = function(value) {
      if (typeof value === "object" && value !== null) {
        var simpleError = {};
        for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
          var property = commonProperties_1[_i];
          if (typeof value[property] === "string") {
            simpleError[property] = value[property];
          }
        }
        return simpleError;
      }
      return { message: String(value) };
    };
    function createAsyncThunk(typePrefix, payloadCreator, options) {
      var fulfilled = createAction(typePrefix + "/fulfilled", function(payload, requestId, arg, meta) {
        return {
          payload,
          meta: __spreadProps(__spreadValues({}, meta || {}), {
            arg,
            requestId,
            requestStatus: "fulfilled"
          })
        };
      });
      var pending = createAction(typePrefix + "/pending", function(requestId, arg, meta) {
        return {
          payload: void 0,
          meta: __spreadProps(__spreadValues({}, meta || {}), {
            arg,
            requestId,
            requestStatus: "pending"
          })
        };
      });
      var rejected = createAction(typePrefix + "/rejected", function(error, requestId, arg, payload, meta) {
        return {
          payload,
          error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
          meta: __spreadProps(__spreadValues({}, meta || {}), {
            arg,
            requestId,
            rejectedWithValue: !!payload,
            requestStatus: "rejected",
            aborted: (error == null ? void 0 : error.name) === "AbortError",
            condition: (error == null ? void 0 : error.name) === "ConditionError"
          })
        };
      });
      var displayedWarning = false;
      var AC = typeof AbortController !== "undefined" ? AbortController : function() {
        function class_1() {
          this.signal = {
            aborted: false,
            addEventListener: function() {
            },
            dispatchEvent: function() {
              return false;
            },
            onabort: function() {
            },
            removeEventListener: function() {
            },
            reason: void 0,
            throwIfAborted: function() {
            }
          };
        }
        class_1.prototype.abort = function() {
          if (true) {
            if (!displayedWarning) {
              displayedWarning = true;
              console.info("This platform does not implement AbortController. \nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.");
            }
          }
        };
        return class_1;
      }();
      function actionCreator(arg) {
        return function(dispatch, getState, extra) {
          var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
          var abortController = new AC();
          var abortReason;
          var abortedPromise = new Promise(function(_, reject) {
            return abortController.signal.addEventListener("abort", function() {
              return reject({ name: "AbortError", message: abortReason || "Aborted" });
            });
          });
          var started = false;
          function abort(reason) {
            if (started) {
              abortReason = reason;
              abortController.abort();
            }
          }
          var promise = function() {
            return __async(this, null, function() {
              var _a, _b, finalAction, conditionResult, err_1, skipDispatch;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    _c.trys.push([0, 4, , 5]);
                    conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, { getState, extra });
                    if (!isThenable(conditionResult))
                      return [3, 2];
                    return [4, conditionResult];
                  case 1:
                    conditionResult = _c.sent();
                    _c.label = 2;
                  case 2:
                    if (conditionResult === false) {
                      throw {
                        name: "ConditionError",
                        message: "Aborted due to condition callback returning false."
                      };
                    }
                    started = true;
                    dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, { requestId, arg }, { getState, extra })));
                    return [4, Promise.race([
                      abortedPromise,
                      Promise.resolve(payloadCreator(arg, {
                        dispatch,
                        getState,
                        extra,
                        requestId,
                        signal: abortController.signal,
                        rejectWithValue: function(value, meta) {
                          return new RejectWithValue(value, meta);
                        },
                        fulfillWithValue: function(value, meta) {
                          return new FulfillWithMeta(value, meta);
                        }
                      })).then(function(result) {
                        if (result instanceof RejectWithValue) {
                          throw result;
                        }
                        if (result instanceof FulfillWithMeta) {
                          return fulfilled(result.payload, requestId, arg, result.meta);
                        }
                        return fulfilled(result, requestId, arg);
                      })
                    ])];
                  case 3:
                    finalAction = _c.sent();
                    return [3, 5];
                  case 4:
                    err_1 = _c.sent();
                    finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                    return [3, 5];
                  case 5:
                    skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                    if (!skipDispatch) {
                      dispatch(finalAction);
                    }
                    return [2, finalAction];
                }
              });
            });
          }();
          return Object.assign(promise, {
            abort,
            requestId,
            arg,
            unwrap: function() {
              return promise.then(unwrapResult);
            }
          });
        };
      }
      return Object.assign(actionCreator, {
        pending,
        rejected,
        fulfilled,
        typePrefix
      });
    }
    function unwrapResult(action) {
      if (action.meta && action.meta.rejectedWithValue) {
        throw action.payload;
      }
      if (action.error) {
        throw action.error;
      }
      return action.payload;
    }
    function isThenable(value) {
      return value !== null && typeof value === "object" && typeof value.then === "function";
    }
    var hasMatchFunction = function(v) {
      return v && typeof v.match === "function";
    };
    var matches = function(matcher, action) {
      if (hasMatchFunction(matcher)) {
        return matcher.match(action);
      } else {
        return matcher(action);
      }
    };
    function isAnyOf() {
      var matchers = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        matchers[_i] = arguments[_i];
      }
      return function(action) {
        return matchers.some(function(matcher) {
          return matches(matcher, action);
        });
      };
    }
    function isAllOf() {
      var matchers = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        matchers[_i] = arguments[_i];
      }
      return function(action) {
        return matchers.every(function(matcher) {
          return matches(matcher, action);
        });
      };
    }
    function hasExpectedRequestMetadata(action, validStatus) {
      if (!action || !action.meta)
        return false;
      var hasValidRequestId = typeof action.meta.requestId === "string";
      var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
      return hasValidRequestId && hasValidRequestStatus;
    }
    function isAsyncThunkArray(a) {
      return typeof a[0] === "function" && "pending" in a[0] && "fulfilled" in a[0] && "rejected" in a[0];
    }
    function isPending() {
      var asyncThunks = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
      }
      if (asyncThunks.length === 0) {
        return function(action) {
          return hasExpectedRequestMetadata(action, ["pending"]);
        };
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isPending()(asyncThunks[0]);
      }
      return function(action) {
        var matchers = asyncThunks.map(function(asyncThunk) {
          return asyncThunk.pending;
        });
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
      };
    }
    function isRejected() {
      var asyncThunks = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
      }
      if (asyncThunks.length === 0) {
        return function(action) {
          return hasExpectedRequestMetadata(action, ["rejected"]);
        };
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isRejected()(asyncThunks[0]);
      }
      return function(action) {
        var matchers = asyncThunks.map(function(asyncThunk) {
          return asyncThunk.rejected;
        });
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
      };
    }
    function isRejectedWithValue() {
      var asyncThunks = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
      }
      var hasFlag = function(action) {
        return action && action.meta && action.meta.rejectedWithValue;
      };
      if (asyncThunks.length === 0) {
        return function(action) {
          var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);
          return combinedMatcher(action);
        };
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isRejectedWithValue()(asyncThunks[0]);
      }
      return function(action) {
        var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);
        return combinedMatcher(action);
      };
    }
    function isFulfilled() {
      var asyncThunks = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
      }
      if (asyncThunks.length === 0) {
        return function(action) {
          return hasExpectedRequestMetadata(action, ["fulfilled"]);
        };
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isFulfilled()(asyncThunks[0]);
      }
      return function(action) {
        var matchers = asyncThunks.map(function(asyncThunk) {
          return asyncThunk.fulfilled;
        });
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
      };
    }
    function isAsyncThunkAction() {
      var asyncThunks = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
      }
      if (asyncThunks.length === 0) {
        return function(action) {
          return hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]);
        };
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isAsyncThunkAction()(asyncThunks[0]);
      }
      return function(action) {
        var matchers = [];
        for (var _i2 = 0, asyncThunks_1 = asyncThunks; _i2 < asyncThunks_1.length; _i2++) {
          var asyncThunk = asyncThunks_1[_i2];
          matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);
        }
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
      };
    }
    var assertFunction = function(func, expected) {
      if (typeof func !== "function") {
        throw new TypeError(expected + " is not a function");
      }
    };
    var noop = function() {
    };
    var catchRejection = function(promise, onError) {
      if (onError === void 0) {
        onError = noop;
      }
      promise.catch(onError);
      return promise;
    };
    var addAbortSignalListener = function(abortSignal, callback) {
      abortSignal.addEventListener("abort", callback, { once: true });
    };
    var abortControllerWithReason = function(abortController, reason) {
      var signal = abortController.signal;
      if (signal.aborted) {
        return;
      }
      if (!("reason" in signal)) {
        Object.defineProperty(signal, "reason", {
          enumerable: true,
          value: reason,
          configurable: true,
          writable: true
        });
      }
      ;
      abortController.abort(reason);
    };
    var task = "task";
    var listener = "listener";
    var completed = "completed";
    var cancelled = "cancelled";
    var taskCancelled = "task-" + cancelled;
    var taskCompleted = "task-" + completed;
    var listenerCancelled = listener + "-" + cancelled;
    var listenerCompleted = listener + "-" + completed;
    var TaskAbortError = function() {
      function TaskAbortError2(code) {
        this.code = code;
        this.name = "TaskAbortError";
        this.message = task + " " + cancelled + " (reason: " + code + ")";
      }
      return TaskAbortError2;
    }();
    var validateActive = function(signal) {
      if (signal.aborted) {
        throw new TaskAbortError(signal.reason);
      }
    };
    var promisifyAbortSignal = function(signal) {
      return catchRejection(new Promise(function(_, reject) {
        var notifyRejection = function() {
          return reject(new TaskAbortError(signal.reason));
        };
        if (signal.aborted) {
          notifyRejection();
        } else {
          addAbortSignalListener(signal, notifyRejection);
        }
      }));
    };
    var runTask = function(task2, cleanUp) {
      return __async(void 0, null, function() {
        var value, error_1;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _c.trys.push([0, 3, 4, 5]);
              return [4, Promise.resolve()];
            case 1:
              _c.sent();
              return [4, task2()];
            case 2:
              value = _c.sent();
              return [2, {
                status: "ok",
                value
              }];
            case 3:
              error_1 = _c.sent();
              return [2, {
                status: error_1 instanceof TaskAbortError ? "cancelled" : "rejected",
                error: error_1
              }];
            case 4:
              cleanUp == null ? void 0 : cleanUp();
              return [7];
            case 5:
              return [2];
          }
        });
      });
    };
    var createPause = function(signal) {
      return function(promise) {
        return catchRejection(Promise.race([promisifyAbortSignal(signal), promise]).then(function(output) {
          validateActive(signal);
          return output;
        }));
      };
    };
    var createDelay = function(signal) {
      var pause = createPause(signal);
      return function(timeoutMs) {
        return pause(new Promise(function(resolve) {
          return setTimeout(resolve, timeoutMs);
        }));
      };
    };
    var assign = Object.assign;
    var INTERNAL_NIL_TOKEN = {};
    var alm = "listenerMiddleware";
    var createFork = function(parentAbortSignal) {
      var linkControllers = function(controller) {
        return addAbortSignalListener(parentAbortSignal, function() {
          return abortControllerWithReason(controller, parentAbortSignal.reason);
        });
      };
      return function(taskExecutor) {
        assertFunction(taskExecutor, "taskExecutor");
        var childAbortController = new AbortController();
        linkControllers(childAbortController);
        var result = runTask(function() {
          return __async(void 0, null, function() {
            var result2;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  validateActive(parentAbortSignal);
                  validateActive(childAbortController.signal);
                  return [4, taskExecutor({
                    pause: createPause(childAbortController.signal),
                    delay: createDelay(childAbortController.signal),
                    signal: childAbortController.signal
                  })];
                case 1:
                  result2 = _c.sent();
                  validateActive(childAbortController.signal);
                  return [2, result2];
              }
            });
          });
        }, function() {
          return abortControllerWithReason(childAbortController, taskCompleted);
        });
        return {
          result: createPause(parentAbortSignal)(result),
          cancel: function() {
            abortControllerWithReason(childAbortController, taskCancelled);
          }
        };
      };
    };
    var createTakePattern = function(startListening, signal) {
      var take = function(predicate, timeout) {
        return __async(void 0, null, function() {
          var unsubscribe, tuplePromise, promises, output;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                validateActive(signal);
                unsubscribe = function() {
                };
                tuplePromise = new Promise(function(resolve) {
                  unsubscribe = startListening({
                    predicate,
                    effect: function(action, listenerApi) {
                      listenerApi.unsubscribe();
                      resolve([
                        action,
                        listenerApi.getState(),
                        listenerApi.getOriginalState()
                      ]);
                    }
                  });
                });
                promises = [
                  promisifyAbortSignal(signal),
                  tuplePromise
                ];
                if (timeout != null) {
                  promises.push(new Promise(function(resolve) {
                    return setTimeout(resolve, timeout, null);
                  }));
                }
                _c.label = 1;
              case 1:
                _c.trys.push([1, , 3, 4]);
                return [4, Promise.race(promises)];
              case 2:
                output = _c.sent();
                validateActive(signal);
                return [2, output];
              case 3:
                unsubscribe();
                return [7];
              case 4:
                return [2];
            }
          });
        });
      };
      return function(predicate, timeout) {
        return catchRejection(take(predicate, timeout));
      };
    };
    var getListenerEntryPropsFrom = function(options) {
      var type = options.type, actionCreator = options.actionCreator, matcher = options.matcher, predicate = options.predicate, effect = options.effect;
      if (type) {
        predicate = createAction(type).match;
      } else if (actionCreator) {
        type = actionCreator.type;
        predicate = actionCreator.match;
      } else if (matcher) {
        predicate = matcher;
      } else if (predicate) {
      } else {
        throw new Error("Creating or removing a listener requires one of the known fields for matching an action");
      }
      assertFunction(effect, "options.listener");
      return { predicate, type, effect };
    };
    var createListenerEntry = function(options) {
      var _c = getListenerEntryPropsFrom(options), type = _c.type, predicate = _c.predicate, effect = _c.effect;
      var id = nanoid();
      var entry = {
        id,
        effect,
        type,
        predicate,
        pending: /* @__PURE__ */ new Set(),
        unsubscribe: function() {
          throw new Error("Unsubscribe not initialized");
        }
      };
      return entry;
    };
    var createClearListenerMiddleware = function(listenerMap) {
      return function() {
        listenerMap.forEach(cancelActiveListeners);
        listenerMap.clear();
      };
    };
    var safelyNotifyError = function(errorHandler, errorToNotify, errorInfo) {
      try {
        errorHandler(errorToNotify, errorInfo);
      } catch (errorHandlerError) {
        setTimeout(function() {
          throw errorHandlerError;
        }, 0);
      }
    };
    var addListener = createAction(alm + "/add");
    var clearAllListeners = createAction(alm + "/removeAll");
    var removeListener = createAction(alm + "/remove");
    var defaultErrorHandler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      console.error.apply(console, __spreadArray([alm + "/error"], args));
    };
    var cancelActiveListeners = function(entry) {
      entry.pending.forEach(function(controller) {
        abortControllerWithReason(controller, listenerCancelled);
      });
    };
    function createListenerMiddleware(middlewareOptions) {
      var _this = this;
      if (middlewareOptions === void 0) {
        middlewareOptions = {};
      }
      var listenerMap = /* @__PURE__ */ new Map();
      var extra = middlewareOptions.extra, _c = middlewareOptions.onError, onError = _c === void 0 ? defaultErrorHandler : _c;
      assertFunction(onError, "onError");
      var insertEntry = function(entry) {
        entry.unsubscribe = function() {
          return listenerMap.delete(entry.id);
        };
        listenerMap.set(entry.id, entry);
        return function(cancelOptions) {
          entry.unsubscribe();
          if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {
            cancelActiveListeners(entry);
          }
        };
      };
      var findListenerEntry = function(comparator) {
        for (var _i = 0, _c2 = Array.from(listenerMap.values()); _i < _c2.length; _i++) {
          var entry = _c2[_i];
          if (comparator(entry)) {
            return entry;
          }
        }
        return void 0;
      };
      var startListening = function(options) {
        var entry = findListenerEntry(function(existingEntry) {
          return existingEntry.effect === options.effect;
        });
        if (!entry) {
          entry = createListenerEntry(options);
        }
        return insertEntry(entry);
      };
      var stopListening = function(options) {
        var _c2 = getListenerEntryPropsFrom(options), type = _c2.type, effect = _c2.effect, predicate = _c2.predicate;
        var entry = findListenerEntry(function(entry2) {
          var matchPredicateOrType = typeof type === "string" ? entry2.type === type : entry2.predicate === predicate;
          return matchPredicateOrType && entry2.effect === effect;
        });
        if (entry) {
          entry.unsubscribe();
          if (options.cancelActive) {
            cancelActiveListeners(entry);
          }
        }
        return !!entry;
      };
      var notifyListener = function(entry, action, api, getOriginalState) {
        return __async(_this, null, function() {
          var internalTaskController, take, listenerError_1;
          return __generator(this, function(_c2) {
            switch (_c2.label) {
              case 0:
                internalTaskController = new AbortController();
                take = createTakePattern(startListening, internalTaskController.signal);
                _c2.label = 1;
              case 1:
                _c2.trys.push([1, 3, 4, 5]);
                entry.pending.add(internalTaskController);
                return [4, Promise.resolve(entry.effect(action, assign({}, api, {
                  getOriginalState,
                  condition: function(predicate, timeout) {
                    return take(predicate, timeout).then(Boolean);
                  },
                  take,
                  delay: createDelay(internalTaskController.signal),
                  pause: createPause(internalTaskController.signal),
                  extra,
                  signal: internalTaskController.signal,
                  fork: createFork(internalTaskController.signal),
                  unsubscribe: entry.unsubscribe,
                  subscribe: function() {
                    listenerMap.set(entry.id, entry);
                  },
                  cancelActiveListeners: function() {
                    entry.pending.forEach(function(controller, _, set) {
                      if (controller !== internalTaskController) {
                        abortControllerWithReason(controller, listenerCancelled);
                        set.delete(controller);
                      }
                    });
                  }
                })))];
              case 2:
                _c2.sent();
                return [3, 5];
              case 3:
                listenerError_1 = _c2.sent();
                if (!(listenerError_1 instanceof TaskAbortError)) {
                  safelyNotifyError(onError, listenerError_1, {
                    raisedBy: "effect"
                  });
                }
                return [3, 5];
              case 4:
                abortControllerWithReason(internalTaskController, listenerCompleted);
                entry.pending.delete(internalTaskController);
                return [7];
              case 5:
                return [2];
            }
          });
        });
      };
      var clearListenerMiddleware = createClearListenerMiddleware(listenerMap);
      var middleware = function(api) {
        return function(next) {
          return function(action) {
            if (addListener.match(action)) {
              return startListening(action.payload);
            }
            if (clearAllListeners.match(action)) {
              clearListenerMiddleware();
              return;
            }
            if (removeListener.match(action)) {
              return stopListening(action.payload);
            }
            var originalState = api.getState();
            var getOriginalState = function() {
              if (originalState === INTERNAL_NIL_TOKEN) {
                throw new Error(alm + ": getOriginalState can only be called synchronously");
              }
              return originalState;
            };
            var result;
            try {
              result = next(action);
              if (listenerMap.size > 0) {
                var currentState = api.getState();
                var listenerEntries = Array.from(listenerMap.values());
                for (var _i = 0, listenerEntries_1 = listenerEntries; _i < listenerEntries_1.length; _i++) {
                  var entry = listenerEntries_1[_i];
                  var runListener = false;
                  try {
                    runListener = entry.predicate(action, currentState, originalState);
                  } catch (predicateError) {
                    runListener = false;
                    safelyNotifyError(onError, predicateError, {
                      raisedBy: "predicate"
                    });
                  }
                  if (!runListener) {
                    continue;
                  }
                  notifyListener(entry, action, api, getOriginalState);
                }
              }
            } finally {
              originalState = INTERNAL_NIL_TOKEN;
            }
            return result;
          };
        };
      };
      return {
        middleware,
        startListening,
        stopListening,
        clearListeners: clearListenerMiddleware
      };
    }
    (0, import_immer5.enableES5)();
  }
});

// node_modules/@reduxjs/toolkit/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@reduxjs/toolkit/dist/index.js"(exports, module) {
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_redux_toolkit_cjs_development();
    }
  }
});
export default require_dist2();
//# sourceMappingURL=@reduxjs_toolkit_dist.js.map
